
! COPY this file to a empty DISK 2 or 3, named "BATCH"  then type:
! CALL USER("DSK1.BATCH")

! Print out a copy to follow
! along with the program

! PRESS ANY KEY
CALL KEY("",5,K,S)
NEW
! As you can see RXB KEY 
! has been modified to 
! accept empty strings

! PRESS ANY KEY
CALL KEY("",5,K,S)
NEW
CALL QUITON

! To follow along with this  
! demo print it out first
! Demo creates XB programs

! PRESS ANY KEY TO CONTINUE

! PRESS QUIT TO EXIT USER

CALL KEY("",5,K,S)
NEW
! RXB CALL KEY UPDATED

! Normal XB split keyboard
CALL KEY(1,A,X) :: CALL KEY(2,B,Y)

! RXB UPDATE split keyboard
CALL KEY(1,A,X,2,B,Y)

! See no double Colon needed 
! or RXB saves typing

! (HINT: press space bar)
CALL KEY(" ",5,K,S)
NEW
! RXB ADDS A STRING CHECK

! (HINT: press Y N y n)

CALL KEY("YyNn",5,K,S)

! (HINT: press a number)

CALL KEY("1234567890",5,K,S)

! (HINT: press ENTER)

CALL KEY(CHR$(13),5,K,S)

! (HINT: press a symbol)

V$="`~!@#$%^&*()-_=+[]\{}|"

CALL KEY(V$,5,K,S)

! Much less XB code in RXB 
! than in normal XB to do
! same thing

CALL KEY("",5,K,S)
NEW
100 ! Normal XB CALL KEY      routine vs RXBONKEY
110 CALL CLEAR
120 PRINT "XB CHOOSE A KEY:":"Yes, No, Maybe, End"
130 CALL KEY(3,K,S)
140 IF K=89 THEN PRINT "YES" :: GOTO 130
150 IF K=78 THEN PRINT "NO" :: GOTO 130
160 IF K=77 THEN PRINT "MAYBE" :: GOTO 130
170 IF K=69 THEN PRINT "END" :: GOTO 190
180 GOTO 130
190 ! RXB  CALL ONKEY routine
200 ! RXB CALL ONKEY
210 CALL CLEAR
220 PRINT "RXB CHOOSE A KEY:":"Yes, No, Maybe, End"
230 CALL ONKEY("YNME",3,K,S)GOTO 250,260,280,280
240 GOTO 230
250 PRINT "Yes!" :: GOTO 230
260 PRINT "Nn!" :: GOTO 230
270 PRINT "Maybe" :: GOTO 230
280 PRINT "End!"

SAVE DSK1.RXBONKEY,IV254
NEW 
! RXB can save files in     Internal Format on most XB  programs but the catch is   must be over 288 bytes in   size thus converted to IV254
! XB program are normally   Program Image format so can be confused with normally   Assembly Language Program   files
! RXB fixed this so you can save programs in Internal   Variable 254 format
CALL KEY("",5,K,S)
NEW
! This is done by how you   save those programs         EXAMPLE:
! SAVE DSK1.PRGMNAME,IV254
! See the comma and IV254?

CALL KEY("",5,K,S)
NEW
! RXB can save most files inINTERNAL VARIABLE 254 formatinstead of PROGRAM format
! RXB makes cataloging filesbetter for you to use as    PROGRAM format is confused  with Assembly Programs often, so  RXB fixed this!
! Tack a comma and IV254 to change from XB Program      Image to IV254 format
! EXAMPLE:                  SAVE "DSK1.IV-Format",IV254

CALL KEY("",5,K,S)
NEW
! See above comma and IV254 this is an added RXB option
! Now if the XB program is  smaller then 2 sectors it   will be saved in program    image format instead the    reason is 254 filler bytes  waste space

CALL KEY("",5,K,S)
NEW
1 ! MERGE TO SHOW ADDRESS     AND LINE SIZE OF PROGRAMS
2 CALL CLEAR :: PRINT:"Output to Device? (Y/N)" :: CALL KEY("YN",3,K,S) :: IF K=89 THEN INPUT "DEVICE:":Z$ :: OPEN #1:Z$,OUTPUT :: P=1
3 CALL CLEAR :: CALL PEEK(-31952,A,B,C,D) :: A=A*256+B-65536 :: C=C*256+D-65536 :: PRINT #P:"    PROGRAM INFORMATION": :"Line Number Table" :: CALL HEX(A,A$,C,C$)
4 PRINT #P: :"Start Address ";A$:"End   Address ";C$: : :"Line    Bytes Start":"Number  Used  Address":"------  ----- -------"
5 FOR I=C-3 TO A STEP-4 :: CALL PEEK(I,B,D,E,F) :: B=B*256+D :: E=E*256+F-65536 :: CALL PEEK(E-1,D) :: D=D+5 :: T=T+D :: CALL HEX(E,E$)
6 PRINT #P,USING "#####     ###  ######":B,D,E$ :: IF E THEN CALL SCREEN(6) :: GOSUB 8
7 NEXT I :: A=(A-C-1)/-4 :: PRINT #P: : :TAB(8);"Total Bytes =";T:"   Number of lines =";A:"Average Bytes/Line =";INT(T/A) :: STOP
8 IF Z$="" THEN CALL KEY("",3,D,E) :: CALL SCREEN(8) :: RETURN ELSE RETURN


SAVE "DSK1.LINESHOW",MERGE
CALL KEY("",5,K,S)
NEW
100 ! CHAR HAS BEEN MODIFIEDIN RXB TO REPEAT AFTER A    COMMA
110 CALL CHAR(65,"FF00FFEE00FF8899") :: CALL CHAR(66,"454567656895439")! NORMAL XB
120 !
130 CALL CHAR(65,"FF00FFEE00FF8899",66,"454567656895439")! RXB CALL CHAR
140 !
150 CALL CHAR(ALL,"FFEEDDCCBBAA0099")! RXB ADDED ALL

SAVE DSK1.CHAR,IV254
NEW
100 ! HCHAR RXB VERSION HAS ADDED A AUTOREPEAT AFTER A  COMMA
110 CALL HCHAR(3,4,44,4) :: CALL HCHAR(6,8,47,8) :: CALL HCHAR(11,14,53,9) :: CALL HCHAR(20,8,77,11)! XB VERSION
120 CALL HCHAR(3,4,44,4,6,8,47,8,11,14,53,9,20,8,77,11)! THIS IS RXB VERSION

SAVE DSK1.HCHAR,IV254
NEW
100 ! GHCAR RXB VERSION HAS ADDED A AUTOREPEAT AFTER A  COMMA
110 CALL GCHAR(3,4,A) :: CALL GCHAR(6,8,B) :: CALL GCHAR(11,14,C) :: CALL GCHAR(20,8,D)! XB VERSION
120 CALL GCHAR(3,4,A,6,8,B,11,14,C,20,8,D)! RXB VERSION

SAVE DSK1.GCHAR,IV254
NEW
100 ! HEX IS A RXB DECIMAL  TO HEX CONVERTER FOR ADDRESSIN TI
110 ! SEE THE HEXDECBIN PGM
120 FOR D=-32767 TO 32767
130 CALL HEX(D,H$)
140 PRINT D,H$
150 NEXT D

SAVE DSK1.HEX,IV254
NEW
100 ! HPUT IS A RXB PROGRAM THAT TAKES A STRING VARIABLEAND PUTS IT ON THE SCREEN
105 CALL CLEAR
110 CALL HCHAR(9,9,44,3,9,12,45,3,9,15,46,3,9,18,47,3) ! RXB HCHAR
120 X$=",,,---...///" :: CALL HPUT(3,9,X$) !      HPUT PUTS AT 3,9 X$ ON THE  SCREEN
130 GOTO 130

SAVE DSK1.HPUT,IV254
NEW
100 ! HGET IS A RXB PROGRAM THAT GETS A STRING OFF THE  SCREEN AND PUTS IT INTO A   STRING VARIBLE
110 CALL GCHAR(3,9,A,3,10,B,3,11,C,3,12,D)! RXB GCHAR
120 CALL HGET(3,9,4,X$)!    HGET 4 CHARACTERS AT 3,9 ANDPUTS THEM INTO X$

SAVE DSK1.HGET,IV254
NEW
100 ! INIT IN RXB DOES NOT  HAVE TO BE USED BEFORE LINK OR LOAD
110 CALL INIT! FIXED INIT  AS IT LOADED TO MUCH UNUSED DATA IN LOWER 8K
120 ! ALSO THIS WAS NOTED   IN THE ORGINAL XB SOURCE    CODE I HAVE FROM TI

SAVE DSK1.INIT,IV254
NEW
100 ! PEEKG IS A RXB COMMANDFOR PEEKING GRAM/GROM
110 CALL PEEKG(24576,X)!   PEEK GRAM/GROM AT >6000

SAVE DSK1.PEEKG,IV254
NEW
100 ! PEEKV IS A RXB COMMANDFOR PEEKING VDP
110 FOR X=16370 TO 16383
120 CALL PEEKV(X,Y)! PEEK  VDP AT X AND PUT INTO Y
130 PRINT X,CHR$(Y);Y
140 NEXT X

SAVE DSK1.PEEKV,IV254
NEW
100 ! POKEG IS A RXB COMMANDFOR PUTTING VALUES INTO GRAM
120 CALL POKEG(-8,22)! PUT  22 >16 AT ADDRESS -8 >FFF8  IN GRAM

SAVE DSK1.POKEG,IV254
NEW
100 ! POKER IS A RXB COMMANDFOR PUTTING VALUES INTO THE VDP REGISTERS 0 TO 7
110 CALL POKER(7,244,1,240)! SET RXB TO TEXT MODE
120 FOR D=0 TO 1E2 :: NEXT D
130 CALL POKER(1,232)!       SET RXB TO MULTI COLOR MODE
140 FOR D=0 TO 1E2 :: NEXT D
150 CALL POKER(0,2,1,2)!    SET RXB TO BIT MAP MODE
160 FOR D=0 TO 1E2 :: NEXT D
170 CALL POKER(0,224,0,32)! RXB NORMAL MODE

SAVE DSK1.POKER,IV254
NEW
100 ! POKEV IS A RXB COMMANDFOR PUTTING VALUES INTO VDP
120 CALL POKEV(512,65+96)!  PUT CHARACTER A AT ADDRESS  512 (32*16) ON SCREEN
130 ! A BIAS OF 96 MUST BE  ADDED TO CHARACTERS WHEN PUTON SCREEN

SAVE DSK1.POKEV,IV254
NEW
! RXB also has a catalog    routine CALL CAT(1) or
!  CALL CAT("DSK1.") or     CALL CAT(49) this would be  char 1 in ASCII
! RXB is smarter then most  other XB versions to catalogdrives
! RAMDISK can use           CALL CAT("DSKA.") or        CALL CAT(65) or CALL CAT(A)
 
CALL KEY("",5,K,S)
NEW
CALL CAT(49)
! That was using            CALL CAT(49)                character 1 in ASCII

! Notice the LINESHOW 4     sectors long & MERGE format.

CALL KEY("",5,K,S)
NEW
! RXB CALL JOYST UPDATED

! NORMAL XB

CALL JOYST(1,A,B) :: CALL JOYST(2,C,D)

! RXB UPDATE less typing

CALL JOYST(1,A,B,2,C,D)

CALL KEY("",5,K,S)
NEW 
! JOYLOCATE and JOYMOTION
! JOYLOCATE is like you     combined 
! JOYST+LOCATE+IF key THEN  LINE NUMBER
! JOYMOTION is like you     combined
! JOYST+MOTION+IF key THEN  LINE NUMBER
! (way faster then normal   XB response times)

CALL KEY("",5,K,S)
NEW
! RXB CALL COLOR UPDATED

! NORMAL XB

FOR L=0 TO 14 :: CALL COLOR(L,2,11) :: NEXT L

! RXB COLOR UPDATE

CALL COLOR(ALL,2,11)

! RXB is much faster

CALL KEY("",5,K,S)
NEW
! RXB CALL GCHAR UPDATED
! NORMAL XB

CALL GCHAR(22,3,A) :: CALL GCHAR(22,4,B) :: CALL GCHAR(22,5,C)

! RXB GCHAR UPDATE

CALL GCHAR(22,3,A,22,4,B,22,5,C)

! As you can see saves bytesand much faster 
CALL KEY("",5,K,S)
NEW
! RXB has HGET like GCHAR   but unlike multiple GCHAR   only 1 character at a time 
! RXB has a huge advantage  for saving program space    and making faster programs

CALL HGET(23,1,14,X$)
CALL VGET(21,3,4,Y$)

! The two lines above would take many lines of GCHAR to do same thing and slower too
CALL KEY("",5,K,S)

PRINT X$:Y$

! HGET & VGET are way betterthen GCHAR to use obviously

CALL KEY("",5,K,S)
NEW
! RXB CALL HCHAR UPDATED    ALSO VCHAR UPDATED    

! NORMAL XB
CALL HCHAR(10,25,33,5) :: CALL HCHAR(11,25,33,6) :: CALL HCHAR(12,25,33,7)

! RXB UPDATE
CALL HCHAR(18,25,33,5,19,25,33,6,20,25,33,7)

! NOTICE RXB version must   have number of characters   to repeat or errors out 

CALL KEY("",5,K,S)
NEW
! RXB has HPUT like HCHAR & VCHAR but like mulitple ones in a row

CALL KEY("",5,K,S)
NEW
CALL HPUT(15,1,"HPUT TEST")
CALL VPUT(15,1,"VPUT TEST")

! Better then DISPLAY AT as uses entire screen and does vertical + horizontal

CALL KEY("",5,K,S)

NEW
! RXB CALL VERSION UPDATED

CALL VERSION(A) :: PRINT A

CALL KEY("",5,K,S)
NEW

! NEW RXB SOUND SUBROUTINES

CALL BEEP

! NEW RXB SUBROUTINE

CALL HONK

CALL KEY("",5,K,S)

NEW
! Create a XB program

100 REM Test
110 PRINT "THIS IS A TEST PROGRAM"
120 CALL BEEP
130 END

! SAVE THE PROGRAM

SAVE DSK1.TEST

CALL KEY("",5,K,S)
NEW
! HOW TO EDIT IN USER

OLD DSK1.TEST

RES 1000,100
NUM 1010,111
! REMARK HERE
! SHOW IT
! LET THEM KNOW IT
! DONE

LIST

RES 100,5

CALL KEY("",5,K,S)
LIST

SAVE DSK1.TEST2

CALL KEY("",5,K,S)
NEW
! RUN PROGRAMS BUT GO BACK   TO USER

CALL KEY("",5,K,S)
RUN "DSK1.TEST"
RUN "DSK1.TEST2"

CALL KEY("",5,K,S)
NEW
! MERGE PROGRAMS AND RUN

OLD DSK1.TEST2

RES 3333,4
SAVE DSK1.TEST3,MERGE

LIST

CALL KEY("",5,K,S)
NEW
OLD DSK1.TEST
MERGE DSK1.TEST3

LIST

CALL KEY("",5,K,S)

SAVE DSK1.MPGM,IV254
LIST

CALL KEY("",5,K,S)
NEW
! RXB IMPROVED SIZE
SIZE
CALL KEY("",5,K,S)
NEW
! NOW YOU SEE FREE SPACE ANDTHE FIRST FREE ADDRESS      LOCATION IN SIZE ALSO NOW   ASSEMBLY SIZE AND LOCATIONS OF MEMORY

CALL KEY("",5,K,S)
10 CALL INIT :: CALL SIZE
20 CALL KEY("",5,K,S)
RUN
! SEE LOWER 8K CHANGED?

CALL KEY("",5,K,S)
NEW
! New RXB VDPSTACK MANAGER

! Changing VDPSTACK triggersreset VDP & Program space sodoes a NEW after changes

! 10 CALL VDPSTACK(2392)
! >0958 STACK 
!NORMAL VDP STACK LOCATION

CALL KEY("",5,K,S)
10 CALL VDPSTACK(2392)

CALL KEY("",5,K,S)
RUN
SIZE
CALL KEY("",5,K,S)
! New RXB VDPSTACK MANAGER

! CALL VDPSTACK(4096)
! >1000 VDP STACK LOCATION

CALL KEY("",5,K,S)
CALL VDPSTACK(4096)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB VDPSTACK MANAGER

! CALL VDPSTACK(6176)
! >1820 VDP STACK LOCATION

CALL KEY("",5,K,S)
CALL VDPSTACK(6176)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB VDPSTACK MANAGER

! CALL VDPSTACK(2392)
! >0958 STACK

!NORMAL STACK LOCATION

CALL KEY("",5,K,S)
CALL VDPSTACK(2392)
SIZE
CALL KEY("",5,K,S)
NEW
! RXB PROGRAM RAM MANAGER

! CALL PRAM(START-ADDRESS,  END-ADDRESS)
! Normal XB START >FFE7     (-25 DECIMAL)
! Normal XB END   >A040     (-24512 DECIMAL)
! 24K RAM minus 64 bytes

! CALL PRAM(-25,-24512)     (default previous value)
CALL KEY("",5,K,S)
CALL PRAM(-25,-24512)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! How about full 24K RAM
! START >FFFF               (24K+DEBUGGER)
! END >A000                 (24K+64 BYTES RAM)
! FULL 24K OF RAM FINALLY
! CALL PRAM(-1,-24576)

CALL KEY("",5,K,S)
CALL PRAM(-1,-24576)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >F000               (New high address)  
! END >B000                 (16K RAM)
! CALL PRAM(-4096,-20480)

CALL KEY("",5,K,S)
CALL PRAM(-4096,-20480)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >FFE7               (Normal XB address)
! END >E000                 (8K-8 BYTES RAM)
! CALL PRAM(-25,-8192)

CALL KEY("",5,K,S)
CALL PRAM(-25,-8192)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >D000               (New high address)
! END >C000                 (4K RAM)
! CALL PRAM(-12288,-16384)

CALL KEY("",5,K,S)
CALL PRAM(-12288,-16384)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >FFFF               (TI Debug area)
! END >FFE7                 (Normal XB High address)             
! (25 BYTES RAM)
! CALL PRAM(-1,-25)

CALL KEY("",5,K,S)
CALL PRAM(-1,-25)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >FFE7               (Normal XB High address)
! END >FFE6                 (1024 BYTES RAM)
! CALL PRAM(-25,-1048)

CALL KEY("",5,K,S)
CALL PRAM(-25,-1048)
SIZE 
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER
! OR this way too
! START >FFFF               (TI Debugger area)
! END >FF00                 (256 BYTES RAM)
! CALL PRAM(-1,-256)

CALL KEY("",5,K,S)
CALL PRAM(-1,-256)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! RESET RAM TO NORMAL START
! RESET RAM TO NORMAL END
! CALL PRAM(-25,-24512)

CALL KEY("",5,K,S)
CALL PRAM(-25,-24512)
SIZE
CALL KEY("",5,K,S)
NEW
10 ! If RXB has not blown   your mind watch this!

110 CALL FILES(0) 

120 ! You can do CALL FILES  from program mode now!

130 ! But notice 0 files?

140 ! RXB can do CALL FILES  with a modified 0 files!

150 ! RXB executes a NEW     after the CALL FILES so     you do not have to do that  and in PROGRAM MODE or      EDIT MODE for you!

CALL KEY("",5,K,S)
SAVE "DSK1.CALLFILES",IV254
NEW
! RXB has CALL XB that will return to start title       screen or can be used like  RUN programs. EXAMPLE:
! CALL XB("DSK1.XBFILE")
! Additonally CALL FILES is also built into CALL XB     EXMPLE:
! CALL XB("DSK1.PGM",file#) 
! RXB allows 0 to 15 Files 

CALL KEY("",5,K,S)
NEW
! TRACE FROM USER

OLD DSK1.TEST

TRACE

RUN

UNTRACE

CALL KEY("",5,K,S)
NEW
! USER IGNORES ERRORS

NUM
! ERRORS IN USER
GOTO 1000

RUN

! SAME AS BREAK OR FCTN4    (By the way FCTN4 does not  work in USER)

CALL KEY("",5,K,S)
NEW
100 ! NEW IN RXB IS LIKE IN XB BUT CAN BE CALLED IN A   PROGRAM
110 CALL NEW! PROGRAM IS    ERASED AND DEFAULTS TO THE  COMMAND MODE
120 ! RXB DOCUMENTS SHOW    CALL NEW IS FOR THE USER    RXB COMMAND RUN THAT DEMO
    
CALL KEY("",5,K,S)
SAVE DSK1.NEW,IV254
RUN
100 ! NORMAL XB CLOSE
110 OPEN #1:"DSK1.FILE1"
120 OPEN #2:"DSK1.FILE2"
130 CLOSE #1
140 CLOSE #2

200 ! RXB CLOSE ALL
210 OPEN #1:"DSK1.FILE1"
220 OPEN #2:"DSK1.FILE2"
230 CALL CLSALL

CALL KEY("",5,K,S)
SAVE DSK1.CLSALL,IV254
NEW 
1 ! Use this to convert       plain text to RXB USER files
100 ON ERROR 170
110 OPEN #1:"DSK1.USERDEMO",INPUT
120 OPEN #2:"DSK1.BATCH",OUTPUT
130 LINPUT #1:Z$
140 IF LEN(Z$)=80 THEN X$=X$&Z$ :: GOTO 130
150 IF LEN(Z$)<80 THEN PRINT #2:X$&Z$&CHR$(13)
160 X$,Z$="" :: GOTO 130
170 CALL CLSALL
180 END

SAVE DSK1.DV80TOUSER,IV254
NEW
! RXB Binary SAVE routine   called BSAVE and BLOAD have been changed to PSAVE and   PLOAD 
! The previous version 2015 were 8K sized files but 2020versions are 4K in size     files
! This change was for SAMS  support as any 4K page can  be loaded or saved          anywhere in RAM now
! To explain 2,3,A,B,C,D,E,Fis the HEX location of RAM  boundries thus RXB can load 4K files into RAM for SAMS 

CALL KEY("",5,K,S)
NEW
100 CALL CLEAR
110 CALL MAGNIFY(2)
120 CALL SCREEN(15)
130 CALL COLOR(1,1,15)
140 FOR S=2 TO 8
150 CALL COLOR(S,2,15)
160 NEXT S
170 CALL SPRITE(#1,87,13,84,26)
180 CALL SPRITE(#2,73,13,58,58)
190 CALL SPRITE(#3,78,13,32,90)
200 CALL SPRITE(#4,68,13,58,122)
210 CALL SPRITE(#5,89,13,32,154)
220 CALL SPRITE(#6,88,13,58,186)
230 CALL SPRITE(#7,66,13,84,218)
240 CALL SPRITE(#8,51,12,128,90)
250 CALL SPRITE(#9,46,12,128,122)
260 CALL SPRITE(#10,48,12,128,154)
270 CALL SPRITE(#11,42,5,1,1,0,127)
280 CALL SPRITE(#12,42,5,1,243,127,0)
290 CALL SPRITE(#13,42,5,176,243,0,-127)
300 CALL SPRITE(#14,42,5,176,1,-127,0)
310 CALL SPRITE(#15,42,16,1,128,0,111)
320 CALL SPRITE(#16,42,16,96,243,111,0)
330 CALL SPRITE(#17,42,16,176,128,0,-111)
340 CALL SPRITE(#18,42,16,96,1,-111,0)
350 CALL SPRITE(#19,42,7,1,1,0,99)
360 CALL SPRITE(#20,42,7,1,243,99,0)
370 CALL SPRITE(#21,42,7,176,243,0,-99)
380 CALL SPRITE(#22,42,7,176,1,-99,0)
390 FOR R=3 TO 21
400 CALL HPUT(R,3,RPT$("a",28))
410 NEXT R
420 CALL CHAR(97,"00FF00FF00FF00FF")
430 ! THIS IS HOW THE TITLE SCREEN WAS CREATED AND WAS  SAVED
440 CALL HCHAR(3,3,96,28)
450 CALL VCHAR(3,3,96,20)
460 CALL HCHAR(22,3,96,28)
470 CALL VCHAR(3,30,96,20)
480 CALL HPUT(15,5,"RICHARD LYNN GILBERTSON")
490 CALL HPUT(20,9,"<<<PUSH A KEY>>>")
500 ! LOOP HERE FOR MOVEMENT
510 CALL CHAR(96,"FF818181818181FF")
520 IF RND>.5 THEN CALL COLOR(9,RND*15+1,15)
530 CALL CHAR(96,"00E7E7E7E7E7E700")
540 CALL KEY(0,K,S):: IF S=0 THEN 510
550 ! GET SPRITE MOTION IN N
560 CALL PEEK(-31878,N)
570 ! MOVE VDP TO LOW 8K RAM
580 CALL MOVES("VR",2079,0,8192)
590 ! SAVE RAM TO DISK
600 CALL PSAVE(2,"DSK1.SCREEN")

! SET UP SCREEN AND PSAVE IT

CALL KEY("",5,K,S)
SAVE DSK1.PSAVESCRN,IV254
RUN
100 ! RELOAD SAVED MEMORY
110 CALL PLOAD(2,"DSK1.SCREEN")
120 ! RESET MAGNIFICATION
130 CALL MAGNIFY(2) :: CALL SCREEN(15)
140 ! MOVE FROM RAM TO VDP
150 CALL MOVES("RV",2079,8192,0)
160 ! RESET SPRITE MOTION
170 CALL LOAD(-31878,22)
180 ! LOOP HERE FOR MOVEMENT.
190 CALL CHAR(96,"FF818181818181FF") :: IF RND>.5 THEN CALL COLOR(9,RND*16,15)
200 CALL CHAR(96,"00E7E7E7E7E7E700")
210 CALL KEY(5,K,S):: IF S=0 THEN 190

CALL KEY("",5,K,S)
SAVE DSK1.PLOADSCRN,IV254
RUN
NEW
! RXB has built in support  for SAMS memory card or     sidecar up to 64 Meg SAMS

! PSAVE and PLOAD are used  to SAVE and LOAD SAMS pages 4K at a time

! Access to SAMS is using   CALL SAMS(boundry,page#) 

! boundry = 2,3,A,B,C,D,E,F page# = 0 to 65536 4K pages

! Of course this requires   a SAMS memory card 

CALL KEY("",5,K,S)
NEW
! RXB has built in support  subprograms so this will    show them to you

! This RXB program uses     CALL PEEKG that is a        peek GROM routine

! This RXB program also     finds the address of that   subprogram in GROM

! Lastly it shows the link  to next subprogram and      the actual address in GROM

CALL KEY("",5,K,S)
NEW 
10 ! RXB EXAMPLE             RXB SUBPROGRAM FINDER
100 CALL CLEAR :: ADDRESS=-24538
110 RESTORE :: FOR I=1 TO 2 :: READ X$,Y$,Z$ :: PRINT X$;TAB(11);Y$;TAB(22);Z$ :: NEXT I
120 CALL PEEKG(ADDRESS,B1,B2) :: CALL HEX(B1,B1$,B2,B2$) :: ADDRESS$=SEG$(B1$,3,2)&SEG$(B2$,3,2)
130 CALL PEEKG(ADDRESS+2,LENGTH)
140 CALL MOVES("G$",LENGTH,ADDRESS+3,N$)
150 CALL PEEKG(ADDRESS+3+LENGTH,S1,S2) :: CALL HEX(S1,S1$,S2,S2$) :: S$=SEG$(S1$,3,2)&SEG$(S2$,3,2)
160 CALL HEX(ADDRESS,A$) :: PRINT A$;"-";ADDRESS$;" ";TAB(11);N$;" ";TAB(22);S$ :: PRINT
170 DATA HEADER,SUBPROGRAM,START,*******,**********,*******
180 CALL HEX(ADDRESS$,ADDRESS) :: IF ADDRESS THEN 120

SAVE DSK1.SUBPGMFNDR,IV254
RUN
CALL KEY("",5,K,S)
NEW
! Lets create a USER file   while in USER running a     USER DV80 file?
! Yea that is right we are  going to create a DV80 file from DV80 and run it!
CALL KEY("",5,K,S)

! CREATE A USER FILE FROM   USER FILE

OPEN #1:"DSK1.TEST-USER",OUTPUT
PRINT #1:"1 CALL CLEAR ! TEST OF USER"&CHR$(13)
PRINT #1:"2 A$="&CHR$(34)&" RXB USER "&CHR$(34)&CHR$(13)
PRINT #1:"3 B$="&CHR$(34)&"   DEMO   "&CHR$(34)&CHR$(13)
PRINT #1:"4 C$="&CHR$(34)&" FINISHED "&CHR$(34)&CHR$(13)
PRINT #1:"5 CALL HPUT(12,11,A$,14,11,B$,16,11,C$)"&CHR$(13)
PRINT #1:"6 PRINT "&CHR$(34)&"PLEASE WAIT!"&CHR$(34)&CHR$(13)
PRINT #1:"7 FOR C=1 TO 5000 :: NEXT C"&CHR$(13)
PRINT #1:"8 CALL XB("&CHR$(34)&"DSK1.LOADER"&CHR$(34)&")"&CHR$(13)
PRINT #1:"RUN"&CHR$(13)
CLOSE #1

CALL KEY("",5,K,S)
NEW
! Find file named TEST-USER 

CALL KEY("",5,K,S)
CALL CAT("DSK1.")

CALL KEY("",5,K,S)
NEW
! USER in this demo just    created files on DSK1

! USER CAN CALL USER FILES  IF IT IS THE LAST COMMAND

! OK NOW WE ARE GOING TO    MAKE A TON OF RXB PROGRAMS
! THIS IS GOING TO TAKE     SOMETIME TO MAKE THEM...

CALL KEY("",5,K,S)
NEW
100 ! Normal XB CALL KEY      routine vs RXBONKEY
110 CALL CLEAR
120 PRINT "XB CHOOSE A KEY:":"Yes, No, Maybe, End"
130 CALL KEY(3,K,S)
140 IF K=89 THEN PRINT "YES" :: GOTO 130
150 IF K=78 THEN PRINT "NO" :: GOTO 130
160 IF K=77 THEN PRINT "MAYBE" :: GOTO 130
170 IF K=69 THEN PRINT "END" :: GOTO 190
180 GOTO 130
190 ! RXB  CALL ONKEY routine
200 ! RXB CALL ONKEY
210 CALL CLEAR
220 PRINT "RXB CHOOSE A KEY:":"Yes, No, Maybe, End"
230 CALL ONKEY("YNME",3,K,S)GOTO 250,260,280,280
240 GOTO 230
250 PRINT "Yes!" :: GOTO 230
260 PRINT "Nn!" :: GOTO 230
270 PRINT "Maybe" :: GOTO 230
280 PRINT "End!"

SAVE DSK1.RXBONKEY,IV254
NEW
100 ! CATALOG ALL DISKS
110 N=49
120 ON ERROR 150
130 N=N+1
140 CALL CAT(N)
150 PRINT D$
160 IF N<128 THEN 120 ELSE END

SAVE DSK1.CATALL,IV254
NEW
100 ! JOYLOCATE              JOYST + LOCATE + IF KEY GOTOLINE NUMBER
110 ! As this does all this in asingle command should  be   used in place of normal XB  more compliated version
120 CALL CLEAR
130 CALL CHAR(143,"FFFFFFFFFFFFFFFF")
140 CALL SPRITE(#1,143,2,9,190)
150 CALL JOYLOCATE(1,X,Y,8,8,#1,R,C,K)GOTO 180
160 PRINT X;Y;K;R;C
170 GOTO 150
180 PRINT X;Y;K;R;C;"FIRE"
190 GOTO 150

SAVE DSK1.JLOCATE,IV254
NEW
100 ! RXB CALL JMOTION
110 ! JOYMOTION              JOYST + MOTION + IF KEY GOTOLINE NUMBER
120 ! As this does all this in asingle command should  be   used in place of normal XB  more compliated version
130 CALL CLEAR
140 CALL CHAR(143,"FFFFFFFFFFFFFFFF")
150 CALL SPRITE(#1,143,2,9,190,20,0)
160 CALL JOYMOTION(1,X,Y,#1,9,9,K)GOTO 190
170 PRINT X;Y,K
180 GOTO 160
190 PRINT X;Y,K;"FIRE"
200 GOTO 160

SAVE DSK1.JMOTION,IV254
NEW
100 ! RUN FOR ONE HOUR AND    COMPARE PRINT X XB VS RXB
110 ! NORMAL XB DISTANCE
120 CALL CLEAR :: X=190
130 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
140 CALL DISTANCE(#1,#2,D)
150 CALL DISTANCE(#1,#3,E)
160 CALL DISTANCE(#2,#3,F)
170 X=X+1 :: PRINT D;E;F
180 GOTO 140! X IS COUNTER
190 !
200 ! RXB DISTANCE
210 CALL CLEAR :: X=190
220 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
230 CALL DISTANCE(#1,#2,D,#1,#3,E,#2,#3,F)
240 X=X+1 :: PRINT D;E;F
250 GOTO 230! X IS COUNTER
260 ! RUN FOR 1 HOUR TEST OF    NORMAL DISTANCE XB VS RXB

SAVE DSK1.DISTANCE,IV254
NEW
10 ! RXB EXAMPLE            CALL CHAR(ALL,string)
20 FOR L=0 TO 256 :: PRINT CHR$(L);:: NEXT L
30 S$="0123456789ABCDEF"
40 CALL CHAR(ALL,SEG$(S$,INT(RND*15)+1,INT(RND*15)+1))
50 Z=Z+1 :: IF Z=50 THEN END ELSE 40

SAVE DSK1.CHARALL,IV254
NEW
100 ! NORMAL XB CHARSET
110 CALL HCHAR(1,1,32,768) :: PRINT "NORMAL XB CALL CHARSET": :
120 FOR L=159 TO 30 STEP-1 :: PRINT CHR$(L);" "; :: CALL CHAR(L,"4567") :: NEXT L
130 FOR D=1 TO 600 :: NEXT D
140 CALL CHARSET
150 PRINT "XB CHARSET RESETS 32 TO 95": : :
160 FOR D=1 TO 900 :: NEXT D
170 ! RXB CHARSETALL
180 CALL CHARSETALL
190 PRINT "RXB CHARSETALL 30 TO 159": :
200 PRINT "PRESS ANY KEY"
210 CALL KEY("",5,K,S)

SAVE DSK1.CHARSETALL,IV254
NEW
10 ! RXB EXAMPLE            CALL SWAPCHAR(char,char)    CALL SWAPCHAR(value#,value#)
100 A(0)=-1 :: A(1)=1 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL MAGNIFY(2):: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*20),INT(A(RND*1))*INT(RND*20))
140 NEXT S
150 CALL SWAPCOLOR(#INT(RND*28)+1,#INT(RND*28)+1):: CALL SWAPCHAR(INT(RND*28)+64,INT(RND*28)+64)
160 Z=Z+1 :: IF Z=50 THEN END ELSE 150

SAVE DSK1.SWAP,IV254
NEW
10 ! RXB EXAMPLE            CALL MAGNIFY(factor[,...])
100 A(0)=-1 :: A(1)=1 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,2,20+S,50+S,INT(A(RND*1))*INT(RND*127),INT(A(RND*1))*INT(RND*127))
140 NEXT S
150 CALL MAGNIFY(1,2,1) :: GOTO 150 
160 ! MAGNIFY changed

SAVE DSK1.MAGNIFY,IV254
NEW
100 CALL CLEAR
110 T$="HELLO WORLD"
120 B$=" "
130 CALL BIAS(1,T$,1,B$)
140 FOR X=757 TO 0 STEP-1
150 CALL MOVES("$V",11,T$,X,"$V",1,B$,X+10)
170 NEXT X

SAVE DSK1.MOVESHELLO,IV254
NEW
100 ! RXB EXAMPLE            CALL MOVES(GROM to screen)
110 FOR GA=0 TO 32767 STEP 768 :: CALL MOVES("GV",768,GA,0):: NEXT GA
120 ! RXB EXAMPLE            CALL MOVES (RIPPLE EXAMPLE)
130 CALL HCHAR(1,1,32)
140 CALL MOVES("VV",767,0,1)
150 ! RXB EXAMPLE            CALL MOVES (SCAN VDP)
160 FOR V=0 TO 16384 STEP 768 :: CALL MOVES("VV",768,V,0):: NEXT V
170 ! RXB EXAMPLE            CALL MOVES(RAM to screen)
180 FOR R=0 TO 8192 STEP 768 :: CALL MOVES("RV",768,R,0) :: NEXT R

SAVE DSK1.MOVES,IV254
NEW
10 ! RXB EXAMPLE       CALL MOVES(type$,bytes,from,to)
20  PRINT "Disk controller EPROM chip"
100 CALL CHAR(31,"F0F0F0F0F0F0F0F0")
110 CALL IO(3,8,2176,255) ! TURN ON EPROM
120 FOR A=16384 TO 24576 STEP 224
130 CALL MOVES("R$",224,A,T$)
140 CALL HEX(A,H$)
150 PRINT " ADDRESSS=";A;"HEX=";H$: :T$: :
160 FOR L=1 TO 400 :: NEXT L
170 NEXT A
180 CALL CHAR(31,"00")
190 CALL IO(3,8,2176,0) ! TURN OFF EPROM

SAVE DSK1.MOVESDSR,IV254
NEW
10 ! RXB EXAMPLE CALL BIAS
20 ! MOVES get VDP from     screen into a String         Variable X$
30 CALL MOVES("V$",255,511,X$)
40 ! CALL BIAS removes 96   screen bias from all         characters in String            Variable X$
50 CALL BIAS(0,X$)
60 ! After screen bias is   removed it can be printed    on screen
70 PRINT X$

SAVE DSK1.BIAS,IV254
NEW
10 ! RXB EXAMPLE             RXB SUBPROGRAM FINDER
100 CALL CLEAR :: ADDRESS=-24538
110 RESTORE :: FOR I=1 TO 2 :: READ X$,Y$,Z$ :: PRINT X$;TAB(11);Y$;TAB(22);Z$ :: NEXT I
120 CALL PEEKG(ADDRESS,B1,B2) :: CALL HEX(B1,B1$,B2,B2$) :: ADDRESS$=SEG$(B1$,3,2)&SEG$(B2$,3,2)
130 CALL PEEKG(ADDRESS+2,LENGTH)
140 CALL MOVES("G$",LENGTH,ADDRESS+3,N$)
150 CALL PEEKG(ADDRESS+3+LENGTH,S1,S2) :: CALL HEX(S1,S1$,S2,S2$) :: S$=SEG$(S1$,3,2)&SEG$(S2$,3,2)
160 CALL HEX(ADDRESS,A$) :: PRINT A$;"-";ADDRESS$;" ";TAB(11);N$;" ";TAB(22);S$ :: PRINT
170 DATA HEADER,SUBPROGRAM,START,*******,**********,*******
180 CALL HEX(ADDRESS$,ADDRESS) :: IF ADDRESS THEN 120

SAVE DSK1.SUBPGMFNDR,IV254
NEW
10 ! RXB EXAMPLE            CALL POKER(register,value)
100 CALL CLEAR :: FOR I=0 TO 764 STEP 8 :: CALL POKEV(I,161,162,163,164,165,166,167,168) :: NEXT I
110 CALL CLEAR :: FOR I=0 TO 758 STEP 16 :: CALL POKEV(I,161,162,163,164,165,166,167,168,169,170,172,173,174,175,176) :: NEXT I
120 CALL CLEAR :: FOR I=126 TO 223 :: CALL POKEV(I,I+1,I+2,I+3,I+4,I+5,I+6,I+7) :: NEXT I
130 PRINT: :"SCREEN COLOR CHANGES" :: FOR T=1 TO 5 :: FOR I=0 TO 15 :: CALL POKER(7,1) :: NEXT I :: NEXT T :: CALL SCREEN(8)
140 A$="!@#$%^&*()+1234567890=-:><,.;/~_?'|{}\`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" :: FOR I=1 TO 5 :: PRINT A$ :: NEXT I
150 PRINT: :"CHARACTER COLOR CHANGES" :: FOR I=30 TO 70 :: FOR T=2063 TO 2076 :: CALL POKEV(T,I) :: NEXT T :: NEXT I :: CALL CHARSET :: PRINT
160 PRINT "PRESS A KEY FOR TEXT MODE": : :: CALL BEEP
170 CALL KEY("",0,K,S) :: CALL POKER(7,244) :: CALL POKER(1,240)
180 PRINT "       PRESS A KEY FOR MULTI COLOR MODE": : :: CALL BEEP
190 CALL KEY("",0,K,S) :: CALL POKER(1,232) :: GOSUB 230 :: CALL POKER(1,224)
200 PRINT "PRESS A KEY FOR BIT MAP MODE": : :: CALL BEEP
210 CALL KEY("",0,K,S) :: CALL POKER(0,2) :: CALL POKER(1,224)
220 GOSUB 230 :: CALL POKER(0,0) :: END
230 FOR I=1 TO 800 :: NEXT I :: RETURN

SAVE DSK1.POKER,IV254
NEW
100 ! RXB EXAMPLE            CALL MOTION(STOP,GO)
110 CALL CLEAR :: CALL CHAR(128,RPT$("F",16)) :: CALL MAGNIFY(2)
120 A$="OUT" :: GOSUB 130 :: A$="" :: GOSUB 130 :: CALL QUITON :: END
130 CALL HPUT(1,3,"MOTION WITH"&A$&" RXB") :: IF A$="" THEN CALL MOTION(STOP)
140 FOR A=1 TO 11 :: CALL SPRITE(#A,128,2,A*16-7,1,0,30) :: NEXT A :: IF A$="" THEN CALL MOTION(GO)
150 CALL HPUT(24,4,"PRESS ANY KEY TO CONTINUE.") :: CALL KEY("",0,K,S) :: CALL DELSPRITE(ALL) :: CALL CLEAR :: RETURN

SAVE DSK1.MOTIONGO,IV254
NEW
10 ! RXB EXAMPLE            CALL MOTION(GO,STOP)
100 A(0)=-1 :: A(1)=1 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL MAGNIFY(2) :: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,2,20+S,50+S,INT(A(RND*1))*INT(RND*127),INT(A(RND*1))*INT(RND*127))
140 NEXT S
150 N=N+1 :: ON INT(RND*3)+1 GOSUB 160,170,180 :: IF N>50 THEN END ELSE 150
160 CALL MOTION(GO) :: RETURN
170 CALL MOTION(STOP) :: RETURN
180 FOR DELAY=0 TO 200 :: NEXT DELAY :: RETURN

SAVE DSK1.MOTIONSTOP,IV254
NEW
10 ! RXB EXAMPLE            CALL COLOR(ALL,fore,back)
20 FOR L=0 TO 256 :: PRINT CHR$(L);:: NEXT L
30 CALL COLOR(ALL,RND*15+1,RND*15+1)
40 Z=Z+1 :: IF Z=50 THEN END ELSE 30

SAVE DSK1.COLORALL,IV254
NEW
100 ! COLOR IN RXB HAS ALL  ADDED TO CHANGE ALL SETS    FROM 0 TO 16
120 FOR X=0 TO 255 :: PRINT CHR$(X);
130 NEXT X
140 CALL COLOR(ALL,1,2)! ALLSETS ALL TO TRANPARENT BLACK
150 FOR X=0 TO 2E2 :: NEXT X
160 CALL COLOR(ALL,1,2,ALL,2,1) :: GOTO 160! CREATES A  OPTICAL EFFECT
200 GOTO 200

SAVE DSK1.ALLCOLOR,IV254
NEW
10 ! RXB EXAMPLE            CALL MOTION(ALL,x,y)
100 A(0)=-127 :: A(1)=127 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL MAGNIFY(2):: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,2,20+S,50+S,A(RND)*RND,A(RND)*RND)
140 NEXT S
150 CALL MOTION(ALL,A(RND)*RND,A(RND)*RND)
160 C=C+1 :: IF C<70 THEN 150
170 ! pretty cool huh?

SAVE DSK1.MOTIONALL,IV254
NEW
! RXB EXAMPLE               CALL HEX(number,string)
10 ! Decimal & Hexidecimal
11 FOR D=-32000 TO 30000 STEP 1000
12 CALL HEX(D,H$)
13 PRINT "DEC=";D,"HEX=";H$
100 ! Hexidecimal to Decimal
120 CALL HEX(H$,D)
130 PRINT "HEX=";H$,"DEC=";D
140 NEXT D

SAVE DSK1.HEX~DEC,IV254
NEW
100 ! NUMBERS VS STRINGS
110 DATA 200,124,97,249,140,77,81,173,254,78,93,12,38,65,55,6,0
120 READ N :: B$="BYTES"
130 CALL HEX(N,N$)
140 S$=S$&SEG$(N$,2,2)
150 IF N<>0 THEN 120
160 PRINT "DATA: ";8*16,B$
170 PRINT "STRING:";LEN(S$)+1,B$
180 PRINT "SAVED: ";(8*16)-(LEN(S$)+1),B$
190 ! 8 BYTES PER DATA       WHILE STRING IS 2 BYTES

SAVE DSK1.HEXSTRING,IV254
NEW
10 ! RXB EXAMPLE            CALL SWAPCHAR(char,char)    CALL SWAPCHAR(value#,value#)
100 A(0)=-1 :: A(1)=1 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL MAGNIFY(2):: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*20),INT(A(RND*1))*INT(RND*20))
140 NEXT S
150 CALL SWAPCOLOR(#INT(RND*28)+1,#INT(RND*28)+1):: CALL SWAPCHAR(INT(RND*28)+64,INT(RND*28)+64)
160 Z=Z+1 :: IF Z=50 THEN END ELSE 150

SAVE DSK1.SWAP,IV254
NEW
10 ! RXB EXAMPLE            CALL INVERSE(ALL)
100 CALL INVERSE(ALL)
110 A=A+1 :: IF A<8 THEN 100
120 ! Inverts all character definitions

SAVE DSK1.INVERSEALL,IV254 
NEW
100 ! INVERSE IS A RXB      COMMAND THAT INVERTS THE ALLTHE BITS IN A CHARACTER CODE
110 ! INVERSE HAS ANOTHER   USE FOR PROGRAMMERS
120 PRINT "CHARACTER # (32 TO 159)": :
130 ACCEPT AT(24,1)VALIDATE(DIGIT)SIZE(3)BEEP:X :: PRINT CHR$(X):
140 CALL CHARPAT(X,X$) :: PRINT X$;" NORMAL"
150 CALL INVERSE(X)
160 CALL CHARPAT(X,X$) :: PRINT X$;" INVERSED": :
170 GOTO 120

SAVE DSK1.INVERSED,IV254
NEW
1 ! RXB has improved a COINC  routine run this demo to seethe results!
100 ! RUN FOR 1 HOUR AND     AND PRINT X FOR XB VS RXB
110 ! NORMAL XB COINC
120 CALL CLEAR :: X=190
130 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
140 CALL COINC(ALL,A)
150 CALL COINC(#1,#2,12,B)
160 CALL COINC(#1,#3,12,C)
170 CALL COINC(#2,#3,12,D)
180 X=X+1 :: PRINT A;B;C;D
190 GOTO 140
200 !
210 ! RXB COINC
220 CALL CLEAR :: X=190
230 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
240 CALL COINC(ALL,A,#1,#2,12,B,#1,#3,12,C,#2,#3,12,D)
250 X=X+1 :: PRINT A;B;C;D
260 GOTO 240

SAVE DSK1.COINC,IV254
NEW
10 ! RXB EXAMPLE
100 ! This program gives the illusion of sprites that    bank 90% at a time
110 CALL MAGNIFY(2) :: CALL CLEAR :: CALL SCREEN(15) :: CALL MOTION(GO)
120 CALL SPRITE(#1,65,2,100,10,0,35,#2,66,16,10,140,25,0)
130 CALL COINC(ALL,V)
140 IF V THEN CALL SWAPCHAR(65,66) :: CALL RMOTION(#1) :: CALL SWAPCOLOR(#1,#2) :: GOSUB 160
150 GOTO 130 :: FOR L=1 TO 600 :: NEXT L
160 A=A+1 :: IF A<5 THEN RETURN

SAVE DSK1.SPRITESWAP,IV254
NEW
10 ! RXB EXAMPLE             CALL GMOTION(#sprite,x,y)
100 A(0)=-1 :: A(1)=1 :: CALL CLEAR :: CALL MAGNIFY(2):: CALL SCREEN(15) :: CALL MOTION(GO)
110 FOR S=1 TO 28
120 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*127),INT(A(RND*1))*INT(RND*127))
130 NEXT S
140 S=INT(RND*28)+1 :: CALL GMOTION(#S,X,Y):: CALL HPUT(24,3,"CALL GMOTION(#"&STR$(S)&","&STR$(X)&","&STR$(Y)&")      ") :: FOR L=1 TO 1000 :: NEXT L
150 CALL MOTION(#S,Y,X):: Z=Z+1 :: IF Z<8 THEN 140

SAVE DSK1.GMOTION,IV254
NEW
10 ! RXB EXAMPLE            CALL GMOTION(#sprite,x,y)
100 A(0)=-1 :: A(1)=1 :: CALL CLEAR :: CALL MAGNIFY(2) :: CALL SCREEN(15) :: CALL MOTION(GO)
110 FOR S=1 TO 28
120 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*127),INT(A(RND*1))*INT(RND*127))
130 NEXT S
140 S=INT(RND*28)+1 :: CALL GMOTION(#S,X,Y) :: CALL HPUT(24,3,"CALL GMOTION(#"&STR$(S)&","&STR$(X)&","&STR$(Y)&")      ") :: FOR L=1 TO 1000 :: NEXT L
150 CALL MOTION(#S,Y,X) :: Z=Z+1 :: IF Z<8 THEN 140
160 ! GMOTION gets motion   from one sprite and puts     into another sprite

SAVE DSK1.G~MOTION,IV254
NEW
10 ! RXB EXAMPLE            CALL RMOTION(#sprite)       CALL RMOTION(ALL)
100 A(0)=-1 :: A(1)=1 :: CALL CLEAR :: CALL MAGNIFY(2) :: CALL SCREEN(15)
110 FOR S=1 TO 28
120 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*32),INT(A(RND*1))*INT(RND*32))
130 NEXT S
140 IF RND>.2 THEN CALL RMOTION(#INT(RND*28)+1)ELSE CALL RMOTION(ALL)
150 Z=Z+1 :: IF Z<200 THEN 140
160 ! As this does all this  in a single command should  be used in place of normal  XB  more compliated version

SAVE DSK1.RMOTION,IV254
NEW
10 ! RXB EXAMPLE CALL IO      (SOUND LIST)
100 A=8191
110 DATA 5,159,191,223,255,227,1
120 DATA 9,142,1,164,2,197,1,144,182,211,6
130 DATA 3,145,183,212,5
140 DATA 3,146,184,213,4
150 DATA 5,167,4,147,176,214,5
160 DATA 3,148,177,215,6
170 DATA 3,149,178,216,7
180 DATA 5,202,2,150,179,208,6
190 DATA 3,151,180,209,5
200 DATA 3,152,181,210,4
210 DATA 5,133,3,144,182,211,5
220 DATA 3,145,183,212,6
230 DATA 3,146,184,213,7
240 DATA 5,164,2,147,176,214,6
250 DATA 3,148,177,215,5
260 DATA 3,149,178,216,4
270 DATA 5,197,1,150,179,208,5
280 DATA 3,151,180,209,6
290 DATA 3,152,181,210,7
300 DATA 3,159,191,223,0
310 A=A+1 :: READ B :: CALL POKEV(A,B)
320 IF B=0 THEN 330 ELSE 310
330 CALL IO(1,8192)

SAVE DSK1.IO~CHIMES,IV254
NEW
100 CALL CLEAR! CRASH
110 DATA 2,228,242,5
120 DATA 2,228,240,18
130 DATA 2,228,241,16
140 DATA 2,228,242,14
150 DATA 2,228,243,12
160 DATA 2,228,244,10
170 DATA 2,229,245,9
180 DATA 2,229,246,8
190 DATA 2,229,247,7
200 DATA 2,229,248,6
210 DATA 2,229,249,5
220 DATA 2,230,250,4
230 DATA 2,230,251,3
240 DATA 2,230,252,2
250 DATA 2,230,253,1
260 DATA 2,230,254,1
270 DATA 1,255,0,0
280 FOR AD=4096 TO 4160 STEP 4
290 READ V1,V2,V3,V4
300 CALL POKEV(AD,V1,V2,V3,V4)
310 NEXT AD
320 CALL IO(1,4096)
330 PRINT "CRASH": :"TYPE:":"CALL IO(1,4096)"

SAVE DSK1.IO~CRASH,IV254
NEW
100 ! RUN FOR 1 HOUR AND     AND PRINT X FOR XB VS RXB
110 ! NORMAL XB COINC
120 CALL CLEAR :: X=190
130 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
140 CALL COINC(ALL,A)
150 CALL COINC(#1,#2,12,B)
160 CALL COINC(#1,#3,12,C)
170 CALL COINC(#2,#3,12,D)
180 X=X+1 :: PRINT A;B;C;D
190 GOTO 140
200 !
210 ! RXB COINC
220 CALL CLEAR :: X=190
230 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
240 CALL COINC(ALL,A,#1,#2,12,B,#1,#3,12,C,#2,#3,12,D)
250 X=X+1 :: PRINT A;B;C;D
260 GOTO 240
270 ! 1 HOUR TEST XB VS RXB

SAVE DSK1.COINC,IV254
NEW
1 ! XBRAMDISK used for saving 8K or less XB programs.
100 !Saved program will stay  in memory as long as you do not CALL INIT or turn memory expansion off.
110 !It will even stay in     memory when switching       cartrides with a WIDGET.
200 CALL CLEAR
220 CALL CHAR(42,"AA55AA55AA55AA55",91,"7E8199A1A199817E")
230 CALL CHAR(45,RPT$("0",8)&"FF"&RPT$("0",10)&"10387CFEFE")
240 CALL CLEAR :: CALL HCHAR(2,4,42,26)
250 CALL VCHAR(3,4,42,5) :: CALL VCHAR(3,29,42,5)
260 DISPLAY AT(5,9)SIZE(12):"RAM-DISKETTE"
270 CALL HCHAR(8,4,42,26)
280 DISPLAY AT(12,4):"[ MARTIN KOTULLA 1985"
290 CALL HCHAR(13,6,45,22) :: DISPLAY AT(17,7):"DATAs CHECK?   Y"
296 DISPLAY AT(22,4):"CALL LINK("&CHR$(34)&" LOAD"&CHR$(34)&") retrieve"
300 ACCEPT AT(17,22)BEEPSIZE(-1)VALIDATE("YN"):JN$
310 IF JN$="N" THEN 360
320 FOR I=8192 TO 8458 STEP 2 :: READ A,B :: SUM=SUM+A+B :: NEXT I
330 DISPLAY AT(20,5):"THE DATA-LINES ARE"
340 IF SUM<>20638 THEN DISPLAY AT(22,10):"INCORRECT!" :: END
350 DISPLAY AT(22,11):"CORRECT!"
360 CALL INIT :: RESTORE
370 FOR I=8192 TO 8458 STEP 2 :: READ A,B :: CALL LOAD(I,A,B) :: NEXT I
380 CALL CLEAR :: STOP
390 DATA 032,068,255,255,000,000,170,085,000,000,041,097,032,056,033,126
400 DATA 032,056,033,226,032,056,035,076,032,056,036,050,032,056,036,110
410 DATA 032,056,036,132,032,056,036,144,247,147,248,118,255,231,247,146
420 DATA 255,255,076,079,065,068,032,032,032,196,083,065,086,069,032,032
430 DATA 032,122,000,000,002,001,032,050,002,129,032,066,027,014,192,001
440 DATA 002,002,131,074,140,176,022,006,140,176,022,004,140,176,022,002
450 DATA 192,048,004,080,002,033,000,008,016,239,002,000,037,000,200,000
460 DATA 131,034,002,224,131,224,004,096,000,206,002,224,032,008,192,032
470 DATA 131,132,096,032,131,048,002,032,033,012,002,128,064,000,026,003
480 DATA 002,000,011,000,016,236,007,032,032,048,192,032,131,048,002,001
490 DATA 033,012,220,112,136,000,131,132,018,252,200,032,131,048,032,040
500 DATA 200,032,131,050,032,042,200,032,131,132,032,044,200,032,131,134
510 DATA 032,046,016,029,002,224,032,008,200,032,032,048,032,048,022,003
520 DATA 002,000,029,000,016,204,192,032,032,040,002,001,033,012,220,049
530 DATA 136,000,032,044,018,252,200,032,032,040,131,048,200,032,032,042
540 DATA 131,050,200,032,032,044,131,132,200,032,032,046,131,134,004,192
550 DATA 216,000,131,124,002,224,131,224,004,096,000,112
560 END
NEW
10 CALL CLEAR
20 PRINT "RUN this program to create aload program that loads and runs EA5, EA3, BASIC, and   XB programs from DISK       or HARD DRIVE."
30 PRINT :"STEP #1: Put in the Path of the DV80 USER file that     will create the LOAD program" 
40 PRINT :"STEP #2: Put in the path    where to catalog a drive andwant the LOAD program to be saved and used"
50 PRINT :"STEP #3: If done then press ENTER, if you want to add   more directorys put in path"
60 PRINT :"STEP #4: When done you pressENTER then the LOAD program is created and saved to the disk in path"
70 CALL KEY("",5,K,S) :: CALL CLEAR
150 CALL VERSION(V) :: IF V<2020 THEN PRINT "VERSION TO OLD TO CONTINUE!" :: END
160 DISPLAY AT(1,3)ERASE ALL:"RXB CREATES A LOAD PROGRAM"
170 CALL HPUT(5,3,"EXAMPLE:",7,3,"PATHNAME:DSK1.",9,3,"PATHNAME:DSK.DISKNAME.",11,3,"PATHNAME:WDS1.DIR.")
180 CALL HPUT(13,3,"PATHNAME:WDS1.DIR.SUB-DIR.",15,3,"PATHNAME:WDS.VOL.DIR.")
190 CALL HPUT(17,3,"PATHNAME:WDS.VOL.DIR.SUB-DIR.",19,3,"(Where to save result.)",23,3,"PATHNAME:")
200 ACCEPT AT(23,10)BEEP:M$ :: E$=CHR$(13) :: S$=CHR$(34) :: Q$=RPT$(S$,2)
210 CALL CLEAR :: PRINT "Creating USER file DV80-LOAD"
220 OPEN #1:M$&"DV80-LOAD",VARIABLE 80,DISPLAY,OUTPUT
230 PRINT #1:"NEW"&CHR$(13)
235 PRINT #1:"CALL QUITON"&CHR$(13)
240 PRINT #1:"100 ! RXB LOAD PROGRAM"&E$
250 PRINT #1:"110 @=1 :: DIM P$(48),Y$(48),T(48)"&E$ 
260 PRINT #1:"120 @=1::CALL VERSION(V) :: IF V<2020 THEN PRINT "&S$&"VERSION TO OLD TO CONTINUE!"&S$&" :: END"&E$
270 PRINT #1:"130 RESTORE"&E$
280 PRINT #1:"140 DISPLAY AT(1,3)ERASE ALL:"&S$&"RXB LOAD PROGRAM *"&S$&E$    
290 PRINT #1:"150 DISPLAY AT(6,1):"&S$&"ACTIVE KEYS ARE:"&S$&":: DISPLAY AT(7,1):";   
300 PRINT #1:S$&"E = UP CURSOR"&S$&":"&S$&"X = DOWN CURSOR"&S$&":";
310 PRINT #1:S$&"S = LEFT CURSOR"&S$&":"&S$&"D = RIGHT CURSOR"&S$&E$
320 PRINT #1:"160 DISPLAY AT(14,1):"&S$&"SPACE BAR = NEXT PAGE"&S$&": :"&S$&"C = DIRECTORY"&S$&": :"&S$&"1-9 = CATALOG DISK"&S$;
330 PRINT #1:" :: CALL HPUT(24,3,"&S$&"PLEASE WAIT..."&S$&")"&E$
340 PRINT #1:"170 IF @ THEN CALL HPUT(24,3,"&S$&"PRESS ANY KEY TO CONTINUE!"&S$&")::CALL BEEP::CALL KEY("&Q$&",3,K,S)::@=0"&E$
350 PRINT #1:"180 CALL CLEAR::E$=CHR$(13)::N=1"&E$
360 PRINT #1:"190 Y=1::Z=3::CALL CHAR(128,"&S$&"080C0EFFFF0E0C08"&S$&",129,"&S$&"103070FFFF703010"&S$&")"&E$
370 PRINT #1:"200 FOR C=4 TO 16 STEP 12 :: FOR R=1 TO 24"&E$
380 PRINT #1:"210 READ P$(N),Y$(N),T(N)"&E$
390 PRINT #1:"220 IF T(N)=0 THEN 260"&E$
400 PRINT #1:"230 CALL HPUT(R,C,Y$(N))::IF C=4 THEN CALL HPUT(R,1,CHR$(T(N))) ELSE CALL HPUT(R,32,CHR$(T(N)))"&E$
410 PRINT #1:"240 N=N+1::IF N=49 THEN N=48::GOTO 260"&E$
420 PRINT #1:"250 NEXT R::NEXT C"&E$
430 PRINT #1:"260 CALL HCHAR(Y,Z,128,1,Y,Z+11,129)"&E$
440 PRINT #1:"270 CALL KEY(3,K,S)::IF K=67 THEN CALL CLEAR::INPUT "&S$&"PATH:"&S$&":X$::CALL CAT(X$)::CALL KEY("&Q$&",3,K,S)::GOTO 130"&E$
450 PRINT #1:"280 CALL HCHAR(Y,Z,32,1,Y,Z+11,32) :: IF K>48 AND K<58 THEN CALL CAT(K) :: CALL KEY("&Q$&",3,K,S)::GOTO 130"&E$
460 PRINT #1:"290 IF K=69 OR K=11 THEN S=Y::Y=Y-1::GOSUB 390::IF G=32 THEN Y=S"&E$
470 PRINT #1:"300 IF K=88 OR K=10 THEN S=Y::Y=Y+1::GOSUB 390::IF G=32 THEN Y=S"&E$
480 PRINT #1:"310 IF K=83 OR K= 8 THEN Z=3"&E$
490 PRINT #1:"320 IF K=68 OR K=9 THEN Z=15::CALL GCHAR(Y,Z+1,G)::IF G=32 THEN Z=3"&E$
500 PRINT #1:"330 IF K=32 THEN 340 ELSE 360"&E$
510 PRINT #1:"340 Y=1::IF POS(P$(N),"&S$&"!........!"&S$&",1) THEN 130"&E$ 
520 PRINT #1:"350 GOTO 180"&E$
530 PRINT #1:"360 IF K=13 THEN 420"&E$
540 PRINT #1:"370 IF K=43 OR K=61 THEN N,X=0::GOTO 140"&E$
550 PRINT #1:"380 GOTO 260"&E$
560 PRINT #1:"390 IF Y<1 THEN Y=24"&E$
570 PRINT #1:"400 IF Y>24 THEN Y=1"&E$
580 PRINT #1:"410 CALL GCHAR(Y,Z+1,G)::RETURN"&E$
590 PRINT #1:"420 IF Z=15 THEN T$=P$(24+Y)&Y$(24+Y)ELSE T$=P$(Y)&Y$(Y)"&E$  
600 PRINT #1:"430 IF Z=3 THEN CALL GCHAR(Y,1,S) ELSE CALL GCHAR(Y,32,S)"&E$
610 PRINT #1:"440 IF S=1 THEN CALL EALR(T$) ELSE IF S=5 THEN CALL EA(T$) ELSE IF S=4 THEN CALL XB(T$)"&E$
620 PRINT #1:"450 IF S=9 THEN CALL USER(T$)::END"&E$
640 CALL CLEAR :: ON ERROR 670
660 DELETE M$&"LOAD"
670 DISPLAY AT(1,1)ERASE ALL:"* INPUT DIRECTORY FOR LIST *"
680 CALL HPUT(5,3,"EXAMPLE:",7,3,"PATHNAME:DSK1.",9,3,"PATHNAME:DSK.DISKNAME.",11,3,"PATHNAME:WDS1.DIR.")
690 CALL HPUT(13,3,"PATHNAME:WDS1.DIR.SUB-DIR.",15,3,"PATHNAME:WDS.VOL.DIR.")
700 CALL HPUT(17,3,"PATHNAME:WDS.VOL.DIR.SUB-DIR.",19,3,"PATHNAME:(ENTER TO EXIT)",23,3,"PATHNAME:")
710 ACCEPT AT(23,10)BEEP:_$
720 X=0 :: IF LEN(_$)=0 THEN 1120
730 DIM TYPE$(6),F$(128)
740 TYPE$(1)="DIS/FIX"
750 TYPE$(2)="DIS/VAR"
760 TYPE$(3)="INT/FIX"
770 TYPE$(4)="INT/VAR"
780 TYPE$(5)="PROGRAM"
790 TYPE$(6)="DIRECTORY"
800 OPEN #2:_$,INPUT,INTERNAL,FIXED 38
810 INPUT #2:A$,J,J,K
820 CALL CLEAR :: DISPLAY _$;" -  DISKNAME= ";A$:"AVAILABLE= ";K;" USED= ";J-K
830 DISPLAY:"FILENAME   SIZE    TYPE    P":"---------- ---- ---------- -";
840 INPUT #2:A$,I,J,K
850 T=ABS(I) :: IF LEN(A$)=0 THEN GOSUB 1030 :: GOTO 670
860 DISPLAY: :A$;TAB(12);J;TAB(17);TYPE$(ABS(I));
870 IF ABS(I)=5 THEN 910
880 IF ABS(I)=6 THEN 930
890 B$="  "&STR$(K)
900 DISPLAY SEG$(B$,LEN(B$)-2,3);
910 IF I>0 THEN 930
920 DISPLAY TAB(28);"Y";
930 IF T=4 AND K=254 THEN 1010
940 IF T=5 THEN 950 ELSE 960
950 PRINT :: DISPLAY AT(24,1)BEEP:"XB or EA program? (X/E/ )  ?" :: GOSUB 1020 :: IF W=88 THEN T=4 :: GOTO 1010 ELSE IF W=69 THEN 1010 ELSE IF W=32 THEN 960 ELSE 950
960 IF T=2 AND K=80 THEN 970 ELSE 990
970 PRINT :: DISPLAY AT(24,1)BEEP:"BATCH  ( B/ ) ?" :: GOSUB 1020 :: IF W=66 AND K=80 THEN T=9 :: GOTO 1010
980 IF W=86 AND K=80 THEN 1010 ELSE IF W=32 THEN 840 ELSE 970
990 IF T=1 AND K=80 THEN 1000 ELSE 840
1000 PRINT :: DISPLAY AT(24,1)BEEP:"EA OBJECT FILE? (Y/N) ?" :: GOSUB 1020 :: IF W=89 THEN 1010 ELSE IF W=78 THEN 840 ELSE 1000
1010 X=X+1 :: F$(X)=A$&","&STR$(T) :: GOTO 840
1020 CALL KEY("",3,W,S) :: RETURN
1030 PRINT: :"! Creating program list.": :"PLEASE WAIT..."
1040 IF X=0 THEN 1090
1050 FOR Y=1 TO X
1060 PRINT #1:STR$(1000+@)&" DATA "&_$&","&F$(Y)&E$
1070 @=@+1
1080 NEXT Y
1090 PRINT #1:E$
1100 CLOSE #2
1110 RETURN
1120 CALL CLEAR :: PRINT "PLEASE WAIT..."
1130 @=@+1
1140 PRINT #1:STR$(1000+@)&" DATA !........!,"&Q$&",0"&E$
1150 PRINT #1:"SAVE "&M$&"LOAD,IV254"&E$
1160 PRINT #1:"! New loader on disk and"&E$
1170 PRINT #1:"! named LOAD, USER finished."&E$
1180 PRINT #1:"! Please delete file:       "&M$&"DV80-LOAD"&E$
1190 PRINT #1:"CALL KEY("&CHR$(34)&CHR$(34)&",K,S)"&E$
1200 PRINT #1:"CALL XB("&CHR$(34)&M$&"LOAD"&CHR$(34)&")"&E$
1210 CALL CLSALL
1210 CALL USER(M$&"DV80-LOAD")

SAVE DSK1.LOADER,IV254

CALL USER("DSK1.TEST-USER")