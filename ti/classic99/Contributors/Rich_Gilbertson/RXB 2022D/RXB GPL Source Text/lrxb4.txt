99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0001 
Version 2.0 (Weiand 1985)     Options : LCSFPF#########                         
[0001]               ***********************************************************
[0002]                      TITL 'RXB 2022'
[0003]               ***********************************************************
[0004]                      GROM >8000
[0005]               ***********************************************************
[0006]               * RAM EXPANSION ADDRESS
[0007] A040          CPUBAS EQU  >A040             Expansion RAM base
[0008]               ***********************************************************
[0009]               *           GROM ADDRESSES
[0010]               ***********************************************************
[0011]               *    EQUATES FOR ROUTINES FROM OTHER GROM SECTIONS
[0012]               * GROM >0000
[0013] 0022          ATNZZ  EQU  >0022             Arctangent routine
[0014]               * GROM >6000
[0015] 6012          TOPL15 EQU  >6012             RETURN FROM OLD  or SAVE
[0016] 6014          INITPG EQU  >6014             Initialize program space
[0017] 601A          TOPL10 EQU  >601A             Return to main and re-init
[0018] 6022          KILSYM EQU  >6022             KILL SYMBOL TABLE ROUTINE
[0019] 6030          TOPL02 EQU  >6030             RTN address for failing AUTOL
[0020] 6032          EDITLN EQU  >6032             Edit a line into the program
[0021] 6036          GWSUB  EQU  >6036             Write a few bytes of data to
[0022] 6A74          LLIST  EQU  >6A74             List a line
[0023] 6A76          READLN EQU  >6A76             Read a line from keyboard
[0024] 6A82          WARNZZ EQU  >6A82             WARNING MESSAGE ROUTINE
[0025] 6A84          ERRZZ  EQU  >6A84             ERROR MESSAGE ROUTINE
[0026] 6A86          READL1 EQU  >6A86             Read a line from keyboard
[0027] 7A06          GTLIST EQU  >7A06             GKXB address
[0028]               * GROM >A000
[0029] A002          LITS05 EQU  >A002             Literal string common code
[0030] A006          LINE   EQU  >A006             GET LINE NUMBER ROUTINE
[0031] A008          DATAST EQU  >A008             SEARCH FOR NEXT "DATA" STATEM
[0032] A012          CONV1  EQU  >A012             CONVERT WITH WARNING
[0033] A016          VALCD  EQU  >A016             CONVERT STRING TO NUMBER
[0034] A020          UBSUB  EQU  >A020             CLEAR BREAKPOINTS IN LN # TAB
[0035]               ***********************************************************
[0036]               *    Equates for routine in MONITOR
[0037] 0010          CALDSR EQU  >10               CALL DEVICE SERVICE ROUTINE
[0038] 0012          CFI    EQU  >12               CONVERT TO TWO BYTE INTEGER
[0039] 0034          TONE1  EQU  >34               ACCEPT TONE
[0040] 0036          TONE2  EQU  >36               BAD TONE
[0041] 0018          CHAR2Z EQU  >18               CHARACTER TABLE ADDRESS
[0042] 004A          CHAR3Z EQU  >4A               CHARACTER TABLE ADDRESS
[0043]               ***********************************************************
[0044]               *    Equates for XMLs
[0045] 0000          SYNCHK EQU  >00               SYNCHK XML selector
[0046] 0001          FILSPC EQU  >01               Fill-space utility
[0047] 0002          CSTRIN EQU  >02               Copy-string utility
[0048] 0003          SEETWO EQU  >03               SEETWO XML selector
[0049] 0070          COMPCT EQU  >70               PREFORM A GARBAGE COLLECTION
[0050] 0071          GETSTR EQU  >71               SYSTEM GET STRING
[0051] 0072          MEMCHK EQU  >72               MEMORY check routine: VDP
[0052] 0073          XCNS   EQU  >73               Convert number to string
[0053]               * Warning Default changed in >0073
[0054] 0074          PARSE  EQU  >74               Parse a value
[0055] 0075          CONT   EQU  >75               Continue parsing
[0056] 0077          VPUSH  EQU  >77               Push on value stack
[0057] 0078          VPOP   EQU  >78               Pop off value stack
[0058] 0079          PGMCHR EQU  >79               GET PROGRAM CHARACTER
[0059] 007A          SYM    EQU  >7A               Find SYMBOL entry
[0060] 007B          SMB    EQU  >7B               Also for ARRAYS
[0061] 007C          ASSGNV EQU  >7C               Assign VARIABLE
[0062] 007D          SCHSYM EQU  >7D               Search symbol table
[0063] 007E          SPEED  EQU  >7E               SPEED UP XML
[0064] 007F          CRUNCH EQU  >7F               Crunch an input line
[0065] 0080          CIF    EQU  >80               Convert INTEGER to FLOATING P

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0002 
RXB 2022
[0066] 0081          CONTIN EQU  >81               Continue after a break
[0067] 0083          SCROLL EQU  >83               SCROLL THE SCREEN
[0068] 0084          IO     EQU  >84               IO utility (KW table search)
[0069] 0085          GREAD  EQU  >85               READ DATA FROM ERAM
[0070] 0086          GWRITE EQU  >86               WRITE DATA TO ERAM
[0071] 0087          DELREP EQU  >87               REMOVE CONTENT FROM VDP/ERAM
[0072] 0088          MVDN   EQU  >88               MOVE DATA IN VDP/ERAM
[0073] 0089          MVUP   EQU  >89               MOVE DATA IN VDP/ERAM
[0074] 008A          VGWITE EQU  >8A               MOVE DATA FROM VDP TO ERAM
[0075] 008B          GVWITE EQU  >8B               WRITE DATA FROM GRAM TO VRAM
[0076] 008C          GREAD1 EQU  >8C               READ DATA FROM ERAM
[0077] 008E          GDTECT EQU  >8E               ERAM DETECT&ROM PAGE 1 ENABLE
[0078] 008F          SCNSMT EQU  >8F               SCAN STATEMENT FOR PRESCAN
[0079]               ***********************************************************
[0080]               *    Temporary workspaces in EDIT
[0081] 8300          VAR0   EQU  >8300            TEMPORARY
[0082] 8301          VAR1   EQU  >8301            TEMPORARY
[0083] 8302          ACCUM  EQU  >8302            # OF BYTES ACCUMULATOR (4 BYTE
[0084] 8302          STPT   EQU  >8302            TWO BYTES
[0085] 8302          MNUM   EQU  >8302            Ussually a counter
[0086] 8302          AAA1   EQU  >8302
[0087] 8304          VARY   EQU  >8304
[0088] 8304          PABPTR EQU  >8304            Pointer to current PAB
[0089] 8306          VARY2  EQU  >8306            Use in MVDN only
[0090] 8306          DFLTLM EQU  >8306            Default array limit (10)
[0091] 8306          CCPPTR EQU  >8306            OFFSET WITHIN RECORED (1)
[0092]               *                             or Pointer to current column
[0093] 8307          RECLEN EQU  >8307            LENGTH OF CURRENT RECORD (1)
[0094] 8308          CCPADR EQU  >8308            RAM address of current refs
[0095]               *                             or Actual buffer address or c
[0096] 8308          VARC   EQU  >8308
[0097] 8308          CCPADD EQU  >8308            RAM address of current color
[0098] 8308          CCC1   EQU  >8308
[0099] 830A          CALIST EQU  >830A            Call list for resolving refs
[0100] 830A          RAMPTR EQU  >830A            Pointer for crunching
[0101] 830A          STADDR EQU  >830A            Start address - usually for co
[0102] 830C          BYTES  EQU  >830C            BYTE COUNTER
[0103]               *                             or String length for GETSTR
[0104] 830C          NMPTR  EQU  >830C            Pointer save for pscan
[0105] 830C          BBB1   EQU  >830C
[0106] 830E          CHSAV  EQU  >830E
[0107] 830E          CURINC EQU  >830E            Increment for auto-num mode
[0108] 830E          VAR4   EQU  >830E
[0109] 8310          TOPSTK EQU  >8310            Top of data stack pointer
[0110] 8310          VAR5   EQU  >8310
[0111] 8311          VAR6   EQU  >8311
[0112] 8312          LINUM  EQU  >8312            Used to determine end of scan
[0113] 8314          NMLEN  EQU  >8314            Current line for auto-num
[0114] 8314          CURLIN EQU  >8314            Current line for auto-num
[0115]               *                             or Starting line number for L
[0116] 8316          VAR9   EQU  >8316
[0117] 8316          XFLAG  EQU  >8316            SCAN FLAG-BITS USED AS BELOW
[0118] 8317          DSRFLG EQU  >8317            INTERNAL =60, EXTERNAL =0 (1)
[0119] 8317          OPTFLG EQU  >8317            Option flag byte during OPEN
[0120] 8317          FORNET EQU  >8317            Nesting level of for/next
[0121] 8317          FNUM   EQU  >8317            Current file number for search
[0122]               ***********************************************************
[0123]               *    Permanent workspace variables
[0124] 8318          STRSP  EQU  >8318            String space begining
[0125] 831A          STREND EQU  >831A            String space ending
[0126] 831C          SREF   EQU  >831C            Temporary string pointer
[0127] 831E          SMTSRT EQU  >831E            Start of current statement
[0128] 8320          VARW   EQU  >8320            Screen address (CURSOR)
[0129] 8322          ERRCOD EQU  >8322            Return error code from ALC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0003 
RXB 2022
[0130] 8324          STVSPT EQU  >8324            Value-stack base
[0131] 8326          RTNG   EQU  >8326            Return vector from 9900 code
[0132] 8328          NUDTAB EQU  >8328            Start of NUD table
[0133] 832A          VARA   EQU  >832A            Ending display location
[0134] 832C          PGMPTR EQU  >832C            Program text pointer (TOKEN)
[0135] 832E          EXTRAM EQU  >832E            Line number table pointer
[0136] 8330          STLN   EQU  >8330            Start of line number table
[0137] 8332          ENLN   EQU  >8332            End of line number table
[0138] 8334          DATA   EQU  >8334            Data pointer for READ
[0139] 8336          LNBUF  EQU  >8336            Line table pointer for READ
[0140] 8338          INTRIN EQU  >8338            Add of intrinsic poly constant
[0141] 833A          SUBTAB EQU  >833A            Subprogram symbol table
[0142] 833C          IOSTRT EQU  >833C            PAB list/Start of I/O chain
[0143] 833E          SYMTAB EQU  >833E            Symbol table pointer
[0144] 8340          FREPTR EQU  >8340            Free space pointer
[0145] 8342          CHAT   EQU  >8342            Current charater/token
[0146] 8343          BASE   EQU  >8343            OPTION BASE value
[0147] 8344          PRGFLG EQU  >8344            Program/imperative flag
[0148] 8345          FLAG   EQU  >8345            General 8-bit flag
[0149] 8346          BUFLEV EQU  >8346            Crunch-buffer destruction leve
[0150] 8348          LSUBP  EQU  >8348            Last subprogram block on stack
[0151]               * FAC  EQU  >834A            Floating-point ACcurmulator
[0152] 834B          FAC1   EQU  FAC+1
[0153] 834C          FAC2   EQU  FAC+2
[0154] 834C          AAA    EQU  FAC+2
[0155] 834D          FAC3   EQU  FAC+3
[0156] 834E          FAC4   EQU  FAC+4
[0157] 834E          CCC    EQU  FAC+4
[0158] 834E          FFF    EQU  FAC+4
[0159] 834F          FAC5   EQU  FAC+5
[0160] 8350          FAC6   EQU  FAC+6
[0161] 8350          BBB    EQU  FAC+6
[0162] 8350          EEE    EQU  FAC+6
[0163] 8351          FAC7   EQU  FAC+7
[0164] 8352          FAC8   EQU  FAC+8
[0165] 8353          FAC9   EQU  FAC+9
[0166] 8354          FAC10  EQU  FAC+10
[0167] 8354          DDD1   EQU  FAC+10
[0168] 8355          FAC11  EQU  FAC+11
[0169] 8356          FAC12  EQU  FAC+12
[0170] 8356          FFF1   EQU  FAC+12
[0171] 8357          FAC13  EQU  FAC+13
[0172] 8358          FAC14  EQU  FAC+14
[0173] 8358          EEE1   EQU  FAC+14
[0174] 8359          FAC15  EQU  FAC+15
[0175] 835A          FAC16  EQU  FAC+16
[0176] 835B          FAC17  EQU  FAC+17
[0177]               * ARG  EQU  >835C             Floating-point ARGument
[0178] 835D          ARG1   EQU  ARG+1
[0179] 835E          ARG2   EQU  ARG+2
[0180] 835F          ARG3   EQU  ARG+3
[0181] 8360          ARG4   EQU  ARG+4
[0182] 8361          ARG5   EQU  ARG+5
[0183] 8362          ARG6   EQU  ARG+6
[0184] 8363          ARG7   EQU  ARG+7
[0185] 8364          ARG8   EQU  ARG+8
[0186] 8364          XSTLN  EQU  >8364            GKXB variable
[0187] 8366          TEMP5  EQU  >8366
[0188] 8367          ARG11  EQU  ARG+11
[0189] 836B          ARG15  EQU  ARG+15
[0190] 836C          ARG16  EQU  ARG+16
[0191]               * VSPTR  EQU  >836E          Value stack pointer
[0192]               ***********************************************************
[0193]               *    GPL Status Block

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0004 
RXB 2022
[0194] 8370          HIVDP  EQU  >8370             Highest VDP available
[0195] 8372          STACK  EQU  >8372             STACK FOR DATA
[0196] 8374          KEYBD  EQU  >8374             KEYBOARD SELCTION
[0197] 8375          RKEY   EQU  >8375             KEY CODE
[0198] 8376          EXPZ   EQU  >8376             Exponent in floating-point
[0199] 8378          RANDOM EQU  >8378             RANDOM NUMBER GENERATOR
[0200] 8379          TIMER  EQU  >8379             TIMING REGISTER
[0201] 837A          MOTION EQU  >837A             NUMBER OF MOVING SPRITES
[0202] 837B          VDPSTS EQU  >837B             VDP STATUS REGISTER
[0203] 837C          ERCODE EQU  >837C             STATUS REGISTER
[0204]               ***********************************************************
[0205] 8384          RAMTOP EQU  >8384            Highest address in ERAM
[0206] 8386          RAMFRE EQU  >8386            Free pointer in the ERAM
[0207] 8388          RSTK   EQU  >8388            Subroutine stack base
[0208]               *                             (Starts at >8A)
[0209] 8389          RAMFLG EQU  >8389            ERAM flag
[0210] 83AF          STKMIN EQU  >83AF            Base of data stack
[0211] 83BD          STKMAX EQU  >83BD            Top of data stack
[0212] 83CE          PRTNFN EQU  >83CE            Sound - previous tone finished
[0213]               ***********************************************************
[0214]               *    VDP addresses
[0215] 02E0          SCRNBS EQU  >02E0             Screen base addr for last lin
[0216] 02E2          NLNADD EQU  >02E2             New LiNe ADDress
[0217] 02FE          ENDSCR EQU  >02FE             END of SCReen address
[0218] 0371          LODFLG EQU  >0371             Auto-boot needed flag
[0219] 0372          START  EQU  >0372             Line to start execution at
[0220]               * Temporary
[0221] 0374          NOTONE EQU  >0374             NO-TONE for SIZE in ACCEPT us
[0222]               *                              in FLMGRS (4 bytes used)
[0223] 0376          SYMBOL EQU  >0376             Saved symbol table pointer
[0224] 0382          SPGMPT EQU  >0382             Saved PGMPTR for continue
[0225] 0384          SBUFLV EQU  >0384             Saved BUFLEV for contiue
[0226] 0386          SEXTRM EQU  >0386             Saved EXTRAM for continue
[0227] 0388          SAVEVP EQU  >0388             Saved VSPRT for continue
[0228] 038A          ERRLN  EQU  >038A             On-error line pointer
[0229] 038C          BUFSRT EQU  >038C             Edit recall start addr (VARW)
[0230] 038E          BUFEND EQU  >038E             Edit recall end addr (VARA)
[0231] 0390          CSNTMP EQU  >0390             Use as temporary stored place
[0232]               *                          or CSN TEMPORARY FOR FAC12
[0233] 0392          TABSAV EQU  >0392             Saved main symbol table ponte
[0234] 0394          AUTTMP EQU  >0394             AUTOLD TEMPORARY IN SIDE ERRZ
[0235] 0396          SLSUBP EQU  >0396             Saved LSUBP for continue
[0236] 0398          SFLAG  EQU  >0398             Saved on-warning/break bits
[0237] 039A          SSTEMP EQU  >039A             To save subprogram program ta
[0238] 039C          SSTMP2 EQU  >039C             Same as above. Used in SUBPRO
[0239]               * RXB PATCH CODE * MOVED TO >03B8 SIZXPT (Size ACCEPT AT)
[0240]               * MRGPAB EQU  >039E             MERGEd temporary for pab pt
[0241] 039E          PMEM   EQU  >039E             UPPER 24K MEMORY
[0242] 03B8          MRGPAB EQU  >03B8             MERGEd temporary for pab ptr
[0243] 03AA          INPUTP EQU  >03AA             INPUT TEMPORARY FOR PTR TO PR
[0244] 03AC          ACCVRW EQU  >03AC             Temoporary used in ERRZZ, als
[0245]               *                              used in FLMGRS
[0246]               *                             or temporary for @VARW, @VARA
[0247] 03AE          ACCVRA EQU  >03AE             TRY AGAIN
[0248] 03B0          VALIDP EQU  >03B0             Use as two values passing fro
[0249]               *                          or PTR TO STANDARD STRING IN VAL
[0250] 03B2          VALIDL EQU  >03B2             VALIDATE code to READL1
[0251]               *                          or Length of string in validate
[0252] 03B4          SIZCCP EQU  >03B4             SIZE TEMPORARY FOR CCPADR
[0253] 03B6          SIZREC EQU  >03B6             SIZE TEMPORARY FOR RECLEN
[0254]               *                            Also used as temporary in RELO
[0255]               *----------------------------------------------------------
[0256]               * Added 6/8/81 for NOPSCAN feature
[0257] 03B7          PSCFG  EQU  >03B7

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0005 
RXB 2022
[0258]               *----------------------------------------------------------
[0259] 03B7          ACCTRY EQU  >03B7             ACCEPT "TRY AGAIN" FLAG
[0260] 03B8          SIZXPT EQU  >03B8             Save XPT in SIZE when "try ag
[0261] 03B9          SAPROT EQU  >03B9             PROTECTION flag in SAVE
[0262] 03BA          CSNTP1 EQU  >03BA             CSN TEMPORARY FOR FAC10
[0263]               *----------------------------------------------------------
[0264]               *    Flag 0:  99/4  console, 5/29/81
[0265]               *         1:  99/4A console
[0266] 03BB          CONFLG EQU  >03BB
[0267]               *----------------------------------------------------------
[0268] 03BC          OLDTOP EQU  >03BC             Temporary used in ERRZZ, also
[0269]               *                          or Old top of memory for RELOCA
[0270] 03BC          CPTEMP EQU  >03BC             CCPPTR, RECLEN temp in INPUT
[0271] 03BE          NEWTOP EQU  >03BE             New top of memory for RELOCA
[0272] 03C0          VROAZ  EQU  >03C0             Temporary VDP Roll Out Area
[0273] 0820          CRNBUF EQU  >0820             CRuNch BUFfer address
[0274] 08BE          CRNEND EQU  >08BE             CRuNch buffer END
[0275] 08C0          RECBUF EQU  >08C0             Edit RECall BUFfer
[0276] 0958          VRAMVS EQU  >0958             Default base of value stack
[0277]               ***********************************************************
[0278]               *    IMMEDITATE VALUES
[0279] 0000          NUMBR  EQU  >00               NUMERIC validate
[0280] 0002          LISTZ  EQU  >02
[0281] 0005          OLDZ   EQU  >05
[0282] 0006          RESEQZ EQU  >06
[0283] 0007          SAVEZ  EQU  >07
[0284] 0008          MERGEZ EQU  >08
[0285] 000A          DWNARR EQU  >0A
[0286] 000B          UPARR  EQU  >0B
[0287] 000D          CHRTN  EQU  >0D
[0288] 0020          BKGD   EQU  >20               BACKGROUND CHARACTER
[0289] 0060          OFFSET EQU  >60               OFFSET FOR VIDEO TABLES
[0290] 0065          STRVAL EQU  >65               Value in accum. is string val
[0291]               ***********************************************************
[0292]               * Editting command equates
[0293] 0002          BREAK  EQU  >02               Break key
[0294] 0003          DLETE  EQU  >03               Delete key
[0295] 0004          INSRT  EQU  >04               Insert key
[0296] 0006          RECALL EQU  >06               Edit-buffer recall
[0297] 0007          CLRLN  EQU  >07               Clear-line key
[0298] 0008          BACK   EQU  >08               Back-space key
[0299] 0009          FORW   EQU  >09               Forward-space key
[0300] 000A          DOWN   EQU  >0A               Down-arrow key
[0301] 000B          UPMV   EQU  >0B               Up-arrow key
[0302] 001C          VWIDTH EQU  >1C               Screen width (PRINT)
[0303] 0020          SPACE  EQU  >20               Space key
[0304] 0022          QUOTE  EQU  >22               "
[0305] 0024          DOLLAR EQU  >24               $
[0306] 007E          CURSOR EQU  >1E+OFFSET        CURSOR
[0307] 007F          EDGECH EQU  >1F+OFFSET        EDGE character
[0308] 002C          COMMA  EQU  >2C               ,
[0309] 002D          MINUS  EQU  >2D               -
[0310]               ***********************************************************
[0311]               * PAB offset
[0312] 0000          CZOPEN EQU  0                 OPEN CODE
[0313] 0001          CZCLOS EQU  1                 CLOSE CODE
[0314] 0002          FIL    EQU  2                 File number within BASIC(0-25
[0315] 0002          CZREAD EQU  2                 READ CODE
[0316] 0003          OFS    EQU  3                 Offset within record
[0317] 0003          CZWRIT EQU  3                 WRITE CODE
[0318] 0004          COD    EQU  4                 I/O code
[0319] 0004          CZREST EQU  4                 RESTORE/REWIND CODE
[0320] 0005          FLG    EQU  5                 I/O mode flag byte
[0321] 0005          CZLOAD EQU  5                 LOAD CODE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0006 
RXB 2022
[0322] 0006          BUF    EQU  6                 Start of data buffer
[0323] 0006          CZSAVE EQU  6                 SAVE CODE
[0324] 0007          CZDELE EQU  7                 DELETE CODE
[0325] 0008          LEN    EQU  8                 Record length
[0326] 0008          CZSCR  EQU  8                 SCRATCH CODE
[0327] 0009          CNT    EQU  9                 Character count
[0328] 0009          CZSTAT EQU  9                 STATUS CODE
[0329] 000A          RNM    EQU  10                Record number
[0330] 000C          SCR    EQU  12                Screen base offset
[0331] 000D          NLEN   EQU  13                Length of file descriptor
[0332] 000E          PABLEN EQU  14                PAB LENGTH
[0333]               ***********************************************************
[0334]               *    BASIC TOKEN TABLE
[0335]               *      EQU  >80               spare token
[0336] 0081          ELSEZ  EQU  >81               ELSE
[0337] 0082          SSEPZ  EQU  >82               ::
[0338] 0083          TREMZ  EQU  >83               $
[0339] 0084          IFZ    EQU  >84               IF
[0340] 0085          GOZ    EQU  >85               GO
[0341] 0086          GOTOZ  EQU  >86               GOTO
[0342] 0087          GOSUBZ EQU  >87               GOSUB
[0343] 0088          RETURZ EQU  >88               RETURN
[0344] 0089          DEFZ   EQU  >89               DEF
[0345] 008A          DIMZ   EQU  >8A               DIM
[0346] 008B          ENDZ   EQU  >8B               END
[0347] 008C          FORZ   EQU  >8C               FOR
[0348] 008D          LETZ   EQU  >8D               LET   * RXB REMOVED
[0349] 008E          BREAKZ EQU  >8E               BREAK
[0350] 008F          UNBREZ EQU  >8F               UNBREAK
[0351] 0090          TRACEZ EQU  >90               TRACE
[0352] 0091          UNTRAZ EQU  >91               UNTRACE
[0353] 0092          INPUTZ EQU  >92               INPUT
[0354] 0093          DATAZ  EQU  >93               DATA
[0355] 0094          RESTOZ EQU  >94               RESTORE
[0356] 0095          RANDOZ EQU  >95               RANDOMIZE
[0357] 0096          NEXTZ  EQU  >96               NEXT
[0358] 0097          READZ  EQU  >97               READ
[0359] 0098          STOPZ  EQU  >98               STOP
[0360] 0099          DELETZ EQU  >99               DELETE
[0361] 009A          REMZ   EQU  >9A               REM
[0362] 009B          ONZ    EQU  >9B               ON
[0363] 009C          PRINTZ EQU  >9C               PRINT
[0364] 009D          CALLZ  EQU  >9D               CALL
[0365] 009E          OPTIOZ EQU  >9E               OPTION
[0366] 009F          OPENZ  EQU  >9F               OPEN
[0367] 00A0          CLOSEZ EQU  >A0               CLOSE
[0368] 00A1          SUBZ   EQU  >A1               SUB
[0369] 00A2          DISPLZ EQU  >A2               DISPLAY
[0370] 00A3          IMAGEZ EQU  >A3               IMAGE
[0371] 00A4          ACCEPZ EQU  >A4               ACCEPT
[0372] 00A5          ERRORZ EQU  >A5               ERROR
[0373] 00A6          WARNZ  EQU  >A6               WARNING
[0374] 00A7          SUBXTZ EQU  >A7               SUBEXIT
[0375] 00A8          SUBNDZ EQU  >A8               SUBEND
[0376] 00A9          RUNZ   EQU  >A9               RUN
[0377] 00AA          LINPUZ EQU  >AA               LINPUT
[0378]               *      EQU  >AB               spare token (LIBRARY)
[0379]               *      EQU  >AC               spare token (REAL)
[0380]               *      EQU  >AD               spare token (INTEGER)
[0381]               *      EQU  >AE               spare token (SCRATCH)
[0382]               *      EQU  >AF               spare token
[0383] 00B0          THENZ  EQU  >B0               THEN
[0384] 00B1          TOZ    EQU  >B1               TO
[0385] 00B2          STEPZ  EQU  >B2               STEP

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0007 
RXB 2022
[0386] 00B3          COMMAZ EQU  >B3               ,
[0387] 00B4          SEMICZ EQU  >B4               ;
[0388] 00B5          COLONZ EQU  >B5               :
[0389] 00B6          RPARZ  EQU  >B6               )
[0390] 00B7          LPARZ  EQU  >B7               (
[0391] 00B8          CONCZ  EQU  >B8               &          (CONCATENATE)
[0392]               *      EQU  >B9               spare token
[0393] 00BA          ORZ    EQU  >BA               OR
[0394] 00BB          ANDZ   EQU  >BB               AND
[0395] 00BC          XORZ   EQU  >BC               XOR
[0396] 00BD          NOTZ   EQU  >BD               NOT
[0397] 00BE          EQUALZ EQU  >BE               =
[0398] 00BF          LESSZ  EQU  >BF               <
[0399] 00C0          GREATZ EQU  >C0               >
[0400] 00C1          PLUSZ  EQU  >C1               +
[0401] 00C2          MINUSZ EQU  >C2               -
[0402] 00C3          MULTZ  EQU  >C3               *
[0403] 00C4          DIVIZ  EQU  >C4               /
[0404] 00C5          CIRCUZ EQU  >C5               ^
[0405]               *      EQU  >C6               spare token
[0406] 00C7          STRINZ EQU  >C7               QUOTED STRING
[0407] 00C8          UNQSTZ EQU  >C8               UNQUOTED STRING
[0408] 00C8          NUMZ   EQU  >C8               ALSO NUMERICAL STRING
[0409] 00C8          NUMCOZ EQU  >C8               ALSO UNQUOTED STRING
[0410] 00C9          LNZ    EQU  >C9               LINE NUMBER CONSTANT
[0411]               *      EQU  >CA               spare token
[0412] 00CB          ABSZ   EQU  >CB               ABS
[0413] 00CC          ATNZ   EQU  >CC               ATN
[0414] 00CD          COSZ   EQU  >CD               COS
[0415] 00CE          EXPZZ  EQU  >CE               EXP
[0416] 00CF          INTZ   EQU  >CF               INT
[0417] 00D0          LOGZ   EQU  >D0               LOG
[0418] 00D1          SGNZZ  EQU  >D1               SGN
[0419] 00D2          SINZ   EQU  >D2               SIN
[0420] 00D3          SQRZ   EQU  >D3               SQR
[0421] 00D4          TANZ   EQU  >D4               TAN
[0422] 00D5          LENZ   EQU  >D5               LEN
[0423] 00D6          CHRZZ  EQU  >D6               CHR$
[0424] 00D7          RNDZ   EQU  >D7               RND
[0425] 00D8          SEGZZ  EQU  >D8               SEG$
[0426] 00D9          POSZ   EQU  >D9               POS
[0427] 00DA          VAL    EQU  >DA               VAL
[0428] 00DB          STRZZ  EQU  >DB               STR$
[0429] 00DC          ASCZ   EQU  >DC               ASC
[0430] 00DD          PIZ    EQU  >DD               PI
[0431] 00DE          RECZ   EQU  >DE               REC
[0432] 00DF          MAXZ   EQU  >DF               MAX
[0433] 00E0          MINZ   EQU  >E0               MIN
[0434] 00E1          RPTZZ  EQU  >E1               RPT$
[0435]               *      EQU  >E2               unused
[0436]               *      EQU  >E2               unused
[0437]               *      EQU  >E3               unused
[0438]               *      EQU  >E4               unused
[0439]               *      EQU  >E5               unused
[0440]               *      EQU  >E6               unused
[0441]               *      EQU  >E7               unused
[0442] 00E8          NUMERZ EQU  >E8               NUMERIC
[0443] 00E9          DIGITZ EQU  >E9               DIGIT
[0444] 00EA          UALPHZ EQU  >EA               UALPHA
[0445] 00EB          SIZEZ  EQU  >EB               SIZE
[0446] 00EC          ALLZ   EQU  >EC               ALL
[0447] 00ED          USINGZ EQU  >ED               USING
[0448] 00EE          BEEPZ  EQU  >EE               BEEP
[0449] 00EF          ERASEZ EQU  >EF               ERASE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0008 
RXB 2022
[0450] 00F0          ATZ    EQU  >F0               AT
[0451] 00F1          BASEZ  EQU  >F1               BASE
[0452]               *      EQU  >F2               spare token (TEMPORARY)
[0453] 00F3          VARIAZ EQU  >F3               VARIABLE
[0454] 00F4          RELATZ EQU  >F4               RELATIVE
[0455] 00F5          INTERZ EQU  >F5               INTERNAL
[0456] 00F6          SEQUEZ EQU  >F6               SEQUENTIAL
[0457] 00F7          OUTPUZ EQU  >F7               OUTPUT
[0458] 00F8          UPDATZ EQU  >F8               UPDATE
[0459] 00F9          APPENZ EQU  >F9               APPEND
[0460] 00FA          FIXEDZ EQU  >FA               FIXED
[0461] 00FB          PERMAZ EQU  >FB               PERMANENT
[0462] 00FC          TABZ   EQU  >FC               TAB
[0463] 00FD          NUMBEZ EQU  >FD               #
[0464] 00FE          VALIDZ EQU  >FE               VALIDATE
[0465]               *      EQU  >FF               ILLEGAL VALUE
[0466]               ***********************************************************
[0467]                      TITL 'FLMGR-359'
[0468]               ***********************************************************
[0469]               *                        GROM HEADER
[0470]               ***********************************************************
[0471]               *    Branch table routines
[0472]               ***********************************************************
[0473] 8000 42,5D           BR   DISPL1            DISPLAY routine
[0474] 8002 41,82           BR   DELET             DELETE routine
[0475] 8004 42,6C           BR   PRINT             PRINT routine
[0476] 8006 45,F6           BR   INPUT             INPUT routine (not yet impele
[0477] 8008 40,32           BR   OPEN              OPEN routine
[0478] 800A 41,9C           BR   CLOSE             CLOSE routine
[0479] 800C 42,02           BR   RESTOR            RESTORE routine
[0480] 800E 4B,40           BR   READ              READ routine
[0481] 8010 53,0E           BR   GETDAT            Get DATA from ERAM/VDP (not u
[0482] 8012 41,FA           BR   CLSALL            CLOSE ALL OPEN FILES subrouti
[0483] 8014 4D,BE           BR   SAVE              SAVE routine
[0484] 8016 4B,CA           BR   OLD               LOAD routine
[0485] 8018 50,6E           BR   LIST              LIST routine
[0486] 801A 56,AB           BR   OUTREC            Output record routine
[0487] 801C 51,E4           BR   EOF               End of file routine
[0488] 801E 49,71           BR   ACCEPT            ACCEPT routine
[0489] 8020 4B,9C           BR   SRDATA            Search "DATAZ" routine
[0490] 8022 51,D0           BR   SUBREC            RECORD routine
[0491] 8024 55,B3           BR   CHKEND            Check EOS
[0492] 8026 4B,D0           BR   OLD1              A subroutine for LOAD
[0493] 8028 50,08           BR   MERGE             MERGE a program
[0494] 802A 51,7F           BR   GRMLST            List a line out of ERAM
[0495] 802C 51,AA           BR   GRSUB2            Read 2 bytes of data from ERA
[0496] 802E 51,C2           BR   GRSUB3            Read 2 bytes of data from ERA
[0497]               *                             with resetting possible break
[0498] 8030 48,47           BR   LINPUT              LINPUT statement
[0499]               ***********************************************************
[0500]               *               OPEN STATEMENT HANDLER
[0501]               * Handle the BASIC OPNE statement. A legal syntax can only
[0502]               * be something like
[0503]               *      OPEN #{exp}:{string-exp}[,{open-options}]
[0504]               * in which {open-option} is any of the following
[0505]               * DISPLAY, INPUT, VARIABLE, RELATIVE, INTERNAL, SEQUENTIAL,
[0506]               * OUTPUT, UPDATE, APPEND, FIXED or PERMANENT
[0507]               *
[0508]               * Each keyword can only be used once, which is being checke
[0509]               * with an OPTFLG-bit. For each specific option please refer
[0510]               * to the related routine.
[0511]               * Scanning stops as soon as no next field starting with a
[0512]               * comma can be found.
[0513]               * NOTE: After the actual DSR OPEN has been preformed, the

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0009 
FLMGR-359
[0514]               *       length of the record, whether VARIABLE or FIXED,
[0515]               *       has to be non-zero. A zero length will cause an
[0516]               *       INCORRECT STATEMENT error.
[0517]               ***********************************************************
[0518] 8032 CB,70,3C OPEN   DCHE >3CE2,@HIVDP      CALL FILES(0) USED ILLEGAL 
       8035 E2
[0519] 8036 77,CD           BS   ERRMEM            ERROR MEMORY (all used)
[0520] 8038 06,93,5B        CALL CHKFN             See if we specified any file
[0521] 803B 77,DD           BS   ERRFE             Definitely not... no # or #0
[0522] 803D 06,93,77        CALL CHKCON            Check and search given filenu
[0523] 8040 77,DD           BS   ERRFE             *** FILE NUMBER EXISTS ***
[0524]               * ERROR IF NOT STOPPED ON COLON
[0525] 8042 0F,7E           XML  SPEED             Must be at a
[0526] 8044 00              BYTE SYNCHK          *  colon or else
[0527] 8045 B5              BYTE COLONZ          *   its an error
[0528] 8046 06,96,60        CALL PARFN             Parse filename and create PAB
[0529] 8049 93,2C           DDEC @PGMPTR           Backup pgm pointer for next t
[0530] 804B 0F,79    OPTION XML  PGMCHR            Get next program character
[0531]               * Next field should start with a comma
[0532] 804D D6,42,B3 OPTIZ0 CEQ  COMMAZ,@CHAT
[0533] 8050 41,13           BR   CHECK
[0534]               * Enter HERE after comma exit in "SEQUENTIAL"
[0535] 8052 0F,79    OPTIZ1 XML  PGMCHR            Next token please...
[0536]               * Treat DISPLAY and INPUT as special cases
[0537] 8054 D6,42,A2        CEQ  DISPLZ,@CHAT
[0538] 8057 60,F0           BS   OPTZ6
[0539] 8059 D6,42,92        CEQ  INPUTZ,@CHAT
[0540] 805C 60,FA           BS   OPTZ7
[0541] 805E A6,42,F3        SUB  VARIAZ,@CHAT      Reduce keyword offset to 0
[0542] 8061 CA,42,09        CHE  9,@CHAT           Keyword to high
[0543] 8064 61,0C           BS   OPERR
[0544] 8066 8A,42           CASE @CHAT             JUST IN CASE
[0545] 8068 40,C4           BR   OPTZ01            Option VARIABLE
[0546] 806A 40,82           BR   OPTZ02                   RELATIVE
[0547] 806C 40,EB           BR   OPTZ03                   INTERNAL
[0548] 806E 40,87           BR   OPTZ1                    SEQUENTIAL
[0549] 8070 40,AE           BR   OPTZ2                    OUTPUT
[0550] 8072 40,B3           BR   OPTZ3                    UPDATE
[0551] 8074 40,BD           BR   OPTZ4                    APPEND
[0552] 8076 40,C9           BR   OPTZ5                    FIXED
[0553]               *      BR   OPTZ0                    PERMANENT       <<<<<<
[0554]               * CASE 0 - "PERMANENT" ************************************
[0555]               *  Only check for multiple usage. Since PERMANENT is the
[0556]               *  default, we might as well ignore it...
[0557] 8078 DA,17,04 OPTZ0  CLOG >04,@OPTFLG
[0558] 807B 41,0C           BR   OPERR
[0559] 807D B6,17,04        OR   >04,@OPTFLG       Not used ... use now
[0560] 8080 40,4B           BR   OPTION            Treat as simple default
[0561]               * CASE 2 - "RELATIVE" *************************************
[0562]               *  Select relative record file in PAB and fall through in
[0563]               *  SEQUENTIAL code for multiple usage check. Also handle
[0564]               *  initial file-size there.
[0565] 8082 B6,E0,05 OPTZ02 OR   >01,V@FLG(@PABPTR) Indicate RELATIVE RECORD
       8085 04,01
[0566]               * CASE 4 - "SEQUENTIAL" ***********************************
[0567]               *  Checks for multiple usage. Remainder of syntax demads th
[0568]               *  we have something like:
[0569]               *                         [{numeric expression}],...
[0570]               *  In case only a comma is found, we use the default.
[0571]               *  Everything else has to be evaluated as a numeric
[0572]               *  expression, convertable to a 16-bit integer value.
[0573] 8087 DA,17,08 OPTZ1  CLOG >08,@OPTFLG
[0574] 808A 41,0C           BR   OPERR
[0575] 808C B6,17,08        OR   >08,@OPTFLG       First time usage, ok

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0010 
FLMGR-359
[0576] 808F 0F,79           XML  PGMCHR            Check next token for default
[0577]               * Comma means default has been used
[0578] 8091 D6,42,B3        CEQ  COMMAZ,@CHAT
[0579] 8094 60,52           BS   OPTIZ1
[0580] 8096 06,95,B3        CALL CHKEND            Check for end of statement
[0581] 8099 61,13           BS   CHECK
[0582] 809B 06,80,A5        CALL CHKPAR            Preform combined checking & p
[0583] 809E BD,E0,0A        DST  @FAC,V@RNM(@PABPTR) Non-zero result
       80A1 04,4A
[0584] 80A3 40,4D           BR   OPTIZ0            Scan other options
[0585]               * Parse and check a numeric argument in here....
[0586] 80A5 0F,74    CHKPAR XML  PARSE             If not ... parse up to comma
[0587] 80A7 B3              BYTE COMMAZ
[0588] 80A8 06,93,62        CALL CHKCNV            Check and convert to integer
[0589] 80AB 61,0C           BS   OPERR             Oops..., someone made a mista
[0590] 80AD 00              RTN                    Return to caller
[0591]               * CASE 5 - "OUTPUT" ***************************************
[0592]               *  Select mode code "01" and check for multiple usage. Use
[0593]               *  MFLAG bit in OPTFLG for checking.
[0594] 80AE B6,E0,05 OPTZ2  OR   >02,V@FLG(@PABPTR)  Mode code = 01
       80B1 04,02
[0595]               * CASE 6 - "UPDATE" ***************************************
[0596]               *  Default ... Check for multiple usage only...
[0597]               *  Test for previous usage of any mode setting
[0598] 80B3 DA,17,01 OPTZ3  CLOG >01,@OPTFLG
[0599] 80B6 41,0C           BR   OPERR
[0600] 80B8 B6,17,01        OR   >01,@OPTFLG       If not... set "MODE USED" bit
[0601] 80BB 40,4B           BR   OPTION            Continue option scan
[0602]               * CASE 7 - "APPEND" ***************************************
[0603]               *  Mode code "11" indicates APPEND mode.
[0604] 80BD B6,E0,05 OPTZ4  OR   >06,V@FLG(@PABPTR)  Mode code = 11
       80C0 04,06
[0605] 80C2 40,B3           BR   OPTZ3
[0606]               * CASE 1 - "VARIABLE" *************************************
[0607]               *  Change record type to VARIABLE and continue as FIXED
[0608] 80C4 B6,E0,05 OPTZ01 OR   >10,V@FLG(@PABPTR)  Indicate variable length mo
       80C7 04,10
[0609]                
[0610]               * CASE 8 - "FIXED" ****************************************
[0611]               *  Fixed is default. Don't change anything, unless argument
[0612]               *  is given. In this case evaluate as numeric expression an
[0613]               *  check for 8-bit integer range...
[0614]               *  This routine is also used for VARIABLE !!!!!
[0615] 80C9 0F,79    OPTZ5  XML  PGMCHR            Get next character
[0616] 80CB D6,42,B3        CEQ  COMMAZ,@CHAT      Could be some argument
[0617] 80CE 60,E1           BS   OPTZ55
[0618] 80D0 06,95,B3        CALL CHKEND            Could also be end of statemen
[0619] 80D3 60,E1           BS   OPTZ55            It is an EOS
[0620] 80D5 06,80,A5        CALL CHKPAR            Check & parse expression
[0621]               * Check for byte overflow (records can only be up to 255
[0622]               * bytes in length)
[0623] 80D8 8E,4A           CZ   @FAC
[0624] 80DA 41,0C           BR   OPERR
[0625] 80DC BC,E0,08        ST   @FAC1,V@LEN(@PABPTR) Select non-zero rec-size
       80DF 04,4B
[0626] 80E1 DA,17,10 OPTZ55 CLOG >10,@OPTFLG
[0627] 80E4 41,0C           BR   OPERR
[0628] 80E6 B6,17,10        OR   >10,@OPTFLG       Prevent to much usage of mode
[0629] 80E9 40,4D           BR   OPTIZ0             Continue option scan
[0630]               * CASE 3 - "INTERNAL" *************************************
[0631]               *  Select INTERANL file type and continue in DIPLAY
[0632] 80EB B6,E0,05 OPTZ03 OR   8,V@FLG(@PABPTR)  Select INTERNAL type
       80EE 04,08
[0633]               * CASE 9 - "DISPLAY" **************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0011 
FLMGR-359
[0634]               *  Default. Only check for multiple usage of either DISPLAY
[0635]               *  or INTERNAL...
[0636] 80F0 DA,17,02 OPTZ6  CLOG >02,@OPTFLG
[0637] 80F3 41,0C           BR   OPERR
[0638] 80F5 B6,17,02        OR   >02,@OPTFLG       Else set "DISPLAY/INTERAL" fl
[0639] 80F8 40,4B           BR   OPTION            Continue... DISPLAY is defaul
[0640]               * CASE 10 "INPUT" *****************************************
[0641]               *  Same as any other I/O type definition. Mode code "10" ..
[0642]               *  Continue in OPTZ3
[0643] 80FA B6,E0,05 OPTZ7  OR   >04,V@FLG(@PABPTR) Mode code = 10
       80FD 04,04
[0644] 80FF 40,B3           BR   OPTZ3
[0645]               * CLRFRE deallocates previously alocated (parts of) PAB's a
[0646]               * return with an error message
[0647] 8101 86,02    CLRFRE CLR  @MNUM             Undo any allocation
[0648] 8103 BC,03,E0        ST   V@OFS(@PABPTR),@MNUM+1  We need the length for
       8106 03,04
[0649]               *                                    that
[0650]               *      V@OFS(@PABPTR) Was set up in PARFN routine
[0651] 8108 A1,40,02        DADD @MNUM,@FREPTR     Update the first free world
[0652] 810B 00              RTN                    And return
[0653] 810C 06,81,01 OPERR  CALL CLRFRE            First undo the allocation
[0654] 810F 06,6A,84 ERRSYN CALL ERRZZ             Then give an error
[0655] 8112 03              BYTE 3                 * SYNTAX ERROR
[0656]               * Continue with CHECK to conplete the actual OPEN
[0657] 8113 06,95,B3 CHECK  CALL CHKEND            Check EOS
[0658] 8116 41,0C           BR   OPERR             Not EOS  : SYNTAX ERROR
[0659]               * If the user hasn't specified VARIABLE or FIXED, the
[0660]               * default specification depends on the file type.
[0661]               * Change current default (=VARIABLE) to FIXED for
[0662]               * RELATIVE files.
[0663] 8118 DA,E0,05        CLOG >01,V@FLG(@PABPTR) RELATIVE RECORD
       811B 04,01
[0664] 811D 61,2D           BS   G8127
[0665] 811F DA,E0,05        CLOG >10,V@FLG(@PABPTR) VARIABLE RECORD
       8122 04,10
[0666] 8124 61,2B           BS   G8125
[0667] 8126 06,81,01 FILZZ  CALL CLRFRE            Undo the PAB allocation
[0668] 8129 57,DD           BR   ERRFE             FILE ERROR
[0669] 812B 41,37    G8125  BR   G8131             Sequential file, check rec. m
[0670] 812D DA,17,10 G8127  CLOG >10,@OPTFLG       No definition yet
[0671] 8130 41,37           BR   G8131
[0672] 8132 B6,E0,05        OR   >10,V@FLG(@PABPTR) Force VARIABLE mode
       8135 04,10
[0673] 8137 06,97,71 G8131  CALL CDSR              Call the DSR, return with err
[0674] 813A 57,9A           BR   ERRZ2B             indication in COND...
[0675] 813C 87,E0,0A        DCLR V@RNM(@PABPTR)    Make sure we start with recor
       813F 04
[0676]               * Check for undefined record length. The record length for
[0677]               * any type might be defined by the DSR
[0678] 8140 8E,E0,08        CZ   V@LEN(@PABPTR)
       8143 04
[0679] 8144 61,26           BS   FILZZ
[0680] 8146 BC,03,E0        ST   V@LEN(@PABPTR),@MNUM+1 Get record length
       8149 08,04
[0681] 814B 86,02           CLR  @MNUM             Create two byte result and
[0682] 814D 86,E0,03        CLR  V@OFS(@PABPTR)     allocate - remove offset for
       8150 04
[0683]               *                              later use
[0684] 8151 BD,4A,02        DST  @MNUM,@FAC        - prepare for space claim
[0685]               * Check for special case : no PAB's yet
[0686] 8154 8F,3C           DCZ  @IOSTRT
[0687] 8156 41,5D           BR   G8157
[0688] 8158 BD,3C,04        DST  @PABPTR,@IOSTRT   Simply enter the first pointe

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0012 
FLMGR-359
[0689] 815B 41,6F           BR   G8169
[0690] 815D BD,0A,3C G8157  DST  @IOSTRT,@STADDR   Search for the end of the cha
[0691] 8160 8F,B0,0A G815A  DCZ  V*STADDR
[0692] 8163 61,6B           BS   G8165
[0693] 8165 BD,0A,B0        DST  V*STADDR,@STADDR  Keep on deferring
       8168 0A
[0694] 8169 41,60           BR   G815A
[0695] 816B BD,B0,0A G8165  DST  @PABPTR,V*STADDR  Update last chain link
       816E 04
[0696] 816F BD,E0,06 G8169  DST  @PABPTR,V@BUF(@PABPTR) Set empty buffer first
       8172 04,04
[0697] 8174 0F,72           XML  MEMCHK            Check memory overflow & strin
[0698] 8176 77,CD           BS   ERRMEM            * MEMORY FULL
[0699] 8178 A5,40,02        DSUB @MNUM,@FREPTR     Compute buffer entry address
[0700] 817B A5,E0,06        DSUB @MNUM,V@BUF(@PABPTR) Correct buffer address in
       817E 04,02
[0701] 8180 0F,75           XML  CONT              Return to the parser
[0702]               ***********************************************************
[0703]               *                    DELETE ROUTINE
[0704]               * Use file # 0 for this operation. Parse the file name
[0705]               * string-expression as usual, and delete the PAB before
[0706]               * actually calling the DSR.
[0707]               ***********************************************************
[0708] 8182 86,17    DELET  CLR  @FNUM             Create file #0 - non-existing
[0709] 8184 06,96,60        CALL PARFN             Handle as normal PAB OPEN
[0710] 8187 06,95,B3        CALL CHKEND            Check EOS first
[0711] 818A 41,0C           BR   OPERR             Not EOS : go undo PAB allocat
[0712]               *                              and print SYNTAX ERROR
[0713] 818C 86,02           CLR  @MNUM       *  Delete PAB again before calling
[0714] 818E BC,03,E0        ST   V@OFS(@PABPTR),@MNUM+1  Create double byte PAB
       8191 03,04
[0715]                
[0716] 8193 A1,40,02        DADD @MNUM,@FREPTR     Update free word pointer
[0717] 8196 06,97,64        CALL IOCALL            Preform I/O call for actual d
[0718] 8199 07              BYTE CZDELE
[0719] 819A 0F,75           XML  CONT
[0720]               ***********************************************************
[0721]               *                    CLOSE ROUTINE
[0722]               * Syntax could be
[0723]               * CLOSE #{ num exp }  or CLOSE #{ num exp }:DELETE
[0724]               *
[0725]               * Possibly output pending records before closing or
[0726]               * deleting the file.
[0727]               ***********************************************************
[0728] 819C 06,93,5B CLOSE  CALL CHKFN             Check for "no #" / "#0" cases
[0729] 819F 77,DD           BS   ERRFE             Not for "CLOSE" you don't
[0730] 81A1 06,93,77        CALL CHKCON            Check file number etc...
[0731] 81A4 57,DD           BR   ERRFE             *** FILE NUMBER NOT IN SYSTEM
[0732] 81A6 06,93,96        CALL OUTEOF            Output pending records
[0733] 81A9 BE,E0,04        ST   CZCLOS,V@COD(@PABPTR) Default to CLOSE I/O code
       81AC 04,01
[0734] 81AE D6,42,B5        CEQ  COLONZ,@CHAT      Check for ":DELETE" spec.
[0735] 81B1 41,BE           BR   G81B8
[0736] 81B3 0F,79           XML  PGMCHR            Request next input token
[0737] 81B5 0F,7E           XML  SPEED             Must be at a
[0738] 81B7 00              BYTE SYNCHK          *  "DELETE" else
[0739] 81B8 99              BYTE DELETZ          *   its an error
[0740] 81B9 BE,E0,04        ST   CZDELE,V@COD(@PABPTR) Change CLOSE to DELETE
       81BC 04,07
[0741] 81BE 06,95,B3 G81B8  CALL CHKEND            EOS?
[0742] 81C1 41,0F           BR   ERRSYN            NO:SYNTAX ERROR
[0743] 81C3 06,97,71        CALL CDSR              Call DSR with whatever we hav
[0744] 81C6 41,CD           BR   CLOSZ1            Reset means error....
[0745] 81C8 06,93,AC        CALL DELPAB            Delete PAB and data-buffer

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0013 
FLMGR-359
[0746] 81CB 0F,75           XML  CONT              Return to parser routine
[0747] 81CD BD,5C,E0 CLOSZ1 DST  V@4(@PABPTR),@ARG Save error code for message
       81D0 04,04
[0748] 81D2 06,93,AC        CALL DELPAB            Now delete the PAB
[0749] 81D5 BD,04,40        DST  @FREPTR,@PABPTR   Store error-code in free memo
[0750] 81D8 A7,04,00        DSUB 6,@PABPTR         Create standard size PAB
       81DB 06
[0751] 81DC BD,E0,04        DST  @ARG,V@4(@PABPTR) Copy error-code
       81DF 04,5C
[0752] 81E1 57,C1           BR   ERRIO             Exit to error-routine
[0753]               ***********************************************************
[0754]               *                   CLOSE ALL ROUTINE
[0755]               * CLOSE all the existing PABs ... ignore errors
[0756]               *
[0757]               * NOTE: "CLSLBL" is used in the I/O error routine to
[0758]               *       determine if a warning should be given rather than
[0759]               *       an error.
[0760]               ***********************************************************
[0761] 81E3 BD,04,B0 G81DD  DST  V*PABPTR,@PABPTR
       81E6 04
[0762] 81E7 8F,B0,04 CLSAZ0 DCZ  V*PABPTR          Find last PAB in chain
[0763] 81EA 41,E3           BR   G81DD
[0764] 81EC 06,93,96        CALL OUTEOF            Take care of pending records
[0765] 81EF BE,E0,04 CLSLBL ST   CZCLOS,V@COD(@PABPTR) Select CLOSE code
       81F2 04,01
[0766] 81F4 06,97,71        CALL CDSR              CLOSE to DSR routine
[0767] 81F7 06,93,AC        CALL DELPAB            Delete PAB - ignore CLOSE err
[0768] 81FA BD,04,3C CLSALL DST  @IOSTRT,@PABPTR   Start at beginning of chain
[0769] 81FD 8F,3C           DCZ  @IOSTRT           Continue until done
[0770] 81FF 41,E7           BR   CLSAZ0
[0771] 8201 00              RTN                    And return
[0772]               ***********************************************************
[0773]               *                   RESTORE ROUTINE
[0774]               * RESTORE can have any of four forms:
[0775]               *
[0776]               * RESTORE                     Restore to first DATA
[0777]               * RESTORE 20                  Restore DATA pointer
[0778]               * RESTORE #1                  Rewind file number 1
[0779]               * RESTORE #1, REC 2           Position file 1 at record 2
[0780]               ***********************************************************
[0781] 8202 87,4A    RESTOR DCLR @FAC              Assume simple RESTORE
[0782] 8204 D6,42,FD        CEQ  NUMBEZ,@CHAT
[0783] 8207 42,25           BR   OLDCD
[0784] 8209 06,93,5B        CALL CHKFN             Check for #<filenumber>
[0785] 820C 8F,4A           DCZ  @FAC              Found equivalent of #0
[0786] 820E 62,2D           BS   OLDCZ0
[0787] 8210 06,93,77        CALL CHKCON            Check and decode file #
[0788] 8213 57,DD           BR   ERRFE             Give error if file not there
[0789] 8215 06,93,96        CALL OUTEOF            Output pending record
[0790] 8218 87,E0,0A        DCLR V@RNM(@PABPTR)    Initialize to record 0
       821B 04
[0791] 821C 06,94,C8        CALL PARREC            Parse possible record clause
[0792] 821F 06,97,64        CALL IOCALL            Call DSR routine with
[0793] 8222 04              BYTE CZREST          *   RESTORE I/O code
[0794] 8223 0F,75           XML  CONT              Return if no error found
[0795]               * Following code is for handling RESTORE to line number
[0796]               * within program
[0797] 8225 06,95,B3 OLDCD  CALL CHKEND            Check for start with end
[0798] 8228 62,2D           BS   OLDCZ0            If we have anything else
[0799] 822A 06,A0,06        CALL LINE               in FAC (double)
[0800] 822D D5,30,32 OLDCZ0 DCEQ @ENLN,@STLN
[0801] 8230 42,39           BR   G8233
[0802] 8232 06,6A,82 WRNNPP CALL WARNZZ            * NO PROGRAM PRESENT *
[0803] 8235 1D              BYTE 29

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0014 
FLMGR-359
[0804] 8236 05,60,12        B    TOPL15            Go back to toplevel
[0805] 8239 BD,36,32 G8233  DST  @ENLN,@LNBUF      Start at beginning of program
[0806] 823C A7,36,00        DSUB 3,@LNBUF          Backup for first line number
       823F 03
[0807]               * Check against given line number
[0808] 8240 06,91,C2 OLDCZ1 CALL GRSUB3            Read 2 bytes of line ptr from
[0809]               *                              line # table which is in ERA
[0810] 8243 36              BYTE LNBUF           * Source address on ERAM/VDP
[0811]               *                             @EEE1: Destination addr on CP
[0812] 8244 C5,4A,58        DCH  @EEE1,@FAC        Try to get something higher
[0813] 8247 42,54           BR   G824E
[0814] 8249 D5,36,30        DCEQ @STLN,@LNBUF      Last line in program
[0815] 824C 77,D9           BS   ERRDAT
[0816] 824E A7,36,00        DSUB 4,@LNBUF          Get next entry in line # tabl
       8251 04
[0817] 8252 42,40           BR   OLDCZ1            Try again with next line
[0818] 8254 A3,36,00 G824E  DADD 3,@LNBUF          Undo subtraction
       8257 03
[0819] 8258 06,A0,08        CALL DATAST            Setup pointer for READ
[0820] 825B 0F,75           XML  CONT              Continue PARSE
[0821]               ***********************************************************
[0822]               *                 DISPLAY ROUTINE
[0823]               * DISPLAY handles all random screen access stuff..
[0824]               * the AT-clause, and the BEEP, ERASE ALL and SIZE clause.
[0825]               ***********************************************************
[0826] 825D 06,94,F5 DISPL1 CALL DISACC            Evaluate DISPLAY options
[0827] 8260 63,9B           BS   EOLEX             EXIT directly on end-of-state
[0828]               * If anything is specified it has to be a colon
[0829] 8262 8E,04           CZ   @PABPTR           Nothing was specified
[0830] 8264 62,CA           BS   PRINZ1
[0831]               * At this point we MUST have a colon, or else we error off
[0832]               * (SYNTAX ERROR)
[0833] 8266 0F,7E           XML  SPEED             Check for a colon
[0834] 8268 00              BYTE SYNCHK          *  and continue
[0835] 8269 B5              BYTE COLONZ          *   it approved
[0836] 826A 42,CA           BR   PRINZ1            Continue with PRINT items
[0837]               ***********************************************************
[0838]               *                    PRINT ROUTINE
[0839]               * MAIN-HANDLER FOR ALL PRINT-FUNCTIONS
[0840]               ***********************************************************
[0841] 826C 06,97,45 PRINT  CALL INITKB            Initialize keyboard I/O
[0842] 826F D6,42,FD        CEQ  NUMBEZ,@CHAT      Could still be anything
[0843] 8272 42,CA           BR   PRINZ1
[0844] 8274 06,93,5B        CALL CHKFN             Check if default or open chan
[0845] 8277 8F,4A           DCZ  @FAC              Default intended
[0846] 8279 62,AB           BS   PRNZ10
[0847] 827B 06,93,77        CALL CHKCON            Check and convert expression
[0848] 827E 57,DD           BR   ERRFE             Error if PAB not in system
[0849]               * PRINT allowed in output, append or update modes
[0850]               *       Not allowed in input mode
[0851] 8280 DA,E0,05        CLOG >04,V@FLG(@PABPTR)
       8283 04,04
[0852] 8285 62,8E           BS   G8288
[0853] 8287 DA,E0,05        CLOG >02,V@FLG(@PABPTR)
       828A 04,02
[0854] 828C 77,DD           BS   ERRFE
[0855] 828E D6,E0,04 G8288  CEQ  CZREAD,V@COD(@PABPTR)
       8291 04,02
[0856] 8293 42,99           BR   G8293
[0857] 8295 86,E0,03        CLR  V@OFS(@PABPTR)    Unpend pending INPUTs
       8298 04
[0858] 8299 BE,E0,04 G8293  ST   CZWRIT,V@COD(@PABPTR) uncomplete PRINTs
       829C 04,03
[0859] 829E 06,96,FB        CALL PRINIT            Initialize some variables

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0015 
FLMGR-359
[0860]               * Next character has to be either EOL, COMMA, or COLON
[0861] 82A1 06,95,B3        CALL CHKEND
[0862] 82A4 63,9B           BS   EOLEX              exit on end of statement
[0863] 82A6 06,94,C8        CALL PARREC            Parse possible record clause
[0864] 82A9 62,B7           BS   PRINZ0            found "," but no REC clause
[0865] 82AB 06,95,B3 PRNZ10 CALL CHKEND
[0866] 82AE 63,9B           BS   EOLEX             Exit on end of statement for
[0867]               *                       "PRINT #0" or "PRINT file position"
[0868] 82B0 D6,42,B3        CEQ  COMMAZ,@CHAT
[0869] 82B3 42,C4           BR   G82BE
[0870] 82B5 0F,79           XML  PGMCHR            Get next in line
[0871] 82B7 8E,04    PRINZ0 CZ   @PABPTR           For "PRINT #0"
[0872] 82B9 63,D5           BS   USING
[0873]               *         Interal type of file?
[0874] 82BB DA,E0,05        CLOG >08,V@FLG(@PABPTR)
       82BE 04,08
[0875] 82C0 57,DD           BR   ERRFE
[0876] 82C2 43,D5           BR   USING             Execute USING clause
[0877] 82C4 0F,7E    G82BE  XML  SPEED             Must be at a
[0878] 82C6 00              BYTE SYNCHK          *   colon at this point
[0879] 82C7 B5              BYTE COLONZ          *     and error off on others
[0880] 82C8 42,CF           BR   CONPRT            Make it a short branched ELSE
[0881] 82CA D6,42,ED PRINZ1 CEQ  USINGZ,@CHAT
[0882] 82CD 63,D5           BS   USING             End standard initialization
[0883]               * Test standard separators
[0884] 82CF 06,96,2D CONPRT CALL TSTSEP            Test separator character
[0885] 82D2 D6,42,FC        CEQ  TABZ,@CHAT        Handle TABs
[0886] 82D5 63,33           BS   PRTAB
[0887]               * At this point we've checked TAB and ; , :
[0888]               * The only remaining print items have to be expressions
[0889]               *  All expressions are being handled below.
[0890]               * If the result of the expression is a numeric, the string
[0891]               * is transformed into a string and printed. Strings are
[0892]               * printed "as is".
[0893]               *  The code for strings and converted numerics cannot be ma
[0894]               * common, since numerics may require an extra space behind
[0895]               * the item, depending upon the current position in the reco
[0896]               *  Either way, the string is chunked up into little pieces
[0897]               * it won't fit in an empty record.
[0898] 82D7 0F,74           XML  PARSE             Evaluate the expression
[0899] 82D9 B5              BYTE COLONZ
[0900]               * Special code for INTERNAL file handling
[0901]               *  Translate numeric datums into string format and indicate
[0902]               * length 8. Then check to see if the item fits within the
[0903]               * current record. If not, it is an error, since each item
[0904]               * has to fit.
[0905] 82DA 06,83,CB        CALL TSTINT            Test for internal files
[0906] 82DD 63,09           BS   OTHEZ1            Nope, something different
[0907] 82DF D6,4C,65        CEQ  STRVAL,@FAC2      Change numerics
[0908] 82E2 62,F2           BS   G82EC
[0909] 82E4 BE,56,08        ST   8,@FAC12          To string length 8
[0910] 82E7 35,00,08        MOVE 8,@FAC,@ARG       Save in ARG
       82EA 5C,4A
[0911] 82EC BE,55,5C        ST   ARG,@FAC11        And use this as source
[0912] 82EF 06,96,11        CALL RSTRING           Reserve some string space
[0913] 82F2 BC,5C,07 G82EC  ST   @RECLEN,@ARG      Compute remaining space to EO
[0914] 82F5 A4,5C,06        SUB  @CCPPTR,@ARG       for space checking
[0915] 82F8 90,5C           INC  @ARG              Make it real space
[0916] 82FA C8,51,5C        CHE  @ARG,@FAC7        Not enough!!!!!
[0917] 82FD 77,DD           BS   ERRFE
[0918]               * The = check includes length byte
[0919] 82FF BC,B0,08        ST   @FAC7,V*CCPADR    Prestore string length
       8302 51
[0920] 8303 91,08           DINC @CCPADR           Update actual RAM address

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0016 
FLMGR-359
[0921] 8305 90,06           INC  @CCPPTR            and internal column pointer
[0922] 8307 43,0E           BR   OTHEZ0
[0923] 8309 D6,4C,65 OTHEZ1 CEQ  STRVAL,@FAC2      Print the string result
[0924] 830C 43,13           BR   G830D
[0925] 830E 06,97,14 OTHEZ0 CALL OSTRNG            Output the string to the reco
[0926] 8311 43,2E           BR   CHKSEP
[0927] 8313 86,55    G830D  CLR  @FAC11            Select standard BASIC format
[0928] 8315 0F,73           XML  XCNS              Convert number to string
[0929] 8317 06,96,11        CALL RSTRING           Reserve and copy string
[0930] 831A 06,97,14        CALL OSTRNG            Output the string
[0931]               * Possibly add an extra space if we're not at the end of th
[0932]               * current record.
[0933] 831D C8,07,06        CHE  @CCPPTR,@RECLEN   Enough space left
[0934] 8320 43,2E           BR   CHKSEP
[0935] 8322 BE,B0,08        ST   SPACE,V*CCPADR    Add trailing space
       8325 20
[0936] 8326 A0,B0,08        ADD  @DSRFLG,V*CCPADR  Take care of screen I/O
       8329 17
[0937] 832A 91,08           DINC @CCPADR           Update current column address
[0938] 832C 90,06           INC  @CCPPTR            and base 1 pointer
[0939] 832E 06,96,2D CHKSEP CALL TSTSEP            Check for legal delimiter
[0940] 8331 41,0F           BR   ERRSYN            Illegal delimiter. SYNTAX ERR
[0941]               *                              Unconditional branch
[0942]               * PRTAB - Print TAB as part of PRINT command
[0943] 8333 06,83,CB PRTAB  CALL TSTINT            Watch out for INTERAL file ty
[0944] 8336 57,DD           BR   ERRFE             They can't handle TABs
[0945] 8338 0F,79           XML  PGMCHR            Skip TAB keyword
[0946] 833A D6,42,B7        CEQ  LPARZ,@CHAT
[0947] 833D 41,0F           BR   ERRSYN
[0948] 833F 0F,74           XML  PARSE             Parse TAB expression
[0949] 8341 B6              BYTE RPARZ
[0950] 8342 06,94,BE        CALL CNVDEF            Check and convert to integer
[0951] 8345 BC,4C,07        ST   @RECLEN,@FAC2     Set modulo number
[0952] 8348 06,96,20        CALL COMMOD            Compute remainder
[0953] 834B C4,06,4B        CH   @FAC1,@CCPPTR     Position on next output recor
[0954] 834E 43,55           BR   G834F
[0955] 8350 06,96,AB        CALL OUTREC            Output current record - no pe
[0956] 8353 63,2E           BS   CHKSEP             react on SIZE block!!!
[0957] 8355 D4,06,4B G834F  CEQ  @FAC1,@CCPPTR     Stay here
[0958] 8358 63,2E           BS   CHKSEP
[0959] 835A BC,03,4B        ST   @FAC1,@MNUM+1     Fill with spaces
[0960] 835D 0F,84           XML  IO                OK, go ahead... fill'r up
[0961] 835F 01              BYTE FILSPC
[0962] 8360 43,2E           BR   CHKSEP            And check separator again
[0963]               * Comma is similar to TAB, except that it generates at leas
[0964]               * one space. The exact number of spaces generated depends
[0965]               * upon the current position within the record. If the next
[0966]               * fixed tab-position is outside the record, the record, the
[0967]               * current record is output and the column pointer is reset
[0968]               * to column 1 of the next record.
[0969] 8362 BC,03,06 PRTCOM ST   @CCPPTR,@MNUM+1   Compute initial # of spaces
[0970] 8365 92,03           DEC  @MNUM+1           Decrecment for 0 origin
[0971] 8367 86,02           CLR  @MNUM             Clear high byte of double
[0972] 8369 AE,02,0E        DIV  14,@MNUM          TABs are 14 spaces apart
[0973] 836C 90,02           INC  @MNUM             Compute next TAB-stop
[0974] 836E AA,02,0E        MUL  14,@MNUM           and actual position
[0975] 8371 C4,07,03        CH   @MNUM+1,@RECLEN   Within this record
[0976] 8374 43,7D           BR   PRCOL
[0977] 8376 90,03           INC  @MNUM+1           Convert to real position
[0978] 8378 0F,84           XML  IO                Fill spaces to new location
[0979] 837A 01              BYTE FILSPC
[0980] 837B 43,80           BR   PRSEM             Outside current record
[0981]               * The ":" (colon) separator is used to output the current
[0982]               * record, and proceed to position 1 of the next record.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0017 
FLMGR-359
[0983] 837D 06,96,AB PRCOL  CALL OUTREC            Output the current record
[0984]               * The ";" (semi-colon) generates the null string. Since all
[0985]               * print items should be separated by a separator, this one
[0986]               * has been introduced to separate without moving to another
[0987]               * position. Notice that all separators join up here.
[0988] 8380 0F,79    PRSEM  XML  PGMCHR            Skip the separator
[0989] 8382 06,95,B3        CALL CHKEND            Exit on end of line
[0990] 8385 42,CF           BR   CONPRT            Continue if not end of line
[0991] 8387 8E,17    PRSMZ1 CZ   @DSRFLG           For screen output continue
[0992] 8389 63,AA           BS   PREXIT
[0993] 838B DA,04,08        CLOG >08,@PABPTR       Check SIZE clause
[0994] 838E 63,AA           BS   PREXIT
[0995] 8390 06,96,AB        CALL OUTREC            Output current record (blank
[0996] 8393 BC,06,09        ST   @CCPADR+1,@CCPPTR Compute correct value for CCP
[0997] 8396 A6,06,E1        SUB  >E1,@CCPPTR       Subtract current screen base
[0998] 8399 43,AA           BR   PREXIT             and exit form this command
[0999]               * End of line exit routine for PRINT statement
[1000] 839B 8E,17    EOLEX  CZ   @DSRFLG           I/O - remove blocks if
[1001] 839D 63,A7           BS   G83A1
[1002] 839F DA,04,04        CLOG >04,@PABPTR        " AT" clause unused
[1003] 83A2 43,A7           BR   G83A1
[1004] 83A4 B2,04,E7        AND  >E7,@PABPTR        remove flag 3 (SIZE used)
[1005] 83A7 06,96,AB G83A1  CALL OUTREC            Output pending record
[1006]               * Continue here if record remains pending
[1007] 83AA 8E,17    PREXIT CZ   @DSRFLG           Regular file/device I/O
[1008] 83AC 43,B7           BR   G83B1
[1009] 83AE 92,06           DEC  @CCPPTR           Back to actual offset
[1010] 83B0 BC,E0,03        ST   @CCPPTR,V@OFS(@PABPTR) Save for next statement
       83B3 04,06
[1011] 83B5 0F,75           XML  CONT              Continue with next statement
[1012]               *                              End external I/O handling
[1013]               * Reset of code is for internal I/O handling (VDP)
[1014] 83B7 DA,04,04 G83B1  CLOG >04,@PABPTR       Is not used
[1015] 83BA 43,C1           BR   G83BB
[1016] 83BC BC,7F,06        ST   @CCPPTR,@XPT      Save current value of pointer
[1017] 83BF 94,7F           INCT @XPT              CCPPTR: 1-28
[1018] 83C1 DA,04,02 G83BB  CLOG >02,@PABPTR       Used BEEP clause
[1019] 83C4 63,C9           BS   G83C3
[1020] 83C6 06,00,34        CALL TONE1             ---------- BEEP ------------
[1021] 83C9 0F,75    G83C3  XML  CONT              Continue in PARSE routine
[1022]               * TSTINT - test for INTERAL type files, set COND if file
[1023]               *          is NOT INTERNAL
[1024] 83CB 8E,17    TSTINT CZ   @DSRFLG           Couldn't possibly be INTERNAL
[1025] 83CD 53,92           BR   RTC
[1026] 83CF DA,E0,05        CLOG >08,V@FLG(@PABPTR) Set COND according to bit 3
       83D2 04,08
[1027] 83D4 01              RTNC                   Return without changing COND
[1028]               ********* PRINT / DISPLAY USING SECTION *******************
[1029]               * Arrive here after the keyword "USING" has been rejected.
[1030] 83D5 0F,7E    USING  XML  SPEED
[1031] 83D7 00              BYTE SYNCHK          * Get first character of format
[1032] 83D8 ED              BYTE USINGZ          *  after (double) checking USIN
[1033] 83D9 D6,42,C9        CEQ  LNZ,@CHAT         Pick up the line number
[1034] 83DC 44,36           BR   G8430
[1035] 83DE 0F,79           XML  PGMCHR            Get high address
[1036] 83E0 BC,4A,42        ST   @CHAT,@FAC
[1037] 83E3 0F,79           XML  PGMCHR             and low address
[1038] 83E5 BC,4B,42        ST   @CHAT,@FAC1
[1039] 83E8 0F,79           XML  PGMCHR              get next program character
[1040] 83EA BD,4C,2E        DST  @EXTRAM,@FAC2        in SEETWO : EXTRAM value w
[1041]               *                                 changed
[1042] 83ED 0F,7E           XML  SPEED
[1043] 83EF 03              BYTE SEETWO          *  Find the line # in the progr
[1044] 83F0 C1,4C,2E        DEX  @EXTRAM,@FAC2      result in SEETWO is in EXTRA

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0018 
FLMGR-359
[1045]               *                               and restore EXTRAM value
[1046] 83F3 44,64           BR   USNGZ1               has to match exactly
[1047] 83F5 95,4C           DINCT @FAC2            Move up to the pointer field
[1048] 83F7 BD,52,34        DST   @DATA,@FAC8      Save DATA pointer for READ fi
[1049] 83FA 06,91,AA        CALL GRSUB2            Read 2 bytes of data from ERA
[1050] 83FD 4C              BYTE FAC2           *  @FAC2 : Source address on ERA
[1051] 83FE BD,34,58        DST  @EEE1,@DATA       @EEE1 : Destination addr. on
[1052]               *                              Put it in @DATA
[1053] 8401 BE,4C,A3        ST   IMAGEZ,@FAC2      Search for an IMAGE token
[1054] 8404 06,8B,9F        CALL SEARCH             at beginning of an statement
[1055] 8407 64,64           BS   USNGZ1            Error if not found on this li
[1056] 8409 06,93,0A        CALL GETGFL            Get first part of format stri
[1057] 840C 06,93,29        CALL CHKSTR            Prepare data for string assig
[1058] 840F BD,0C,50        DST  @FAC6,@BYTES      Copy actual string length in
[1059] 8412 BD,34,52        DST  @FAC8,@DATA       Restore original DATA pointer
[1060] 8415 06,92,D3        CALL CTSTR             Create a temporary string
[1061] 8418 8F,50           DCZ  @FAC6
[1062] 841A 64,34           BS   G842E
[1063] 841C 8E,80,84        CZ   @RAMTOP           Data from RAM
[1064] 841F 44,29           BR   G8423
[1065] 8421 34,50,B0        MOVE @FAC6,V*TEMP5,V*SREF
       8424 1C,B0,66
[1066] 8427 44,34           BR   G842E
[1067] 8429 BD,56,50 G8423  DST  @FAC6,@FFF1       FFF1 : byte count
[1068] 842C BD,54,66        DST  @TEMP5,@DDD1      DDD1 : source address in ERAM
[1069] 842F BD,58,1C        DST  @SREF,@EEE1       EEE1 : destination address on
[1070] 8432 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[1071] 8434 44,3E    G842E  BR   G8438
[1072] 8436 0F,74    G8430  XML  PARSE             Parse up to the ending ":"
[1073] 8438 B5              BYTE COLONZ
[1074] 8439 D6,4C,65        CEQ  STRVAL,@FAC2      * IMAGE ERROR *
[1075] 843C 44,64           BR   USNGZ1
[1076] 843E D6,42,B5 G8438  CEQ  COLONZ,@CHAT      Probably no variable list
[1077] 8441 64,4E           BS   G8448
[1078] 8443 06,95,B3        CALL CHKEND            We better check that through
[1079] 8446 41,0F           BR   ERRSYN             something sneaky sneaked in
[1080] 8448 8E,51           CZ   @FAC7             End of line exit
[1081] 844A 63,9B           BS   EOLEX
[1082] 844C 44,69           BR   G8463             Look for format item
[1083] 844E 8E,51    G8448  CZ   @FAC7             Exclude null strings
[1084] 8450 64,64           BS   USNGZ1
[1085] 8452 BD,5C,4E        DST  @FAC4,@ARG        Get start address for string
[1086] 8455 BC,5E,51        ST   @FAC7,@ARG2       Get format string length
[1087] 8458 D6,B0,5C USNGZ0 CEQ  >23,V*ARG         Found no format item yet
       845B 23
[1088] 845C 64,66           BS   G8460
[1089] 845E 91,5C           DINC @ARG              Try next address
[1090] 8460 92,5E           DEC  @ARG2             Update address
[1091] 8462 44,58           BR   USNGZ0            Try up to the end of the stri
[1092] 8464 57,C9    USNGZ1 BR   ERRIM             * IMAGE ERROR
[1093]               * Now we're sure that we have at least one legal format ite
[1094]               * (anything with a "#" in it)
[1095] 8466 BE,42,B3 G8460  ST   COMMAZ,@CHAT      Fake comma seperator for prin
[1096] 8469 0F,77    G8463  XML  VPUSH             Current string might be tempo
[1097] 846B BD,0C,50        DST  @FAC6,@BYTES      Create a workstring for outpu
[1098] 846E 90,0D           INC  @BYTES+1          Create space for end of strin
[1099] 8470 0C              CARRY                  String would be too long
[1100] 8471 64,64           BS   USNGZ1
[1101] 8473 0F,71           XML  GETSTR            Length whold equal format str
[1102] 8475 BD,14,1C        DST  @SREF,@CURLIN     Create a temporary string
[1103] 8478 A1,1C,50        DADD @FAC6,@SREF       Compute last position in stri
[1104] 847B 86,B0,1C        CLR  V*SREF            Set end of string indicator
[1105] 847E BD,4E,E0 USNGZ3 DST  V@4(@VSPTR),@FAC4 Update FAC4 area in case garb
       8481 04,6E

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0019 
FLMGR-359
[1106] 8483 34,50,B0        MOVE @FAC6,V*FAC4,V*CURLIN Copy format
       8486 14,B0,4E
[1107] 8489 BD,4E,14        DST  @CURLIN,@FAC4     Complete preps for VPUSH
[1108] 848C BF,4A,00        DST  >001C,@FAC        SREF = >001C
       848F 1C
[1109] 8490 91,50           DINC @FAC6             Include 0 in string length
[1110] 8492 0F,77           XML  VPUSH             Make the string temporary
[1111] 8494 BD,14,E0        DST  V@4(@VSPTR),@CURLIN Update current line pointer
       8497 04,6E
[1112] 8499 D6,B0,14 USNGZ4 CEQ  >23,V*CURLIN      Try to locate the next format
       849C 23
[1113] 849D 64,C9           BS   G84C3
[1114] 849F 8E,B0,14        CZ   V*CURLIN          Not end of string yet
[1115] 84A2 64,A8           BS   G84A2
[1116] 84A4 91,14           DINC @CURLIN           Update pointer if not found
[1117] 84A6 44,99           BR   USNGZ4             and continue searching
[1118] 84A8 D6,42,B3 G84A2  CEQ  COMMAZ,@CHAT      Stop on last variable
[1119] 84AB 45,C9           BR   USNGZ9
[1120] 84AD 0F,78           XML  VPOP              Restore original workstring d
[1121] 84AF BC,0C,51        ST   @FAC7,@BYTES      Pring the current format stri
[1122] 84B2 92,0C           DEC  @BYTES            Don't count the last "0"
[1123] 84B4 BE,03,01        ST   1,@MNUM+1         Indicate direct output withou
[1124] 84B7 06,97,1E        CALL CHKRZ0            Copy string to output record
[1125] 84BA 06,96,AB        CALL OUTREC            Also output current record
[1126]               * FAC still contains the right data, however it is easier j
[1127]               * to copy the original string again.
[1128] 84BD BD,14,4E        DST  @FAC4,@CURLIN     Reconstruct CRULIN
[1129] 84C0 0F,78           XML  VPOP              Copy original string info
[1130] 84C2 0F,77           XML  VPUSH             Without actually removing it
[1131] 84C4 A5,14,50        DSUB @FAC6,@CURLIN     Reconstruct start address
[1132] 84C7 44,7E           BR   USNGZ3            Continue for the next variabl
[1133] 84C9 D5,14,E0 G84C3  DCEQ V@4(@VSPTR),@CURLIN Avoid "#" as count
       84CC 04,6E
[1134] 84CE 64,EF           BS   USNZ42
[1135] 84D0 93,14           DDEC @CURLIN           Backup to the sign
[1136] 84D2 D6,B0,14        CEQ  >2E,V*CURLIN      Used ".#####"
       84D5 2E
[1137] 84D6 44,E1           BR   G84DB
[1138] 84D8 D5,14,E0        DCEQ V@4(@VSPTR),@CURLIN
       84DB 04,6E
[1139] 84DD 64,EF           BS   USNZ42
[1140] 84DF 93,14           DDEC @CURLIN           Avoid checking count bit
[1141] 84E1 D6,B0,14 G84DB  CEQ  >2D,V*CURLIN      Check for minus
       84E4 2D
[1142] 84E5 64,EF           BS   USNZ42
[1143] 84E7 D6,B0,14        CEQ  >2B,V*CURLIN      Check for plus
       84EA 2B
[1144] 84EB 64,EF           BS   USNZ42
[1145] 84ED 91,14           DINC @CURLIN           It's neither, so we undo
[1146]               * Check for availability of variables
[1147] 84EF D6,42,B3 USNZ42 CEQ  COMMAZ,@CHAT      Exit if no more pt item
[1148] 84F2 45,C9           BR   USNGZ9
[1149] 84F4 0F,79           XML  PGMCHR            Get next expression
[1150] 84F6 A5,14,E0        DSUB V@4(@VSPTR),@CURLIN Make CURLIN offset for
       84F9 04,6E
[1151]               *                                garbage collection
[1152] 84FB 0F,74           XML  PARSE             Parse up to ";" or ","
[1153] 84FD B4              BYTE SEMICZ
[1154] 84FE A1,14,E0        DADD V@4(@VSPTR),@CURLIN Reconstruct new CLN after
       8501 04,6E
[1155]               *                                garbage collection
[1156] 8503 87,52           DCLR @FAC8             Start with clean sheet for co
[1157] 8505 87,55           DCLR @FAC11
[1158] 8507 86,57           CLR  @FAC13

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0020 
FLMGR-359
[1159] 8509 BD,0E,14        DST  @CURLIN,@VAR4     Now start checking process
[1160] 850C D6,B0,14        CEQ  >2E,V*CURLIN
       850F 2E
[1161] 8510 65,39           BS   USNGZ5
[1162] 8512 D6,B0,14        CEQ  >23,V*CURLIN      Has to be "+" or "-"
       8515 23
[1163] 8516 65,2D           BS   G8527
[1164] 8518 D6,B0,14        CEQ  >2D,V*CURLIN
       851B 2D
[1165] 851C 45,21           BR   G851B
[1166] 851E B6,55,02        OR   >02,@FAC11        Set explict sign flag for CNS
[1167] 8521 D6,B0,14 G851B  CEQ  >2B,V*CURLIN
       8524 2B
[1168] 8525 45,2D           BR   G8527
[1169] 8527 B6,55,02        OR   >02,@FAC11        Set explict sign flag for CNS
[1170] 852A B6,55,04        OR   >04,@FAC11        Set positive sign flag for CN
[1171] 852D 06,85,EB G8527  CALL ACCNM             Accept first character plus "
[1172] 8530 BC,56,53        ST   @FAC9,@FAC12      Set up FAC12 for CNS
[1173] 8533 D6,B0,0E        CEQ  >2E,V*VAR4        Found decimal point
       8536 2E
[1174] 8537 45,46           BR   G8540
[1175] 8539 86,53    USNGZ5 CLR  @FAC9             Prepare for use as counter of
[1176]               *                              of # sign after decimal poin
[1177] 853B 06,85,EB        CALL ACCNM             Accept some more "#"'s
[1178] 853E BC,57,53        ST   @FAC9,@FAC13      Set up FAC13 for CNS
[1179] 8541 A0,53,56        ADD  @FAC12,@FAC9      FAC9 now contains the total n
[1180]               *                              of "#" sign, decimal point a
[1181]               *                              maybe a sign bit
[1182] 8544 92,53           DEC  @FAC9             Exclude the decimal point
[1183] 8546 D7,B0,0E G8540  DCEQ >5E5E,V*VAR4      Attempt to decode  ^^
       8549 5E,5E
[1184] 854B 45,6A           BR   USNZ55
[1185] 854D 95,0E           DINCT @VAR4            Update address
[1186] 854F D7,B0,0E        DCEQ  >5E5E,V*VAR4
       8552 5E,5E
[1187] 8554 45,68           BR   G8562
[1188] 8556 95,0E           DINCT @VAR4            Update address
[1189] 8558 B6,55,08        OR   >08,@FAC11        Set E-format bit for CNS
[1190] 855B D6,B0,0E        CEQ  >5E,V*VAR4
       855E 5E
[1191] 855F 45,6A           BR   USNZ55
[1192] 8561 91,0E           DINC @VAR4             Update end address
[1193] 8563 B6,55,10        OR   >10,@FAC11        Set extended E-format bit for
[1194] 8566 45,6A           BR   USNZ55
[1195] 8568 97,0E    G8562  DDECT @VAR4            Correct for previous errors
[1196]               * At this point, CURLIN is pointing at the first item of th
[1197]               * format, VAR4 is pointing at the character following the i
[1198] 856A CA,4C,64 USNZ55 CHE  >64,@FAC2         Detected numerical argument
[1199] 856D 65,9C           BS   G8596
[1200] 856F DA,55,02        CLOG >02,@FAC11        Exclude the sign count
[1201] 8572 65,76           BS   G8570
[1202] 8574 92,53           DEC  @FAC9             FAC9 : Number of significant
[1203] 8576 DA,55,08 G8570  CLOG >08,@FAC11        If E-format is used
[1204] 8579 65,82           BS   G857C
[1205] 857B CE,53,0A        CGT  >0A,@FAC9         More than 10 significant digi
[1206] 857E 77,C9           BS   ERRIM
[1207] 8580 45,87           BR   G8581
[1208] 8582 CE,53,0E G857C  CGT  14,@FAC9          More than 14 significant digi
[1209] 8585 77,C9           BS   ERRIM
[1210] 8587 B6,55,01 G8581  OR   >01,@FAC11        Set fixed format output it fo
[1211] 858A 0F,73           XML  XCNS    1          Convert number to fixed form
[1212]               * FAC11 points to the beginning of the string after supress
[1213]               * leading 0's, FAC12 contains the length of the string
[1214] 858C BC,57,55        ST   @FAC11,@FAC13     FAC13 now point to beginning

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0021 
FLMGR-359
[1215]               *                              the string
[1216] 858F 86,55           CLR  @FAC11            Clear high byte
[1217] 8591 34,55,B0        MOVE @FAC11,*FAC13,V*CURLIN Copy the result string f
       8594 14,90,57
[1218]               *                                   temporary
[1219] 8597 BD,14,0E        DST  @VAR4,@CURLIN     Move pointer behind print fie
[1220] 859A 44,99           BR   USNGZ4            Continue after printing
[1221] 859C BD,54,0E G8596  DST  @VAR4,@FAC10      Compute total length
[1222] 859F A5,54,14        DSUB @CURLIN,@FAC10
[1223] 85A2 C4,51,55        CH   @FAC11,@FAC7      String exceeds limits
[1224] 85A5 45,B7           BR   G85B1
[1225] 85A7 BE,00,2A        ST   >2A,@VAR0         Prepare a "*****.." string
[1226] 85AA BC,B0,14 G85A4  ST   @VAR0,V*CURLIN    Fill the remainder of field
       85AD 00
[1227] 85AE 91,14           DINC @CURLIN           Up to the end
[1228] 85B0 D5,14,0E USNZ67 DCEQ @VAR4,@CURLIN     Which is stored in VAR4
[1229] 85B3 45,AA           BR   G85A4
[1230] 85B5 44,99           BR   USNGZ4
[1231] 85B7 8F,50    G85B1  DCZ  @FAC6
[1232] 85B9 65,C4           BS   USNZ68
[1233] 85BB 34,50,B0        MOVE @FAC6,V*FAC4,V*CURLIN Copy result string
       85BE 14,B0,4E
[1234] 85C1 A1,14,50        DADD @FAC6,@CURLIN     And update address in string
[1235] 85C4 BE,00,20 USNZ68 ST   SPACE,@VAR0       Fill remainder with spaces
[1236] 85C7 45,B0           BR   USNZ67
[1237] 85C9 0F,78    USNGZ9 XML  VPOP              Temporary string back out
[1238] 85CB BC,0C,15        ST   @CURLIN+1,@BYTES  Output up to the current
[1239]               *                              position
[1240] 85CE A4,0C,4F        SUB  @FAC5,@BYTES      Create one byte result
[1241] 85D1 65,D9           BS   USNZ95            Avoid empty strings
[1242] 85D3 BE,03,01        ST   1,@MNUM+1         Prevent skip if field too sma
[1243] 85D6 06,97,1E        CALL CHKRZ0            Preform all nomal I/O stuff
[1244] 85D9 0F,78    USNZ95 XML  VPOP              Remove source format string
[1245] 85DB 06,95,B3        CALL CHKEND            Check for end of line exit
[1246] 85DE 63,9B           BS   EOLEX             Take end of line exit
[1247] 85E0 0F,7E           XML  SPEED
[1248] 85E2 00              BYTE SYNCHK          * Then it HAS to be a ";"
[1249] 85E3 B4              BYTE SEMICZ
[1250] 85E4 06,95,B3        CALL CHKEND            Now - must be EOS
[1251] 85E7 63,87           BS   PRSMZ1            Supressed end of record, make
[1252]               *                              it a pending record
[1253] 85E9 41,0F           BR   ERRSYN            SYNTAX ERROR
[1254]               * Collect string of "#"'s
[1255] 85EB 90,53    ACCNM  INC  @FAC9             Update item count
[1256] 85ED 91,0E           DINC @VAR4              and item address
[1257] 85EF D6,B0,0E        CEQ  >23,V*VAR4        Decode as many "#"'s as
       85F2 23
[1258]               *                              possible
[1259] 85F3 65,EB           BS   ACCNM
[1260] 85F5 00              RTN                    Return from duty
[1261]               ***********************************************************
[1262]               *                    INPUT ROUTINE
[1263]               * First check for file or screen I/O. If file I/O then chec
[1264]               * for pending output and print that. If screen I/O then
[1265]               * check for input prompt:
[1266]               * Next collect the INPUT variable list on the V-stack. Get
[1267]               * enough input form either file or keyboard, and compare
[1268]               * types with entries on V-stack. After verification and
[1269]               * approval, assign the values.
[1270]               ***********************************************************
[1271] 85F6 06,97,45 INPUT  CALL INITKB            Assume keyboard INPUT
[1272] 85F9 D6,42,FD        CEQ  NUMBEZ,@CHAT      Might be #0 or #1-255
[1273] 85FC 47,60           BR   G875A
[1274] 85FE 06,93,5B        CALL CHKFN             Check for default #0

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0022 
FLMGR-359
[1275] 8601 8F,4A           DCZ  @FAC              If luno #0
[1276] 8603 46,11           BR   G860B
[1277] 8605 BD,A3,AA        DST  @PGMPTR,V@INPUTP  Save PGMPTR for "try again"
       8608 2C
[1278] 8609 91,A3,AA        DINC V@INPUTP          Pass the ":" for the
[1279]               *                              "prompt" code handler
[1280]               *                              later, (using #0 will not
[1281]               *                              take care the prompt in
[1282]               *                              INPUT)
[1283] 860C 06,89,33        CALL INPUZ2            #0 is equivalent to no #
[1284] 860F 47,6E           BR   INPZ2
[1285] 8611 06,88,EE G860B  CALL INSU1             Get info about file
[1286]               * INTERNAL files get special treatment
[1287] 8614 DA,E0,05        CLOG >08,V@FLG(@PABPTR) INTERNAL file
       8617 04,08
[1288] 8619 66,B3           BS   G86AD
[1289] 861B 8E,E0,03        CZ   V@OFS(@PABPTR)    Fresh start
       861E 04
[1290] 861F 46,24           BR   G861E
[1291] 8621 06,97,6B INTRZ0 CALL IOCLZ1            Get a new record through
[1292]               *                              the DSR
[1293] 8624 BC,2B,E0 G861E  ST   V@OFS(@PABPTR),@VARA+1 Regain possible offset
       8627 03,04
[1294] 8629 86,2A           CLR  @VARA             Make that a two byte constant
[1295] 862B BD,66,E0        DST  V@BUF(@PABPTR),@TEMP5 Get first address
       862E 06,04
[1296] 8630 A1,66,2A        DADD @VARA,@TEMP5      Compute actual address
[1297]               *                              within record
[1298] 8633 06,97,E9 INTRZ1 CALL BUG01             Get the symbol table entry
[1299]               * Above call fixes bug, of the given variable
[1300] 8636 0F,77           XML  VPUSH             And save it on the stack
[1301] 8638 87,0C           DCLR @BYTES            Assume no data available
[1302] 863A C8,2B,E0        CHE  V@CNT(@PABPTR),@VARA+1 Pick up data
       863D 09,04
[1303] 863F 66,49           BS   G8643
[1304] 8641 BC,0D,B0        ST   V*TEMP5,@BYTES+1  Length byte first
       8644 66
[1305] 8645 91,66           DINC @TEMP5            Update both actual address
[1306] 8647 90,2B           INC  @VARA+1            and offset
[1307] 8649 D6,4C,65 G8643  CEQ  >65,@FAC2         Has to be string variable
[1308] 864C 46,56           BR   G8650
[1309] 864E BD,50,0C        DST  @BYTES,@FAC6      Set length of string
[1310] 8651 06,92,E4        CALL CTMPST            Create temporary string
[1311] 8654 46,84           BR   G867E
[1312] 8656 D6,0D,08 G8650  CEQ  >08,@BYTES+1      * FILE ERROR
[1313] 8659 57,DD           BR   ERRFE
[1314] 865B 34,0C,4A        MOVE @BYTES,V*TEMP5,@FAC  Copy value
       865E B0,66
[1315] 8660 8F,4A           DCZ  @FAC              Watch out for non-scaled stuf
[1316] 8662 66,82           BS   G867C
[1317] 8664 BE,5C,51        ST   FAC7,@ARG         Test for legal numeric
[1318] 8667 C6,90,5C G8661  CH   99,*ARG           * FILE ERROR
       866A 63
[1319] 866B 77,DD           BS   ERRFE
[1320] 866D 92,5C           DEC  @ARG              Next digit for test
[1321] 866F D6,5C,4B        CEQ  FAC1,@ARG
[1322] 8672 46,67           BR   G8661
[1323] 8674 BD,5C,4A        DST  @FAC,@ARG         Copy in ARG for some testing
[1324] 8677 81,5C           DABS @ARG              Be sure we're positive
[1325]               * If first byte after expon. byte=0 : incorrect
[1326]               * normalization has occured : FILE ERROR
[1327]               * Or >99 : illegal numeric  : FILE ERROR
[1328] 8679 92,5D           DEC  @ARG1             0 would cause underflow here
[1329] 867B C6,5D,62        CH   98,@ARG1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0023 
FLMGR-359
[1330] 867E 77,DD           BS   ERRFE
[1331] 8680 46,84           BR   G867E
[1332] 8682 87,4C    G867C  DCLR @FAC2             Be sure FAC2 = 0 (no strings)
[1333] 8684 A1,66,0C G867E  DADD @BYTES,@TEMP5     Update address and
[1334] 8687 A0,2B,0D        ADD  @BYTES+1,@VARA+1   offset again
[1335] 868A 0F,7C           XML  ASSGNV            Assign value to variable
[1336] 868C 86,E0,03        CLR  V@OFS(@PABPTR)    Undo allocated offsets
       868F 04
[1337] 8690 D6,42,B3        CEQ  COMMAZ,@CHAT
[1338] 8693 46,B1           BR   G86AB
[1339] 8695 0F,79           XML  PGMCHR            Get next text character
[1340] 8697 06,95,B3        CALL CHKEND            Check for end of statement
[1341] 869A 66,A5           BS   INTRZ2            OK, EOS is fine
[1342] 869C C8,2B,E0        CHE  V@CNT(@PABPTR),@VARA+1
       869F 09,04
[1343] 86A1 66,21           BS   INTRZ0
[1344] 86A3 46,33           BR   INTRZ1            Still something left
[1345] 86A5 C8,2B,E0 INTRZ2 CHE  V@CNT(@PABPTR),@VARA+1
       86A8 09,04
[1346] 86AA 66,B1           BS   G86AB
[1347] 86AC BC,E0,03        ST   @VARA+1,V@OFS(@PABPTR) Save value of offset
       86AF 04,2B
[1348] 86B1 0F,75    G86AB  XML  CONT              And CONTINUE
[1349] 86B3 06,92,90 G86AD  CALL GETVAR            Collect variable list on stac
[1350] 86B6 BD,14,0A        DST  @STADDR,@CURLIN   Save it in temp
[1351] 86B9 BF,0A,08        DST  CRNBUF,@RAMPTR    Initialize crunch buffer poin
       86BC 20
[1352] 86BD 86,07           CLR  @RECLEN           Initialize field counter
[1353] 86BF BE,E0,04        ST   CZREAD,V@COD(@PABPTR) Select READ operation
       86C2 04,02
[1354] 86C4 8E,E0,03        CZ   V@OFS(@PABPTR)
       86C7 04
[1355] 86C8 46,EF           BR   INPZ31
[1356] 86CA 46,D2           BR   INPZ3             Adjust for used record usage
[1357] 86CC BE,EF,FF G86C6  ST   COMMAZ,V@-1(@RAMPTR) Fake legal separator
       86CF FF,0A,B3
[1358] 86D2 06,97,6B INPZ3  CALL IOCLZ1            Get next input record
[1359] 86D5 86,E0,03        CLR  V@OFS(@PABPTR)    Reset offset within record
       86D8 04
[1360] 86D9 06,88,2D        CALL RECENT
[1361] 86DC BC,2A,E0        ST   V@CNT(@PABPTR),@VARA Get record length
       86DF 09,04
[1362] 86E1 8E,2A    G86DB  CZ   @VARA
[1363] 86E3 66,EF           BS   INPZ31
[1364] 86E5 A2,B0,20        ADD  OFFSET,V*VARW     Add video offset for normal
       86E8 60
[1365] 86E9 91,20           DINC @VARW             Screen-type crunch - proceed
[1366] 86EB 92,2A           DEC  @VARA              for entire record
[1367] 86ED 46,E1           BR   G86DB
[1368] 86EF 06,88,2D INPZ31 CALL RECENT            Compute actual record entry
[1369] 86F2 BC,2B,E0        ST   V@CNT(@PABPTR),@VARA+1  Compute end of record
       86F5 09,04
[1370] 86F7 86,2A           CLR  @VARA             Make that a double byte
[1371] 86F9 A1,2A,E0        DADD V@BUF(@PABPTR),@VARA  Add buffer start addr
       86FC 06,04
[1372] 86FE 93,2A           DDEC @VARA             Point to last position in rec
[1373] 8700 86,11           CLR  @VAR6             Assume no values input
[1374] 8702 0F,7F           XML  CRUNCH            Scan data fields as in DATA s
[1375] 8704 01              BYTE 1               * Indicate input stmt crunch
[1376] 8705 8F,22           DCZ  @ERRCOD           If some crunch error
[1377] 8707 57,D5           BR   ERRINP
[1378] 8709 90,11           INC  @VAR6             Get correct # of fields (one
[1379] 870B A0,07,11        ADD  @VAR6,@RECLEN     Update # of fields up to now
[1380] 870E C8,07,10        CHE  @VAR5,@RECLEN     OK, THAT'S ENOUGH!!!!

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0024 
FLMGR-359
[1381] 8711 46,CC           BR   G86C6
[1382] 8713 97,2C           DDECT @PGMPTR          Backup program pointer
[1383] 8715 0F,79           XML  PGMCHR            Re-inspect last token before
[1384] 8717 06,88,2D        CALL RECENT            Precompute record entry
[1385] 871A 86,E0,03        CLR  V@OFS(@PABPTR)    Assume no pending record
       871D 04
[1386] 871E D6,42,B3        CEQ  COMMAZ,@CHAT      Make record pending
[1387] 8721 47,58           BR   G8752
[1388] 8723 D4,07,10        CEQ  @VAR5,@RECLEN     Enough left pending
[1389] 8726 67,58           BS   G8752
[1390] 8728 A4,07,10        SUB  @VAR5,@RECLEN     Compute remaining # of fields
[1391] 872B A4,11,07        SUB  @RECLEN,@VAR6     # of fields used in last reco
[1392] 872E D6,B0,20 INPZ32 CEQ  >82,V*VARW        +OFFSET
       8731 82
[1393] 8732 47,40           BR   G873A             Skip quoted strings
[1394] 8734 91,20    G872E  DINC @VARW
[1395] 8736 D6,B0,20        CEQ  >82,V*VARW        +OFFSET
       8739 82
[1396] 873A 47,34           BR   G872E
[1397] 873C 91,20           DINC @VARW
[1398] 873E 47,2E           BR   INPZ32            Search for Nth data item
[1399] 8740 91,20    G873A  DINC @VARW             Update pointer
[1400] 8742 D6,EF,FF        CEQ  >8C,V@-1(@VARW) * ","+OFFSET = >8C
       8745 FF,20,8C
[1401] 8748 47,40           BR   G873A
[1402] 874A 92,11           DEC  @VAR6             Commas denote end of field
[1403] 874C 47,2E           BR   INPZ32            Continue until done
[1404] 874E A5,20,E0        DSUB V@BUF(@PABPTR),@VARW Compute current offset
       8751 06,04
[1405] 8753 BC,E0,03        ST   @VARW+1,V@OFS(@PABPTR) Store for next round
       8756 04,21
[1406] 8758 BC,11,10 G8752  ST   @VAR5,@VAR6       Copy # of variables for check
[1407] 875B BD,0A,14        DST  @CURLIN,@STADDR   Restore from temp
[1408] 875E 47,8C           BR   G8786
[1409] 8760 06,97,45 G875A  CALL INITKB            Initialize some variables for
[1410] 8763 BD,A3,AA        DST  @PGMPTR,V@INPUTP  Save for "try agian" case
       8766 2C
[1411] 8767 BD,A3,BC        DST  @CCPPTR,V@CPTEMP  Save CCPPTR, RECLEN for "try
       876A 06
[1412]               *                         Entry point for "try again" case
[1413] 876B 06,89,0C INPZ33 CALL INSUB1            Put out prompt
[1414] 876E 06,92,90 INPZ2  CALL GETVAR            Get variable list on V-stack
[1415] 8771 06,89,41 INPUZ3 CALL INSUB2            Read from the screen
[1416] 8774 86,11           CLR  @VAR6             Assume no values input
[1417] 8776 0F,7F           XML  CRUNCH            Crunch the input line
[1418] 8778 01              BYTE 1               * Indicate input stmt scan
[1419] 8779 BD,0A,14        DST  @CURLIN,@STADDR   Restore from temp
[1420] 877C 8F,22           DCZ  @ERRCOD           If got some crunch error
[1421] 877E 47,C1           BR   WRNINP
[1422] 8780 0F,83           XML  SCROLL            Scroll up after crunching
[1423] 8782 BE,7F,03        ST   3,@XPT            Reset XPT too - pending recor
[1424] 8785 90,11           INC  @VAR6             # fields = # of commas + 1
[1425] 8787 D4,10,11        CEQ  @VAR6,@VAR5       # of variables wrong
[1426] 878A 47,C1           BR   WRNINP
[1427]               * Once we're here, all information should be availiable
[1428]               * After type verification for input and variables, push
[1429]               * all value entries on the V-stack.
[1430]               * VAR6 = VAR5 = number of variables
[1431] 878C BD,14,34 G8786  DST  @DATA,@CURLIN     Save current DATA pointer
[1432] 878F BF,34,08        DST  CRNBUF,@DATA      Get crunch entry
       8792 20
[1433] 8793 BD,02,0E        DST  @VAR4,@MNUM       Get entry in V-stack before P
[1434] 8796 A3,02,00 INPUZ4 DADD 8,@MNUM           Point to first symbol table e
       8799 08

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0025 
FLMGR-359
[1435] 879A BD,06,B0        DST  V*MNUM,@CCPPTR    Get immedediate result
       879D 02
[1436] 879E 06,93,12        CALL GETRAM            Get value descriptor from RAM
[1437] 87A1 DA,B0,06        CLOG >80,V*CCPPTR      Numerical value
       87A4 80
[1438] 87A5 47,D5           BR   G87CF
[1439] 87A7 06,92,F2        CALL CHKNUM            Check entered value against n
[1440] 87AA 47,BA           BR   INPUZ5            Found error
[1441] 87AC 8E,17           CZ   @DSRFLG           Do not check overflow in file
[1442]               *                              supply machine infinity with
[1443]               *                              appropriate sign and continu
[1444] 87AE 67,DA           BS   INPUZ6
[1445] 87B0 8E,A3,BA        CZ   V@CSNTP1          Watch out for overflow in scr
[1446] 87B3 67,DA           BS   INPUZ6
[1447] 87B5 BD,34,14        DST  @CURLIN,@DATA     Restore DATA pointer
[1448] 87B8 47,C5           BR   WRZZ5             Ask for input re-enter
[1449] 87BA 8E,17    INPUZ5 CZ   @DSRFLG           FILE I/O IS FATAL
[1450] 87BC 77,D5           BS   ERRINP
[1451] 87BE BD,34,14        DST  @CURLIN,@DATA     Restore DATA pointer on error
[1452] 87C1 06,6A,82 WRNINP CALL WARNZZ            Go here for simple warnings t
[1453] 87C4 20              BYTE 32              * INPUT ERROR - TRY AGAIN
[1454] 87C5 06,88,40 WRZZ5  CALL SCRZ              Scroll the screen and reset C
[1455] 87C8 BD,2C,A3        DST  V@INPUTP,@PGMPTR  Restore ptr to "prompt" if an
       87CB AA
[1456] 87CC BD,06,A3        DST  V@CPTEMP,@CCPPTR  Restore CCPPTR, RECLEN, for t
       87CF BC
[1457] 87D0 BD,6E,0E        DST  @VAR4,@VSPTR      Restore original stack ptr
[1458] 87D3 47,6B           BR   INPZ33
[1459] 87D5 06,93,29 G87CF  CALL CHKSTR            Check string input
[1460] 87D8 67,BA           BS   INPUZ5            ERROR ... CHECK I/O TYPE
[1461] 87DA 06,93,12 INPUZ6 CALL GETRAM            Get separation character (RAM
[1462] 87DD D6,01,B3        CEQ  COMMAZ,@VAR0+1
[1463] 87E0 67,EC           BS   G87E6
[1464] 87E2 92,11           DEC  @VAR6             Has to be end of data
[1465] 87E4 47,BA           BR   INPUZ5            If not ... ERROR
[1466] 87E6 8E,01           CZ   @VAR0+1
[1467] 87E8 47,BA           BR   INPUZ5
[1468] 87EA 47,F0           BR   G87EA
[1469] 87EC 92,11    G87E6  DEC  @VAR6             Count number of value entries
[1470] 87EE 47,96           BR   INPUZ4            Continue
[1471]               * Assign cycle - assign values to variables because it resc
[1472]               * the program line, this code can not be udes for inperativ
[1473]               * statements , since the crunch buffer get's destroyed on
[1474]               * input. The rescan is necessary because subscripts should
[1475]               * evaluated AFTER all previous values have been assigned. i
[1476]               *        INPUT I,A(I)      with values 2,3
[1477]               * Should assign value 3 to A(2) !!!!!!!!!
[1478]               * No error-checking is done here, since types are already
[1479]               * validated. We might get subscripts out of range though!!!
[1480] 87F0 BF,34,08 G87EA  DST  CRNBUF,@DATA      Prepare for input rescan
       87F3 20
[1481] 87F4 BD,2C,0A        DST  @STADDR,@PGMPTR   Restore token pointer for res
[1482] 87F7 93,2C           DDEC @PGMPTR           Backup on token
[1483] 87F9 BD,6E,0E        DST  @VAR4,@VSPTR      Restore original stack pointe
[1484] 87FC 0F,79    INPZ65 XML  PGMCHR            Get next program characters
[1485] 87FE 06,95,B3        CALL CHKEND            Might have , before EOS
[1486] 8801 68,28           BS   INPUZ7
[1487] 8803 06,97,E9        CALL BUG01             Rescan variable name
[1488]               * Above call fixes bug.       Get correct entry for arrays
[1489] 8806 0F,77           XML  VPUSH             Save on stack for ASSGNV
[1490] 8808 06,93,12        CALL GETRAM            Get first token of input valu
[1491] 880B D6,4C,65        CEQ  STRVAL,@FAC2      Numerical case
[1492] 880E 68,15           BS   G880F
[1493] 8810 06,92,F2        CALL CHKNUM            Check for numerical value

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0026 
FLMGR-359
[1494] 8813 68,1E           BS   INPZ67            COND should be set (valid num
[1495] 8815 06,93,29 G880F  CALL CHKSTR            Get the correct string value
[1496] 8818 BD,0C,50        DST  @FAC6,@BYTES      Length for temporary string
[1497] 881B 06,92,E4        CALL CTMPST            Create temporary string
[1498] 881E 0F,7C    INPZ67 XML  ASSGNV            Assign value to variable
[1499] 8820 06,93,12        CALL GETRAM            Skip separator (already check
[1500] 8823 06,95,B3        CALL CHKEND            Check for end to statement
[1501] 8826 47,FC           BR   INPZ65            Found it
[1502] 8828 BD,34,14 INPUZ7 DST  @CURLIN,@DATA     Restore DATA pointer
[1503] 882B 0F,75           XML  CONT              Contiue in PARSE
[1504] 882D BC,21,E0 RECENT ST   V@OFS(@PABPTR),@VARW+1  Get record offset
       8830 03,04
[1505] 8832 86,20           CLR  @VARW             Double byte value required
[1506] 8834 A1,20,E0        DADD V@BUF(@PABPTR),@VARW   Got it
       8837 06,04
[1507] 8839 00              RTN                    AND NOW, THE END IS NEAR...
[1508] 883A C7,08,02 CHKRM  DCH  SCRNBS+29,@CCPADR Not enough room for "?"
       883D FD
[1509] 883E 48,46           BR   G8840
[1510] 8840 0F,83    SCRZ   XML  SCROLL            Scroll one line for "?"
[1511] 8842 BF,08,02        DST  SCRNBS+2,@CCPADR   and update CCPADR accordingl
       8845 E2
[1512] 8846 00       G8840  RTN
[1513]               ***********************************************************
[1514]               *                LINPUT ROUTINE
[1515]               * If file-I/O then
[1516]               *             Get file number and check it
[1517]               *             Internal file not allowed
[1518]               * End if
[1519]               * Get variable info
[1520]               * Must be string variable
[1521]               * If file I/O then
[1522]               *           If no-partial-record of REC clause included
[1523]               *           Read new record
[1524]               *     End if
[1525]               *     Set up copy pointers
[1526]               * Else
[1527]               *     Call readline to read from keyboard
[1528]               *     Copy to crunch buffer adjustin g for screen offset
[1529]               * End if
[1530]               * Get string of proper length
[1531]               * Move data into string
[1532]               * Assign string
[1533]               * Done.
[1534]               ***********************************************************
[1535] 8847 06,97,45 LINPUT CALL INITKB            Assume input from keyboard
[1536] 884A D6,42,FD        CEQ  NUMBEZ,@CHAT      If "#" - then device
[1537] 884D 48,62           BR   G885C
[1538] 884F 06,93,5B        CALL CHKFN             Check for default = 0
[1539] 8852 8F,4A           DCZ  @FAC              #0 is assumed
[1540] 8854 68,65           BS   LINP10
[1541] 8856 06,88,EE        CALL INSU1             Parse the device #
[1542] 8859 DA,E0,05        CLOG >08,V@FLG(@PABPTR)
       885C 04,08
[1543] 885E 57,DD           BR   ERRFE
[1544] 8860 48,65           BR   LINP10
[1545] 8862 06,89,0C G885C  CALL INSUB1            Handle possible prompt
[1546] 8865 BD,0E,6E LINP10 DST  @VSPTR,@VAR4      Save original V-pointer
[1547]               *                              incase BREAK in READLN
[1548] 8868 06,97,E9        CALL BUG01             Get info about the symbol
[1549]               * Above call fixes bug.       Get value pointer and type
[1550] 886B D6,4C,65        CEQ  STRVAL,@FAC2      Must be string
[1551] 886E 57,E5           BR   ERRMUV
[1552] 8870 0F,77           XML  VPUSH

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0027 
FLMGR-359
[1553] 8872 8E,17           CZ   @DSRFLG           If device I/O
[1554] 8874 48,B5           BR   G88AF
[1555] 8876 8E,E0,03        CZ   V@OFS(@PABPTR)    If new record
       8879 04
[1556] 887A 48,81           BR   G887B
[1557] 887C 06,97,6B        CALL IOCLZ1            Read the record
[1558] 887F 48,99           BR   G8893
[1559] 8881 BC,0C,E0 G887B  ST   V@CNT(@PABPTR),@BYTES Get length of record
       8884 09,04
[1560] 8886 BD,66,E0        DST  V@BUF(@PABPTR),@TEMP5 Get address of buffer
       8889 06,04
[1561] 888B 8E,0C    G8885  CZ   @BYTES            While characters in buffer
[1562] 888D 68,99           BS   G8893
[1563] 888F A6,B0,66        SUB  OFFSET,V*TEMP5    Remove INPUT's offset
       8892 60
[1564] 8893 91,66           DINC @TEMP5            Increment pointer
[1565] 8895 92,0C           DEC  @BYTES            Decrement count
[1566] 8897 48,8B           BR   G8885             Drop out directly when done
[1567] 8899 86,66    G8893  CLR  @TEMP5            Need a word value
[1568] 889B BC,67,E0        ST   V@OFS(@PABPTR),@TEMP5+1  Restore value
       889E 03,04
[1569] 88A0 86,0C           CLR  @BYTES            Need a word value
[1570] 88A2 BC,0D,E0        ST   V@CNT(@PABPTR),@BYTES+1  Get the length
       88A5 09,04
[1571] 88A7 A5,0C,66        DSUB @TEMP5,@BYTES     Calcualte length
[1572] 88AA A1,66,E0        DADD V@BUF(@PABPTR),@TEMP5  Current buffer address
       88AD 06,04
[1573] 88AF 86,E0,03        CLR  V@OFS(@PABPTR)    Read next record next time
       88B2 04
[1574] 88B3 48,E7           BR   G88E1             Else if keyboard input
[1575] 88B5 06,89,41 G88AF  CALL INSUB2            Clear line and call READLN
[1576] 88B8 87,0C           DCLR @BYTES            Initialize byte counter
[1577] 88BA BD,66,0A        DST  @RAMPTR,@TEMP5    Initialize "crunch" pointer
[1578] 88BD D6,B0,2A        CEQ  SPACE+OFFSET,V*VARA     If space
       88C0 80
[1579] 88C1 48,C5           BR   G88BF
[1580] 88C3 93,2A           DDEC @VARA             Don't include space on end
[1581] 88C5 CD,20,2A G88BF  DCGT @VARA,@VARW       While not at end
[1582] 88C8 68,E2           BS   G88DC
[1583] 88CA BC,00,B0        ST   V*VARW,@VAR0      Get the character
       88CD 20
[1584] 88CE D6,00,7F        CEQ  EDGECH,@VAR0      If not at edge character
[1585] 88D1 68,DE           BS   G88D8
[1586] 88D3 A6,00,60        SUB  OFFSET,@VAR0      Subtract screen offset
[1587] 88D6 BC,B0,0A        ST   @VAR0,V*RAMPTR    And put into crunch buffer
       88D9 00
[1588] 88DA 91,0C           DINC @BYTES            Count it
[1589] 88DC 91,0A           DINC @RAMPTR           And update "crunch" pointer
[1590] 88DE 91,20    G88D8  DINC @VARW             Update input pointer
[1591] 88E0 48,C5           BR   G88BF
[1592] 88E2 0F,83    G88DC  XML  SCROLL            Scroll the screen
[1593] 88E4 BE,7F,03        ST   3,@XPT            Initialize x-pointer
[1594] 88E7 06,92,E4 G88E1  CALL CTMPST            Create temporary string
[1595] 88EA 0F,7C           XML  ASSGNV            Assign the value to it
[1596] 88EC 0F,75           XML  CONT              And continue execution
[1597]               * Get file number and info about the file
[1598] 88EE 06,93,77 INSU1  CALL CHKCON            Check & convert & search
[1599] 88F1 57,DD           BR   ERRFE             Give error if required
[1600]               * INPUT allowed for input and update modes
[1601] 88F3 DA,E0,05        CLOG >02,V@FLG(@PABPTR)
       88F6 04,02
[1602] 88F8 57,DD           BR   ERRFE
[1603] 88FA 06,93,96        CALL OUTEOF            Output pending PRINT stuff
[1604] 88FD BE,E0,04        ST   CZREAD,V@COD(@PABPTR)   Ensure read operation

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0028 
FLMGR-359
       8900 04,02
[1605] 8902 06,94,C8        CALL PARREC            Parse REC clause
[1606] 8905 0F,7E           XML  SPEED             Must be at a
[1607] 8907 00              BYTE SYNCHK          *  colon else
[1608] 8908 B5              BYTE COLONZ          *   its and error
[1609] 8909 86,17           CLR  @DSRFLG           Clear keyboard input flag
[1610] 890B 00              RTN
[1611]               * Parse and put out input prompt
[1612] 890C BD,0A,2C INSUB1 DST  @PGMPTR,@STADDR   Save pointer for prompt check
[1613] 890F 93,0A           DDEC @STADDR           Backup to previous token
[1614]               *                              Go into a tight loop
[1615] 8911 06,95,C0 G890B  CALL NXTCHR            Get next program character
[1616] 8914 69,2D           BS   INPZ37            Detected end of statement
[1617] 8916 D6,42,B5        CEQ  COLONZ,@CHAT      Stop if we find a colon
[1618] 8919 49,11           BR   G890B
[1619] 891B BD,2C,0A        DST  @STADDR,@PGMPTR   Backup for actual prompt scan
[1620] 891E 0F,79           XML  PGMCHR            Jump into 1st char of prompt
[1621] 8920 0F,74           XML  PARSE             And try to decode string expr
[1622] 8922 B5              BYTE COLONZ
[1623] 8923 D6,4C,65        CEQ  STRVAL,@FAC2      Number prompt illegal
[1624] 8926 57,C5           BR   ERRSNM
[1625] 8928 06,97,14        CALL OSTRNG            Output the given prompt
[1626] 892B 49,3C           BR   INPZ39            Exit without prompt backup
[1627] 892D BD,2C,0A INPZ37 DST  @STADDR,@PGMPTR   Backup to beginning of line
[1628] 8930 BE,42,B5        ST   COLONZ,@CHAT      Fake prompt with ":"
[1629] 8933 06,88,3A INPUZ2 CALL CHKRM             Check for room for ?
[1630] 8936 BE,B0,08        ST   >9F,V*CCPADR      Display ?
       8939 9F
[1631] 893A 95,08           DINCT @CCPADR          Count it too
[1632] 893C 0F,7E    INPZ39 XML  SPEED             Must be at a
[1633] 893E 00              BYTE SYNCHK          *  colon else
[1634] 893F B5              BYTE COLONZ          *   its an error
[1635] 8940 00              RTN
[1636]               * Issue 'BEEP' and call read line to read form screen
[1637] 8941 06,88,3A INSUB2 CALL CHKRM             Check for room for answer
[1638] 8944 BD,20,08        DST  @CCPADR,@VARW     Copy current cursor position
[1639] 8947 BE,B0,08 G8941  ST   >80,V*CCPADR      Clear the remainder
       894A 80
[1640] 894B 91,08           DINC @CCPADR            of the current line
[1641] 894D CB,08,02        DCHE >02FE,@CCPADR     Stop if we're there
       8950 FE
[1642] 8951 49,47           BR   G8941
[1643] 8953 BF,A2,FE        DST  >7F7F,V@>02FE     Replace edgechars
       8956 7F,7F
[1644] 8958 8E,80,CE        CZ   @PRTNFN           If previous tone finished
[1645] 895B 49,60           BR   G895A
[1646] 895D 06,00,34        CALL TONE1             ---------- BEEP -------------
[1647] 8960 C1,6E,0E G895A  DEX  @VAR4,@VSPTR      Don't destroy V-stack on BREA
[1648] 8963 06,6A,76        CALL READLN            Input a line from the keyboar
[1649] 8966 C1,6E,0E        DEX  @VAR4,@VSPTR      Restore V-stack pointer
[1650] 8969 BD,14,0A        DST  @STADDR,@CURLIN   Save in a temp
[1651] 896C BF,0A,08        DST  CRNBUF,@RAMPTR    Init crunch buffer pointer
       896F 20
[1652] 8970 00              RTN
[1653]               ***********************************************************
[1654]               *                   ACCEPT STATEMENT
[1655]               * Accept input anywhere on the screen. The total number of
[1656]               * input variables is limited to one. On an ACCEPT AT( , ),
[1657]               * the maximum number that can be accepted is up to the righ
[1658]               * margin!!!! If SIZE() is used, the maximum number is
[1659]               * limited to the given SIZE, or to the number of characters
[1660]               * remaining on the line, whichever is the lesser.
[1661]               ***********************************************************
[1662]               * RXB PATCH TO FIX ACCEPT USED IN EDIT MODE               

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0029 
FLMGR-359
[1663]               * ACCEPT CLR  V@ACCTRY          Clear "try again" flag
[1664] 8971 05,97,FC ACCEPT B    ACCPMM
[1665] 8974 06,94,F5 ACCEP2 CALL DISACC            Use common code for DISPLAY/A
[1666] 8977 61,0F           BS   ERRSYN             COND set means end of statem
[1667] 8979 BE,63,FF        ST   >FF,@ARG7         Assume we don't have VALIDATE
[1668]               ************ VALIDATE OPTION HANDLING *********************
[1669] 897C D6,42,FE        CEQ  VALIDZ,@CHAT      Detected VALIDATE option
[1670] 897F 4A,03           BR   G89FD
[1671] 8981 0F,79           XML  PGMCHR            Next character should start o
[1672] 8983 D6,42,B7        CEQ  LPARZ,@CHAT       "* SYNTAX ERROR *"
[1673] 8986 41,0F           BR   ERRSYN
[1674] 8988 B6,04,40        OR   >40,@PABPTR       Indicate usage of validate cl
[1675] 898B BF,2A,00        DST  1,@VARA           Use VARA as length of option
       898E 01
[1676] 898F 87,20           DCLR @VARW             VARW= options used, VARW+1=#0
[1677]               *                              stack entries for strings
[1678] 8991 0F,79    G898B  XML  PGMCHR            Skip separator token
[1679] 8993 CA,42,E8        CHE  NUMERZ,@CHAT      Could be valid option
[1680] 8996 49,B0           BR   G89AA
[1681] 8998 CA,42,EB        CHE  UALPHZ+1,@CHAT    It is ....
[1682] 899B 69,B0           BS   G89AA
[1683] 899D BE,5C,01        ST   1,@ARG            Select bit 0 as number option
[1684] 89A0 A6,42,E8        SUB  NUMERZ,@CHAT      Create correct offset
[1685] 89A3 69,A8           BS   SETVW             Skip the shift stat.
[1686] 89A5 E0,5C,42        SLL  @CHAT,@ARG        Then select whatever option w
[1687] 89A8 B4,20,5C SETVW  OR   @ARG,@VARW        Remember options in VARW
[1688]               *                              stack entries for strings
[1689] 89AB 0F,79           XML  PGMCHR            Get next token
[1690] 89AD 05,89,CA        B    VLIDZ0            Must use a long branch here
[1691] 89B0 0F,74    G89AA  XML  PARSE             Try to decode a string expres
[1692] 89B2 B6              BYTE RPARZ
[1693] 89B3 D6,4C,65        CEQ  STRVAL,@FAC2      String-number mismatch
[1694] 89B6 57,C5           BR   ERRSNM
[1695] 89B8 8E,51           CZ   @FAC7             Only count non-null strings
[1696] 89BA 69,CA           BS   VLIDZ0
[1697] 89BC A0,2B,51        ADD  @FAC7,@VARA+1     Now watch out for overflow
[1698] 89BF 0C              CARRY                  Sting truncated
[1699] 89C0 49,C6           BR   G89C0
[1700] 89C2 06,6A,84        CALL ERRZZ             * STRING TRUNCATED ERROR *
[1701] 89C5 13              BYTE 19
[1702] 89C6 0F,77    G89C0  XML  VPUSH             Push the result for future re
[1703] 89C8 90,21           INC  @VARW+1           Count number of entries on st
[1704] 89CA D6,42,B3 VLIDZ0 CEQ  COMMAZ,@CHAT      Evaluate all fields
[1705] 89CD 69,91           BS   G898B
[1706] 89CF 0F,7E           XML  SPEED
[1707] 89D1 00              BYTE SYNCHK          * Check for ")" on end
[1708] 89D2 B6              BYTE RPARZ           * If not, "* SYNTAX ERROR *"
[1709] 89D3 06,94,F8        CALL DISPZ1            Try to evaluate further optio
[1710] 89D6 61,0F           BS   ERRSYN            Premature end of statement
[1711] 89D8 BD,0C,2A        DST  @VARA,@BYTES      Allocate string for character
[1712] 89DB 0F,71           XML  GETSTR
[1713] 89DD BD,5C,1C        DST  @SREF,@ARG        Get start of allocated string
[1714] 89E0 BC,B0,5C        ST   @VARW,V*ARG       Get start of allocated string
       89E3 20
[1715] 89E4 91,5C           DINC @ARG              Leave room form standard opti
[1716] 89E6 8E,21    G89E0  CZ   @VARW+1           Copy all available informatio
[1717] 89E8 69,F9           BS   G89F3
[1718] 89EA 0F,78           XML  VPOP              Regain stack-entry
[1719] 89EC 34,50,B0        MOVE @FAC6,V*FAC4,V*ARG Copy string
       89EF 5C,B0,4E
[1720] 89F2 A1,5C,50        DADD @FAC6,@ARG        Update destination address
[1721] 89F5 92,21           DEC  @VARW+1           Count # of stack entries
[1722] 89F7 49,E6           BR   G89E0
[1723] 89F9 BD,A3,B0 G89F3  DST  @SREF,V@VALIDP    Copy start address of string

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0030 
FLMGR-359
       89FC 1C
[1724] 89FD BD,A3,B2        DST  @VARA,V@VALIDL     and total string length
       8A00 2A
[1725] 8A01 86,63           CLR  @ARG7             Indicate VALIDATE usage of RE
[1726] 8A03 BD,20,08 G89FD  DST  @CCPADR,@VARW     Save start address of the fie
[1727] 8A06 BD,2A,20        DST  @VARW,@VARA       Set default highest address u
[1728] 8A09 BD,5E,08        DST  @CCPADR,@ARG2     Select absolute highest usabl
[1729] 8A0C A3,5E,01        DADD 290,@ARG2         290=2+32*9 maximum of 254 cha
       8A0F 22
[1730] 8A10 C6,2B,FC        CH   >FC,@VARA+1       Start at the end of line
[1731] 8A13 4A,19           BR   G8A13
[1732] 8A15 A3,5E,00        DADD 4,@ARG2
       8A18 04
[1733] 8A19 8E,04    G8A13  CZ   @PABPTR           We used some options like AT,
[1734] 8A1B 6A,6C           BS   G8A66
[1735] 8A1D 0F,7E           XML  SPEED
[1736] 8A1F 00              BYTE SYNCHK          * Should always end on ":"
[1737] 8A20 B5              BYTE COLONZ
[1738] 8A21 DA,04,02        CLOG >02,@PABPTR       Used BEEP clause
[1739] 8A24 6A,29           BS   G8A23
[1740] 8A26 06,00,34        CALL TONE1             Wake up the user
[1741] 8A29 DA,04,04 G8A23  CLOG >04,@PABPTR       Used AT option, SIZE!!!
[1742] 8A2C 6A,3B           BS   G8A35
[1743] 8A2E DA,04,08        CLOG >08,@PABPTR       Use defualt SIZE option
[1744] 8A31 4A,39           BR   G8A33
[1745] 8A33 BE,05,1C        ST   VWIDTH,@PABPTR+1  Limit current record length
[1746] 8A36 06,95,E5        CALL SIZE1
[1747] 8A39 4A,4D    G8A33  BR   ACCPZ1
[1748] 8A3B DA,04,08 G8A35  CLOG >08,@PABPTR       SIZE option used somewhere
[1749] 8A3E 6A,6C           BS   G8A66
[1750]               * We're sure now that SIZE has been used WITHOUT the AT
[1751]               * option, this means that we should set XPT to point behind
[1752]               * the SIZE field. This can be done by adding the record
[1753]               * length to the current screen base address and the line's
[1754]               * screen base address
[1755] 8A40 BC,7F,09        ST   @CCPADR+1,@XPT    Start of with current address
[1756] 8A43 A0,7F,07        ADD  @RECLEN,@XPT      Add in the current record len
[1757] 8A46 A6,7F,DF        SUB  >DF,@XPT          And subtract the lower base a
[1758]               *                             Also adjust for edge characte
[1759] 8A49 BC,A3,B8        ST   @XPT,V@SIZXPT     Save it for "try again" case
       8A4C 7F
[1760]               *                              in WARNING, XPT gets changed
[1761] 8A4D BD,A3,B4 ACCPZ1 DST  @CCPADR,V@SIZCCP  Save for "try again" case
       8A50 08
[1762] 8A51 BC,A3,B6        ST   @RECLEN,V@SIZREC  Save for "try again" case
       8A54 07
[1763]               ***********************************************************
[1764]               * ENTRY POINT FOR "TRY AGAIN" CASE WHEN SIZE OR ACCEPT USED
[1765]               ***********************************************************
[1766] 8A55 DA,04,80 ACCPZ9 CLOG >80,@PABPTR       Blank current field
[1767] 8A58 4A,5E           BR   G8A58
[1768] 8A5A BE,B0,08        ST   SPACE+OFFSET,V*CCPADR
       8A5D 80
[1769] 8A5E 91,08    G8A58  DINC @CCPADR           Update screen address
[1770] 8A60 92,07           DEC  @RECLEN           Reduce count, always at least
[1771] 8A62 4A,55           BR   ACCPZ9            Loop until at end of field
[1772] 8A64 93,08           DDEC @CCPADR           Fix end of field for maximum
[1773] 8A66 BD,2A,08        DST  @CCPADR,@VARA     Set highest location availabl
[1774] 8A69 BD,5E,2A        DST  @VARA,@ARG2       Also highest location availab
[1775]               *                              OK all set to go
[1776] 8A6C D6,A3,B7 G8A66  CEQ  1,V@ACCTRY        Skip if in "try again"
       8A6F 01
[1777] 8A70 6A,7A           BS   ACCPZ7
[1778] 8A72 BD,0E,6E        DST  @VSPTR,@VAR4      Save first entry in V-stack

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0031 
FLMGR-359
[1779] 8A75 06,97,E9        CALL BUG01             Collect the symbol designator
[1780]               * Above call fixes bug.       Take care of arrays too
[1781] 8A78 0F,77           XML  VPUSH             Save symbol table entry
[1782] 8A7A BD,A3,AC ACCPZ7 DST  @VARW,V@ACCVRW    Save for trying again case
       8A7D 20
[1783] 8A7E BD,A3,AE        DST  @VARA,V@ACCVRA    Save for trying again case
       8A81 2A
[1784]               ***********************************************************
[1785]               * ENTRY POINT FOR "TRY AGAIN" WHEN NEITHER SIZE OR ACCEPT I
[1786]               ***********************************************************
[1787]               * In case a CALL CLEAR or ERASE ALL or CALL HCHAR has just
[1788]               * processed, EDGE CHARS, are gone at the bottom line
[1789] 8A82 DA,04,0C ACCPZ5 CLOG >0C,@PABPTR       If AT/SIZE used, maximum fiel
[1790] 8A85 4A,8C           BR   AZ1                is line, so no need to worry
[1791]               *                              about it
[1792] 8A87 BF,A2,FE        DST  >7F7F,V@>02FE     Put the EDGE CHAR back
       8A8A 7F,7F
[1793] 8A8C C1,0E,6E AZ1    DEX  @VSPTR,@VAR4      Don't destroy V-stack on BREA
[1794] 8A8F 06,6A,86        CALL READL1            Ask for some input that can b
[1795]               *                             used
[1796] 8A92 C1,0E,6E        DEX  @VSPTR,@VAR4      Resote V-stack pointer
[1797]               * At this point, VARA contains the highest location used,
[1798]               * and VARW contains the string's start address
[1799] 8A95 D5,2A,20 ACCPZ2 DCEQ @VARW,@VARA       Only non-empty string
[1800] 8A98 6A,A4           BS   G8A9E
[1801] 8A9A 93,2A           DDEC @VARA             Go to the next position
[1802] 8A9C D6,B0,2A        CEQ  SPACE+OFFSET,V*VARA
       8A9F 80
[1803] 8AA0 6A,95           BS   ACCPZ2
[1804] 8AA2 91,2A           DINC @VARA             Back to the last space
[1805] 8AA4 0F,78    G8A9E  XML  VPOP              Check the symbol designator i
[1806] 8AA6 0F,77           XML  VPUSH             a string or numeric variable
[1807] 8AA8 D6,4C,65        CEQ  >65,@FAC2         If numeric : empty string is
[1808] 8AAB 6A,B8           BS   G8AB2
[1809] 8AAD D5,20,2A        DCEQ @VARA,@VARW       If an empty string was entere
[1810] 8AB0 4A,B8           BR   G8AB2
[1811] 8AB2 06,6A,82        CALL WARNZZ            *** INPUT ERROR ***
[1812] 8AB5 20              BYTE 32
[1813] 8AB6 4B,02           BR   ACCPZ8
[1814] 8AB8 87,0C    G8AB2  DCLR @BYTES            Compute length of input strin
[1815] 8ABA BD,1C,20        DST  @VARW,@SREF       Use SREF as temporary variabl
[1816] 8ABD D5,1C,2A G8AB7  DCEQ @VARA,@SREF
[1817] 8AC0 6A,CE           BS   G8AC8
[1818] 8AC2 D6,B0,1C        CEQ  EDGECH,V*SREF     Exclude edge character
       8AC5 7F
[1819] 8AC6 6A,CA           BS   G8AC4
[1820] 8AC8 91,0C           DINC @BYTES
[1821] 8ACA 91,1C    G8AC4  DINC @SREF             Decrement the counter
[1822] 8ACC 4A,BD           BR   G8AB7
[1823] 8ACE 06,92,D7 G8AC8  CALL CTSTR0            Create a temporary string
[1824] 8AD1 D5,20,2A ACCPZ3 DCEQ @VARA,@VARW
[1825] 8AD4 6A,F1           BS   G8AEB
[1826] 8AD6 D6,B0,20        CEQ  EDGECH,V*VARW     Skip the edge character
       8AD9 7F
[1827] 8ADA 4A,E2           BR   G8ADC
[1828] 8ADC A3,20,00        DADD 4,@VARW
       8ADF 04
[1829] 8AE0 4A,D1           BR   ACCPZ3
[1830] 8AE2 BC,B0,1C G8ADC  ST   V*VARW,V*SREF     Copy the string
       8AE5 B0,20
[1831] 8AE7 A6,B0,1C        SUB  OFFSET,V*SREF     Subtract the screen offset
       8AEA 60
[1832] 8AEB 91,20           DINC @VARW             Update pointers
[1833] 8AED 91,1C           DINC @SREF

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0032 
FLMGR-359
[1834] 8AEF 4A,D1           BR   ACCPZ3            Result can't be 0
[1835] 8AF1 D6,4C,65 G8AEB  CEQ  STRVAL,@FAC2      Numerical variable
[1836] 8AF4 6B,30           BS   ACCPZ6
[1837] 8AF6 BE,4C,65        ST   STRVAL,@FAC2      Create temp string
[1838] 8AF9 06,A0,16        CALL VALCD             Use VAL code for translation
[1839] 8AFC 4B,30           BR   ACCPZ6            No error - ok go on
[1840] 8AFE 06,6A,82 WRNSNM CALL WARNZZ            Error
[1841] 8B01 07              BYTE 7               * STRING NUMBER MISMATCH
[1842] 8B02 DA,04,08 ACCPZ8 CLOG >08,@PABPTR       If SIZE is used
[1843] 8B05 6B,10           BS   G8B0A
[1844] 8B07 DA,04,04        CLOG >04,@PABPTR       Also AT is not used
[1845] 8B0A 4B,10           BR   G8B0A
[1846] 8B0C BC,7F,A3        ST   V@SIZXPT,@XPT     Restore XPT : in WARNING XPT
       8B0F B8
[1847] 8B10 BD,20,A3 G8B0A  DST  V@ACCVRW,@VARW    Restore @VARA, @VARW
       8B13 AC
[1848] 8B14 BD,2A,A3        DST  V@ACCVRA,@VARA
       8B17 AE
[1849] 8B18 BE,A3,B7        ST   1,V@ACCTRY        Set the "try again" flag
       8B1B 01
[1850] 8B1C DA,04,08        CLOG >08,@PABPTR       If SIZE is not used
[1851] 8B1F 4B,26           BR   G8B20
[1852]               * IF ACCEPT ALSO NOT USED. GOTO "TRY AGAIN" FORM HERE
[1853] 8B21 DA,04,04        CLOG >04,@PABPTR
[1854] 8B24 6A,82           BS   ACCPZ5
[1855]               * IF "EITHER SIZE OR ACCEPT IS USED" THEN
[1856] 8B26 BD,08,A3 G8B20  DST  V@SIZCCP,@CCPADR  Restore CCPADR
       8B29 B4
[1857] 8B2A BC,07,A3        ST   V@SIZREC,@RECLEN  Restore RECLEN
       8B2D B6
[1858] 8B2E 4A,55           BR   ACCPZ9            Go blanking the field and
[1859]               *                              "try again"
[1860] 8B30 0F,7C    ACCPZ6 XML  ASSGNV            Should be ok now
[1861] 8B32 DA,04,0C        CLOG >0C,@PABPTR       Test usage of AT and/or SIZE
[1862] 8B35 4B,3C           BR   ACCPZ4            At least one of the two used
[1863] 8B37 0F,83           XML  SCROLL            Scroll the screen up
[1864] 8B39 BE,7F,03        ST   3,@XPT            And reset XPT
[1865] 8B3C 0F,75    ACCPZ4 XML  CONT
[1866]               ***********************************************************
[1867]               *                  READ STATEMENT
[1868]               * Assign DATA values to variables in READ-list one at a
[1869]               * time. Possibly search for new DATA statements if the
[1870]               * current DATA statement has been used. Be careful with
[1871]               * null entries...!!!
[1872]               ***********************************************************
[1873] 8B3E 0F,79    G8B38  XML  PGMCHR            Get character following ","
[1874] 8B40 06,97,E9 READ   CALL BUG01             Get pointers and correct entr
[1875]               * Above call fixes bug.        also allow for array variabl
[1876] 8B43 0F,77           XML  VPUSH             Push on Vstack for assignment
[1877] 8B45 8E,34           CZ   @DATA             DATA ERROR
[1878] 8B47 77,D9           BS   ERRDAT
[1879] 8B49 06,93,0A        CALL GETGFL            Get next data item (RAM/GROM)
[1880] 8B4C D6,4C,65        CEQ  STRVAL,@FAC2
[1881] 8B4F 6B,71           BS   G8B6B
[1882] 8B51 D6,01,C8        CEQ  NUMZ,@VAR0+1      Not a numeric
[1883] 8B54 57,C5           BR   ERRSNM
[1884]               *                              string-number mismatch error
[1885] 8B56 06,93,35        CALL CHKSZ0            Build up string info
[1886] 8B59 91,50           DINC @FAC6             Force legal delimiter on end
[1887] 8B5B 06,A0,02        CALL LITS05            Copy numeric into string spac
[1888] 8B5E BD,56,1C        DST  @SREF,@FAC12      Copy string start address
[1889] 8B61 A1,1C,50        DADD @FAC6,@SREF       Compute end address of string
[1890] 8B64 93,1C           DDEC @SREF             Back up over delimiter
[1891] 8B66 06,A0,12        CALL CONV1             Convert string to number

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0033 
FLMGR-359
[1892] 8B69 D5,A3,90        DCEQ @SREF,V@CSNTMP    WRONG!!!!!!!
       8B6C 1C
[1893] 8B6D 57,D9           BR   ERRDAT
[1894] 8B6F 4B,79           BR   G8B73
[1895] 8B71 06,93,29 G8B6B  CALL CHKSTR            Check string input
[1896] 8B74 77,D9           BS   ERRDAT            Give error on error
[1897] 8B76 06,A0,02        CALL LITS05            Allocate string in string spa
[1898] 8B79 0F,7C    G8B73  XML  ASSGNV            Assign variable
[1899] 8B7B 06,93,0A        CALL GETGFL            Get next datum from DATA stmt
[1900] 8B7E D6,01,B3        CEQ  COMMAZ,@VAR0+1    Has to be an end of DATA
[1901] 8B81 6B,95           BS   G8B8F
[1902] 8B83 8E,01           CZ   @VAR0+1           Check for end of data
[1903] 8B85 57,D9           BR   ERRDAT
[1904] 8B87 97,36           DDECT @LNBUF           Pointer to line # of DATA stm
[1905] 8B89 86,34           CLR  @DATA             Assume the worst - no more DA
[1906] 8B8B D5,36,30        DCEQ @STLN,@LNBUF
[1907] 8B8E 6B,95           BS   G8B8F
[1908] 8B90 93,36           DDEC @LNBUF            Next line's 1st token address
[1909] 8B92 06,A0,08        CALL DATAST            Get next DATA statement
[1910] 8B95 D6,42,B3 G8B8F  CEQ  COMMAZ,@CHAT      Worry about junk in CONT
[1911] 8B98 6B,3E           BS   G8B38
[1912] 8B9A 0F,75           XML  CONT
[1913]               * SRDATA-Search for DATA statements (DATA statement must
[1914]               * be the only statement on one line)
[1915]               * SEARCH-also used for searching IMAGE statement.
[1916] 8B9C BE,4C,93 SRDATA ST   DATAZ,@FAC2       Search for a DATA token
[1917] 8B9F C1,2C,34 SEARCH DEX  @DATA,@PGMPTR     Exchange with normal PC
[1918] 8BA2 C0,01,42        EX   @CHAT,@VAR0+1     Preserve current PGM characte
[1919] 8BA5 8E,44           CZ   @PRGFLG           If imperative statement
[1920] 8BA7 4B,B9           BR   G8BB3
[1921] 8BA9 8E,80,84        CZ   @RAMTOP           With ERAM : text itself in ER
[1922] 8BAC 6B,B9           BS   G8BB3
[1923] 8BAE BE,80,89        ST   >FF,@RAMFLG       Fake RAMFLG in this case
       8BB1 FF
[1924] 8BB2 0F,79           XML  PGMCHR            Get first character on the li
[1925] 8BB4 86,80,89        CLR  @RAMFLG           Restore it back
[1926] 8BB7 4B,BB           BR   SRDAZ1            Skip that PGMCHR
[1927] 8BB9 0F,79    G8BB3  XML  PGMCHR            Get first character on the li
[1928] 8BBB D4,42,4C SRDAZ1 CEQ  @FAC2,@CHAT       Search for specific token
[1929] 8BBE 6B,C3           BS   SRDAZ0
[1930] 8BC0 D4,00,00        CEQ  @VAR0,@VAR0       Set COND if no DATA found
[1931] 8BC3 C1,2C,34 SRDAZ0 DEX  @DATA,@PGMPTR     Exchange won't affect the CON
[1932] 8BC6 C0,01,42        EX   @CHAT,@VAR0+1     Situation ok
[1933] 8BC9 01              RTNC                   Return to caller with COND
[1934]               ***********************************************************
[1935]               *                     OLD STATEMENT
[1936]               * A normal load:
[1937]               *   Get a program from an external device to VDP and
[1938]               *   reinitialize the program pointers. Also update the line
[1939]               *   pointer table, since the memory size of the machine on
[1940]               *   which the program was created doesn't have to be the
[1941]               *   same as on the current system!!!! Then check if ERAM
[1942]               *   existed, move it to ERAM if does exist (in relocated
[1943]               *   from)
[1944]               * Load a sequential file:
[1945]               *   When program is bigger than 13.5K and ERAM exists,
[1946]               *   maximum-length record reads are preformed to read the
[1947]               *   file and each record is copied into the ERAM as it is
[1948]               *   read.
[1949]               ***********************************************************
[1950] 8BCA 06,8B,D0 OLD    CALL OLD1              Make OLD1 a subroutine for LO
[1951] 8BCD 05,60,12        B    TOPL15            Go back to top level
[1952] 8BD0 06,92,3B OLD1   CALL GPNAME            Get program name & reinitiali
[1953] 8BD3 0F,79           XML  PGMCHR            Check for EOL

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0034 
FLMGR-359
[1954] 8BD5 BD,0A,04        DST  @PABPTR,@STADDR   Compute memory start address
[1955] 8BD8 A1,0A,E0        DADD V@NLEN-1(@PABPTR),@STADDR    Add PAB-name lengt
       8BDB 0C,04
[1956] 8BDD A3,0A,00        DADD PABLEN-4,@STADDR              and PAB length
       8BE0 0A
[1957] 8BE1 BD,E0,0A        DST  @HIVDP,V@RNM(@PABPTR)  Compute # of availiable
       8BE4 04,70
[1958] 8BE6 A5,E0,0A        DSUB @STADDR,V@RNM(@PABPTR)
       8BE9 04,0A
[1959] 8BEB 91,E0,0A        DINC V@RNM(@PABPTR)    Include current address
       8BEE 04
[1960] 8BEF BD,E0,06        DST  @STADDR,V@BUF(@PABPTR) for copy start
       8BF2 04,0A
[1961] 8BF4 BE,E0,04        ST   CZLOAD,V@COD(@PABPTR)   Select LOAD I/O code
       8BF7 04,05
[1962] 8BF9 06,97,71        CALL CDSR              Call device service routine
[1963] 8BFC 4C,69           BR   OLDZ3             Not a program file, may be a
[1964]               *                              sequential file
[1965]               * STADDR still points to the info bytes
[1966] 8BFE BD,02,E0        DST  V@2(@STADDR),@MNUM First test checksum
       8C01 02,0A
[1967] 8C03 B9,02,E0        DXOR V@4(@STADDR),@MNUM  which is a simple XOR
       8C06 04,0A
[1968] 8C08 D5,B0,0A        DCEQ @MNUM,V*STADDR     Try PROTECTION option
       8C0B 02
[1969] 8C0C 6C,1B           BS   G8C15
[1970] 8C0E 83,02           DNEG @MNUM
[1971] 8C10 D5,B0,0A        DCEQ @MNUM,V*STADDR    No-ERROR
       8C13 02
[1972] 8C14 4D,33           BR   OLDER
[1973] 8C16 B6,45,80        OR   >80,@FLAG         Yes, set LIST/EDIT PROTECTION
[1974] 8C19 4C,1D           BR   G8C17
[1975] 8C1B 86,45    G8C15  CLR  @FLAG             Otherwise clear protection
[1976] 8C1D BD,32,E0 G8C17  DST  V@2(@STADDR),@ENLN  Copy new ENLN,
       8C20 02,0A
[1977] 8C22 BD,30,E0        DST  V@4(@STADDR),@STLN   STLN and
       8C25 04,0A
[1978] 8C27 BD,A3,BC        DST  V@6(@STADDR),V@OLDTOP top of memory info
       8C2A E0,06,0A
[1979] 8C2D A3,0A,00        DADD 8,@STADDR         Point to program data
       8C30 08
[1980] 8C31 BD,A3,BE        DST  @HIVDP,V@NEWTOP   Set up the new top
       8C34 70
[1981] 8C35 06,8D,3C        CALL RELOCA            Relocate according to @>8370
[1982] 8C38 8E,80,84 OLDZ5  CZ   @RAMTOP           ERAM present?
[1983] 8C3B 6D,38           BS   LRTOPZ
[1984]               *                             No, go back to toplevel
[1985]               *                             Yes, move from VDP to ERAM
[1986]               *                             (in relocated form)
[1987]               ************ Move to the ERAM from CPUBAS first ***********
[1988] 8C3D BD,00,70        DST  @HIVDP,@VAR0
[1989] 8C40 A5,00,30        DSUB @STLN,@VAR0
[1990] 8C43 91,00           DINC @VAR0             # of bytes to move
[1991] 8C45 BD,4E,00        DST  @VAR0,@CCC        @CCC : Byte count for VGWITE
[1992]               * RXB PATCH CODE FOR PMEMORY UPPER 24K
[1993]               *       DST  CPUBAS,@BBB       @BBB : Destination addr on E
[1994] 8C48 BD,50,A3        DST  V@PMEM,@BBB       @BBB : Destination addr on ER
       8C4B 9E
[1995] 8C4C BD,0A,50        DST  @BBB,@STADDR      For later use as the base of
[1996]               *                              current program image in REL
[1997] 8C4F BD,4C,30        DST  @STLN,@AAA        @AAA : Source address on ERAM
[1998] 8C52 0F,8A           XML  VGWITE            Move from VDP to ERAM
[1999] 8C54 BD,A3,BC        DST  @HIVDP,V@OLDTOP   Set up old memory top
       8C57 70

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0035 
FLMGR-359
[2000] 8C58 BD,A3,BE        DST  @RAMTOP,V@NEWTOP  Set up new memory top
       8C5B 80,84
[2001] 8C5D 06,8D,3C        CALL RELOCA            Relocate the program image
[2002] 8C60 BD,80,86 OLDZ7  DST  @STLN,@RAMFRE     Reset the RAMFRE on ERAM
       8C63 30
[2003] 8C64 93,80,86        DDEC @RAMFRE
[2004] 8C67 4D,38           BR   LRTOPZ            Go back to toplevel
[2005]               ***********************************************************
[2006]               * At this point : if ERAM not exist - ERROR off else open
[2007]               * sequential file to load program to ERAM through VDP RAM
[2008]               ***********************************************************
[2009] 8C69 8E,80,84 OLDZ3  CZ   @RAMTOP
[2010] 8C6C 6D,33           BS   OLDER
[2011]               * Set up PAB for OPEN
[2012]               * File type : Sequential file,
[2013]               * Mode of operation : Input
[2014]               * Date type : internal
[2015]               * Record type : Variable length records
[2016]               * Logical record length : 254 maximum
[2017] 8C6E 31,00,09        MOVE 9,G@PAB3,V@4(@PABPTR) Build the PAB          <<
       8C71 E0,04,04
       8C74 8D,2A
[2018] 8C76 BD,4A,70        DST  @HIVDP,@FAC       Compute the data buffer addre
[2019] 8C79 A7,4A,00        DSUB 253,@FAC
       8C7C FD
[2020] 8C7D BD,4C,4A        DST  @FAC,@AAA         Save it for later use in VGWI
[2021] 8C80 BD,E0,06        DST  @FAC,V@BUF(@PABPTR)
       8C83 04,4A
[2022] 8C85 06,97,71        CALL CDSR              Call the device service routi
[2023] 8C88 57,9A           BR   ERRZ2B            Return with ERROR indication
[2024]               *                              in COND
[2025]               * Start to read in file
[2026] 8C8A 06,97,64        CALL IOCALL            Read in the first record
[2027] 8C8D 02              BYTE CZREAD          *
[2028]               * Check the control information
[2029] 8C8E D6,E0,09        CEQ  10,V@CNT(@PABPTR) * 10 bytes contr info
       8C91 04,0A
[2030] 8C93 4D,33           BR   OLDER
[2031]               * >ABCD is the flag set at SAVE time indicating a program f
[2032] 8C95 D7,B0,4A        DCEQ >ABCD,V*FAC
       8C98 AB,CD
[2033] 8C9A 4D,33           BR   OLDER
[2034] 8C9C 95,4A           DINCT @FAC
[2035] 8C9E BD,30,B0        DST  V*FAC,@STLN       Copy the new STLN
       8CA1 4A
[2036] 8CA2 95,4A           DINCT @FAC
[2037] 8CA4 BD,32,B0        DST  V*FAC,@ENLN       ENLN too
       8CA7 4A
[2038] 8CA8 BD,02,32        DST  @ENLN,@MNUM       Test checksum
[2039] 8CAB B9,02,30        DXOR @STLN,@MNUM
[2040] 8CAE 95,4A           DINCT @FAC
[2041] 8CB0 D5,B0,4A        DCEQ @MNUM,V*FAC       Try PROTECTION option
       8CB3 02
[2042] 8CB4 6C,C3           BS   G8CBD
[2043] 8CB6 83,02           DNEG @MNUM
[2044] 8CB8 D5,B0,4A        DCEQ @MNUM,V*FAC       No, ERROR
       8CBB 02
[2045] 8CBC 4D,33           BR   OLDER
[2046] 8CBE B6,45,80        OR   >80,@FLAG         Yes, set LIST/EDIT PROTECTION
[2047] 8CC1 4C,C5           BR   G8CBF
[2048] 8CC3 86,45    G8CBD  CLR  @FLAG             Otherwise clear protection fl
[2049] 8CC5 95,4A    G8CBF  DINCT @FAC
[2050]               * Check is there enough memory in ERAM
[2051] 8CC7 BD,02,B0        DST  V*FAC,@MNUM       Get the old top of memory out

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0036 
FLMGR-359
       8CCA 4A
[2052] 8CCB BD,A3,BC        DST  @MNUM,V@OLDTOP    For later use in RELOCA
       8CCE 02
[2053] 8CCF A5,02,30        DSUB @STLN,@MNUM
[2054] 8CD2 91,02           DINC @MNUM             Total # of bytes in program
[2055] 8CD4 BD,08,02        DST  @MNUM,@CCC1       For later use as the byte cou
[2056]               * RXB PATCH CODE FOR PMEMORY UPPER 24K
[2057]               *       DADD CPUBAS,@MNUM      Add the total # of bytes to 
[2058] 8CD7 A1,02,A3        DADD V@PMEM,@MNUM  Add the total # of bytes to CPUBA
       8CDA 9E
[2059]               * Check if enough memory in ERAM
[2060] 8CDB 0A              GT                     Greater than >FFFF case
[2061] 8CDC 6D,33           BS   OLDER
[2062] 8CDE C5,02,80        DCH  @RAMTOP,@MNUM     Greater than >DFFF case
       8CE1 84
[2063] 8CE2 6D,33           BS   OLDER
[2064]               * Move to ERAM starting from CPUBAS first,
[2065]               * then relocate according the new top of memory in ERAM
[2066]               * RXB PATCH CODE FOR PMEMORY UPPER 24K
[2067]               * OLZZ   DST  CPUBAS,@BBB       @BBB : Destination addr in
[2068] 8CE4 BD,50,A3 OLDZZ  DST  V@PMEM,@BBB       @BBB : Destination addr in
       8CE7 9E
[2069]               *                                    ERAM FOR VGWITE
[2070] 8CE8 BD,0A,50        DST  @BBB,@STADDR      For later use as base of the
[2071]               *                      current program image in ERAM RELOCA
[2072]               *      DST  HIVDP,@AAA        @AAA has been set up before
[2073]               *      DSUB 253,@AAA          For copy start on VDP RAM
[2074]               * @CCC1 : Total # of bytes to move to ERAM, set up above
[2075] 8CEB 06,97,64        CALL IOCALL            Read in the second record
[2076] 8CEE 02              BYTE CZREAD
[2077]               * Read in the file and each record
[2078]               * Should be a full (maximum length 254) record at this time
[2079]               * because program supposed to be bigger than 13.5K
[2080] 8CEF D6,E0,09 G8CE9  CEQ  254,V@CNT(@PABPTR)
       8CF2 04,FE
[2081] 8CF4 4D,33           BR   OLDER
[2082] 8CF6 BF,4E,00        DST  254,@CCC          @CCC : # of bytes to move
       8CF9 FE
[2083] 8CFA 0F,8A           XML  VGWITE            Move data from VDP to ERAM
[2084] 8CFC A3,50,00        DADD 254,@BBB          Update the destination addres
       8CFF FE
[2085]               *                              on ERAM
[2086] 8D00 A7,08,00        DSUB 254,@CCC1         # of bytes left to move
       8D03 FE
[2087] 8D04 6D,1C           BS   OLDZ9             No more bytes to move
[2088] 8D06 06,97,64        CALL IOCALL            Read in the file and each rec
[2089] 8D09 02              BYTE CZREAD          * Copied into ERAM as it is rea
[2090] 8D0A CB,08,00        DCHE 254,@CCC1         Leave the last record alone
       8D0D FE
[2091] 8D0E 6C,EF           BS   G8CE9
[2092]               * The record length should be the same as the # of bytes le
[2093]               * to move at this time
[2094] 8D10 D4,E0,09        CEQ  @CCC1+1,V@CNT(@PABPTR)
       8D13 04,09
[2095] 8D15 4D,33           BR   OLDER
[2096] 8D17 BD,4E,08        DST  @CCC1,@CCC        Set up byte count for the las
[2097] 8D1A 0F,8A           XML  VGWITE            Move data from VDP to ERAM
[2098] 8D1C 06,97,64 OLDZ9  CALL IOCALL            Close the file
[2099] 8D1F 01              BYTE CZCLOS
[2100] 8D20 BD,A3,BE        DST  @RAMTOP,V@NEWTOP  New top of memory
       8D23 80,84
[2101]               * V@OLDTOP : old top of memory, set up above
[2102]               * @STADDR  : base of current program image in ERAM, set abo
[2103] 8D25 06,8D,3C        CALL RELOCA            Relocate the program

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0037 
FLMGR-359
[2104] 8D28 4C,60           BR   OLDZ7             Go to set the RAMFRE and back
[2105]               *                              toplevel
[2106] 8D2A 00,1C,00 PAB3   BYTE >00,>1C,>00,>00,>FE,>00,>00,>00,OFFSET * IV254
       8D2D 00,FE,00
       8D30 00,00,60
[2107]               * OLD error exit code, don't kill machine
[2108] 8D33 06,60,14 OLDER  CALL INITPG            Initialize program space
[2109] 8D36 57,9D           BR   ERRZ2             And take error exit
[2110] 8D38 06,60,22 LRTOPZ CALL KILSYM            Release string space/symbol t
[2111] 8D3B 00              RTN
[2112]               ***********************************************************
[2113]               * RELOCATE THE PROGRAM IMAGE ACCORDING TO THE NEW TOP OF
[2114]               * MEMORY:
[2115]               *         STLN         : old STLN
[2116]               *         ENLN         : old ENLN
[2117]               *         V@OLDTOP     : old top of memory
[2118]               *         V@NEWTOP     : new top of memory
[2119]               *         @STADDR      : current base for the old image
[2120]               ***********************************************************
[2121] 8D3C BD,A3,B4 RELOCA DST  @PABPTR,V@SIZCCP  Save in temp.
       8D3F 04
[2122] 8D40 BD,02,A3        DST  V@OLDTOP,@MNUM    Get the old top of memory
       8D43 BC
[2123] 8D44 BD,04,A3        DST  V@NEWTOP,@PABPTR  Get the new top of memory
       8D47 BE
[2124] 8D48 A5,32,02        DSUB @MNUM,@ENLN       Compute ENLN relative to top
[2125] 8D4B A5,30,02        DSUB @MNUM,@STLN       Compute STLN relative to top
[2126] 8D4E A5,0A,30        DSUB @STLN,@STADDR     Highest memory address used
[2127] 8D51 87,02           DCLR @MNUM             Total # of bytes to be moved
[2128] 8D53 A5,02,30        DSUB @STLN,@MNUM       STLN = -(# bytes -1)
[2129] 8D56 91,02           DINC @MNUM             Take care of that one
[2130] 8D58 A1,32,04        DADD @PABPTR,@ENLN     Compute new address of ENLN
[2131] 8D5B A1,30,04        DADD @PABPTR,@STLN      and STLN
[2132]               * @PABPTR : destination address, @STADDR : source address
[2133] 8D5E BD,5C,02        DST  @MNUM,@ARG        @ARG   : byte count
[2134] 8D61 BD,00,0A        DST  @STADDR,@VAR0     @VAR0  : source addr for MVDN
[2135] 8D64 BD,10,06        DST  @CCPPTR,@VAR5     Save in temp (CCPPTR, VARY2 E
[2136] 8D67 BD,06,04        DST  @PABPTR,@VARY2    @VARY2 : destination addr for
[2137] 8D6A D5,A3,BE        DCEQ @RAMTOP,V@NEWTOP  Relocate the program
       8D6D 80,84
[2138] 8D6F 4D,75           BR   G8D6F              in ERAM
[2139] 8D71 0F,88           XML  MVDN              Move from lower memory to hig
[2140]               *                              memory one byte at a time
[2141] 8D73 4D,84           BR   G8D7E
[2142] 8D75 87,A3,B6 G8D6F  DCLR V@SIZREC          Clear a temporary variable
[2143] 8D78 C1,A3,B6        DEX  @RAMTOP,V@SIZREC  Save the RAMTOP, also fake as
       8D7B 80,84
[2144]               *                         if ERAM not exist for MVDN in thi
[2145] 8D7D 0F,88           XML  MVDN              Move in VDP
[2146] 8D7F C1,A3,B6        DEX  @RAMTOP,V@SIZREC  Restore RAMTOP
       8D82 80,84
[2147] 8D84 BD,06,10 G8D7E  DST  @VAR5,@CCPPTR     Restore back
[2148]               * Update line # links according to new size
[2149] 8D87 BD,02,A3        DST  V@OLDTOP,@MNUM    Old memory top
       8D8A BC
[2150] 8D8B A5,02,A3        DSUB V@NEWTOP,@MNUM    Stop if sizes are same
       8D8E BE
[2151] 8D8F 6D,B9           BS   RELOZ1
[2152] 8D91 BD,0A,30        DST  @STLN,@STADDR     Start relocation at STLN
[2153] 8D94 C9,32,0A OLDZ2  DCHE @STADDR,@ENLN      and continue up to ENLN
[2154] 8D97 4D,B9           BR   RELOZ1
[2155] 8D99 95,0A           DINCT @STADDR          Skip the line #
[2156] 8D9B D4,A3,BE        CEQ  @RAMTOP,V@NEWTOP  If in ERAM
       8D9E 80,84

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0038 
FLMGR-359
[2157] 8DA0 4D,B1           BR   G8DAB
[2158] 8DA2 06,91,AA        CALL GRSUB2            Read the link out
[2159] 8DA5 0A              BYTE STADDR
[2160] 8DA6 A5,58,02        DSUB @MNUM,@EEE1       Update
[2161] 8DA9 06,60,36        CALL GWSUB             Write it back
[2162] 8DAC 0A,58,02        BYTE >0A,>58,>02     * STADDR,EEE1,2
[2163] 8DAF 4D,B5           BR   G8DAF
[2164] 8DB1 A5,B0,0A G8DAB  DSUB @MNUM,V*STADDR    Upadate the link
       8DB4 02
[2165] 8DB5 95,0A    G8DAF  DINCT @STADDR          Skip the link, next line #
[2166] 8DB7 4D,94           BR   OLDZ2             And continue until done
[2167] 8DB9 BD,04,A3 RELOZ1 DST  V@SIZCCP,@PABPTR  Restore from temp
       8DBC B4
[2168] 8DBD 00              RTN
[2169]               ***********************************************************
[2170]               *                    SAVE STATEMENT
[2171]               * SAVE "NAME", MERGE : Save in crunched form in program
[2172]               *  into a file one line at at time with the line number.
[2173]               *  File opened with sequential accessed, variable-length
[2174]               *  records (161 max), display type & output mode, move one
[2175]               *  line number and one in text to the crunch buffer then
[2176]               *  write to the file one line at a time.
[2177]               * A normal SAVE : When ERAM not exist or the size of the
[2178]               *  program and line number table in ERAM can fit in VDP
[2179]               *  (can be moved into VDP from ERAM once), then the save
[2180]               *  statement saves a program image to an external device,
[2181]               *  including all the information the system needs for
[2182]               *  rebuilding the program image on a machine with a
[2183]               *  different memory size, also included is a checksum for
[2184]               *  rudimentary error checking and for PROTECTION VIOLATION
[2185]               * A sequential SAVE : Maximum-length records are performed
[2186]               *  to write the file and each record is copied into the VDP
[2187]               *  from ERAM before it is written.
[2188]               ***********************************************************
[2189] 8DBE DA,45,80 SAVE   CLOG >80,@FLAG         * PROTECTION VIOLATION
[2190] 8DC1 57,E1           BR   ERRPV
[2191] 8DC3 06,92,3B        CALL GPNAME            This will also close all file
[2192]               * Check SAVE "NAME", MERGE or SAVE "NAME", PROTECTED first
[2193] 8DC6 86,A3,B9        CLR  V@SAPROT          Clear "PROTECTED" flag
[2194] 8DC9 0F,79           XML  PGMCHR
[2195] 8DCB 8E,42           CZ   @CHAT             EOL?
[2196] 8DCD 6E,31           BS   SAZ1              Yes, no need to check any opt
[2197] 8DCF D6,42,B3        CEQ  COMMAZ,@CHAT      Has to be a comma here
[2198] 8DD2 41,0F           BR   ERRSYN
[2199] 8DD4 D7,B0,2C        DCEQ >C805,V*PGMPTR    Unquoted string with length 5
       8DD7 C8,05
[2200]               *                              has to be MERGE at this time
[2201] 8DD9 4D,FA           BR   G8DF4
[2202] 8DDB D7,E0,02        DCEQ >4D45,V@2(@PGMPTR) "ME" of MErge
       8DDE 2C,4D,45
[2203]               * RXB PATCH CODE OPTION ADDED IV254 FOR SAVE 2015 *********
[2204]               * SAVE "DSK#.FILENAME",MERGE ! SAVE MERGE FORMAT
[2205]               * SAVE "DSK#.FILENAME",IV254 ! SAVE IV254 PROGRAM FORMAT
[2206]               * SAVE "DSK#.FILENAME" ! NORMAL PROGRAM FORMAT OR IV254
[2207]               *       BR   ERRSYN             If not : SYNTAX ERROR
[2208] 8DE1 58,06           BR    CIV254            CHECK FOR IV254 OPTION
[2209] 8DE3 D7,E0,04        DCEQ >5247,V@4(@PGMPTR) "RG" of meRGe
       8DE6 2C,52,47
[2210] 8DE9 41,0F           BR   ERRSYN             If not : SYNTAX ERROR
[2211] 8DEB D6,E0,06        CEQ  >45,V@6(@PGMPTR)   "E" of mergE
       8DEE 2C,45
[2212] 8DF0 41,0F           BR   ERRSYN             If not : SYNTAX ERROR
[2213] 8DF2 8E,E0,07        CZ   V@7(@PGMPTR)      Check for EOL
       8DF5 2C

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0039 
FLMGR-359
[2214] 8DF6 41,0F           BR   ERRSYN            Not EOL : SYNTAX ERROR
[2215] 8DF8 4F,7C           BR   SAVMG             Go to handle this option
[2216]               * Has to be PROTECTED option here, crunched as unquoted str
[2217] 8DFA D7,B0,2C G8DF4  DCEQ >C809,V*PGMPTR    Unquoted string with length 9
       8DFD C8,09
[2218]               *                              has to be PROTECTED
[2219] 8DFF 41,0F           BR   ERRSYN
[2220] 8E01 D7,E0,02        DCEQ >5052,V@2(@PGMPTR) "PR" of PRotected
       8E04 2C,50,52
[2221] 8E07 41,0F           BR   ERRSYN             If not : SYNTAX ERROR
[2222] 8E09 D7,E0,04        DCEQ >4F54,V@4(@PGMPTR) "OT" of prOTected
       8E0C 2C,4F,54
[2223] 8E0F 41,0F           BR   ERRSYN             If not : SYNTAX ERROR
[2224] 8E11 D7,E0,06        DCEQ >4543,V@6(@PGMPTR) "EC" of protECted
       8E14 2C,45,43
[2225] 8E17 41,0F           BR   ERRSYN             If not : SYNTAX ERROR
[2226] 8E19 D7,E0,08        DCEQ >5445,V@8(@PGMPTR) "TE",of protecTEd
       8E1C 2C,54,45
[2227] 8E1F 41,0F           BR   ERRSYN             If not : SYNTAX ERROR
[2228] 8E21 D6,E0,0A        CEQ  >44,V@10(@PGMPTR)  "D" of protecteD
       8E24 2C,44
[2229] 8E26 41,0F           BR   ERRSYN             If not : SYNTAX ERROR
[2230] 8E28 8E,E0,0B        CZ   V@11(@PGMPTR)     Check EOL
       8E2B 2C
[2231] 8E2C 41,0F           BR   ERRSYN
[2232] 8E2E 90,A3,B9        INC  V@SAPROT
[2233]               ***********************************************************
[2234] 8E31 8E,80,84 SAZ1   CZ   @RAMTOP           If ERAM NOT present then
[2235] 8E34 4E,48           BR   G8E42
[2236]               ***** CLEAR THE BREAKPOINT IN VDP ALONE TO SPEED UP *******
[2237] 8E36 BD,52,30        DST  @STLN,@FAC8       End of line # buffer
[2238] 8E39 B2,B0,52 G8E33  AND  >7F,V*FAC8        Clear the breakpoint
       8E3C 7F
[2239] 8E3D A3,52,00        DADD 4,@FAC8           Move to the next one
       8E40 04
[2240] 8E41 C5,52,32        DCH  @ENLN,@FAC8       Until done
[2241] 8E44 4E,39           BR   G8E33
[2242] 8E46 4E,6F           BR   VSAVZ
[2243] 8E48 06,A0,20 G8E42  CALL UBSUB             Clear the breakpoint in ERAM
[2244] 8E4B BD,02,80        DST  @RAMTOP,@MNUM     Top of memory in ERAM
       8E4E 84
[2245] 8E4F A5,02,30        DSUB @STLN,@MNUM
[2246] 8E52 91,02           DINC @MNUM             # of bytes total in ERAM
[2247] 8E54 BD,00,70        DST  @HIVDP,@VAR0      Top of memory in VDP
[2248] 8E57 A5,00,02        DSUB @MNUM,@VAR0
[2249] 8E5A 91,00           DINC @VAR0
[2250]               * Check is there enough memory in VDP to move the program
[2251]               *  text and line number table from ERAM to VDP
[2252] 8E5C 0A              GT                  Not enough memory in VDP for sur
[2253] 8E5D 4E,BD           BR   GSAVE
[2254] 8E5F BF,10,0A        DST  VRAMVS+64+256,@VAR5 * 64 bytes are for safety b
       8E62 98
[2255]                
[2256]               * DSR routine give file error when loading a program which
[2257]               *  VDP maximum size and was saved from VDP to be a program
[2258]               *  on disk when ERAM not exist. In order to fix this proble
[2259]               *  restrict the program memory to be 256 bytes less then th
[2260]               *  real space in VDP when ERAM not exist.
[2261] 8E63 C9,00,10        DCHE @VAR5,@VAR0       Not enough memory in VDP, do
[2262]               *                              sequential file save
[2263] 8E66 4E,BD           BR   GSAVE
[2264] 8E68 A7,10,00        DSUB 10,@VAR5        * 10 bytes for control informat
       8E6B 0A
[2265] 8E6C 06,8F,50        CALL GVMOV             Enough memory in VDP, move it

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0040 
FLMGR-359
[2266]               *                             over and do the normal save l
[2267]               **************** Without ERAM, or after GVMOV *************
[2268]               **************** do the normal save           *************
[2269] 8E6F BD,0A,40 VSAVZ  DST  @FREPTR,@STADDR   Store additional control info
[2270] 8E72 93,0A           DDEC @STADDR           Back up some more for 2 byte
[2271] 8E74 BD,B0,0A        DST  @>8370,V*STADDR   First current top of memory
       8E77 70
[2272] 8E78 97,0A           DDECT @STADDR
[2273] 8E7A BD,B0,0A        DST  @STLN,V*STADDR    Then STLN
       8E7D 30
[2274] 8E7E 97,0A           DDECT @STADDR
[2275] 8E80 BD,B0,0A        DST  @ENLN,V*STADDR    Then ENLN
       8E83 32
[2276] 8E84 97,0A           DDECT @STADDR          Then
[2277] 8E86 BD,B0,0A        DST  @STLN,V*STADDR
       8E89 30
[2278] 8E8A B9,B0,0A        DXOR @ENLN,V*STADDR    STLN XORed with ENLN
       8E8D 32
[2279] 8E8E D6,A3,B9        CEQ  1,V@SAPROT        Check is there PROTECTED opti
       8E91 01
[2280] 8E92 4E,97           BR   G8E91
[2281] 8E94 83,B0,0A        DNEG V*STADDR          Negate the CHECKSUM to indica
[2282]               *                             LIST/EDIT protection
[2283] 8E97 BD,E0,06 G8E91  DST  @STADDR,V@BUF(@PABPTR)  Save start address in P
       8E9A 04,0A
[2284] 8E9C 93,0A           DDEC @STADDR
[2285] 8E9E BD,E0,0A        DST  @>8370,V@RNM(@PABPTR)   Compute # of bytes used
       8EA1 04,70
[2286] 8EA3 A5,E0,0A        DSUB @STADDR,V@RNM(@PABPTR)   and store that in PAB
       8EA6 04,0A
[2287] 8EA8 8E,80,84        CZ   @RAMTOP           If ERAM exists then
[2288] 8EAB 6E,B3           BS   G8EAD
[2289] 8EAD BD,30,0C        DST  @BBB1,@STLN       Restore the original STLN, EN
[2290] 8EB0 BD,32,08        DST  @CCC1,@ENLN        which points to ERAM
[2291] 8EB3 06,97,64 G8EAD  CALL IOCALL            Call Device Service Routine f
[2292] 8EB6 06              BYTE CZSAVE          * SAVE operation
[2293] 8EB7 06,60,22 LRTOPL CALL KILSYM            Release string space/symbol t
[2294] 8EBA 05,60,12        B    TOPL15            Go back to toplevel
[2295]               ***********************************************************
[2296]               * Open the sequential file, set the PAB
[2297]               * File type             : sequential file
[2298]               * Mode of operation     : output
[2299]               * Data type             : internal
[2300]               * Record type           : variable length records
[2301]               * Logical record length : 254 maximum
[2302] 8EBD 31,00,09 GSAVE  MOVE 9,G@PAB3,V@4(@PABPTR) Build the PAB
       8EC0 E0,04,04
       8EC3 8D,2A
[2303] 8EC5 96,E0,05        DECT V@FLG(@PABPTR)    Put in the correct I/O mode :
       8EC8 04
[2304]               * Compute the data buffer address
[2305] 8EC9 BD,4A,70        DST  @>8370,@FAC
[2306] 8ECC A7,4A,00        DSUB 253,@FAC
       8ECF FD
[2307] 8ED0 BD,E0,06        DST  @FAC,V@BUF(@PABPTR)
       8ED3 04,4A
[2308] 8ED5 BD,58,4A        DST  @FAC,@EEE1     Save it for later use in GVWITE
[2309] 8ED8 06,97,71        CALL CDSR           Call device service routine to o
[2310] 8EDB 57,9A           BR   ERRZ2B         Return with ERROR indication in
[2311]               *                          Put 8 bytes control info at the
[2312]               *                          beginning of the data buffer
[2313] 8EDD BF,B0,4A        DST  >ABCD,V*FAC       >ABCD indentifies a program f
       8EE0 AB,CD
[2314] 8EE2 95,4A           DINCT @FAC              when doing LOAD later

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0041 
FLMGR-359
[2315] 8EE4 BD,B0,4A        DST  @STLN,V*FAC       Save STLN in control info
       8EE7 30
[2316] 8EE8 95,4A           DINCT @FAC
[2317] 8EEA BD,B0,4A        DST  @ENLN,V*FAC       ENLN too
       8EED 32
[2318] 8EEE 95,4A           DINCT @FAC
[2319] 8EF0 BD,B0,4A        DST  @STLN,V*FAC
       8EF3 30
[2320] 8EF4 B9,B0,4A        DXOR @ENLN,V*FAC       Save the checksum
       8EF7 32
[2321] 8EF8 D6,A3,B9        CEQ  1,V@SAPROT        Check is there PROTECTED opti
       8EFB 01
[2322] 8EFC 4F,01           BR   G8EFB
[2323] 8EFE 83,B0,4A        DNEG V*FAC             Negate the CHECKSUM to indica
[2324]               *                              the LIST/EDIT protection
[2325] 8F01 95,4A    G8EFB  DINCT @FAC
[2326] 8F03 BD,B0,4A        DST  @RAMTOP,V*FAC     Save the top of memory info
       8F06 80,84
[2327] 8F08 BE,E0,09        ST   10,V@CNT(@PABPTR) Set the caracter count in PAB
       8F0B 04,0A
[2328] 8F0D 06,97,64        CALL IOCALL            Call device service routine
[2329] 8F10 03              BYTE CZWRIT          * With I/O opcode : write, to s
[2330]               *                       the control info for the first reco
[2331]               * Now start to use maximum-length record to write the file
[2332]               * and each record is copied into the VDP from ERAM bofore i
[2333]               * is written
[2334] 8F11 BD,54,30        DST  @STLN,@DDD1       Starting address on ERAM
[2335]               *      DST  @>8370,@EEE1      @EEE1 has been set up before
[2336]               *      DST  253,@EEE1         Starting address of the data
[2337]               *                              buffer on VDP
[2338] 8F14 BD,08,80        DST  @RAMTOP,@CCC1
       8F17 84
[2339] 8F18 A5,08,30        DSUB @STLN,@CCC1
[2340] 8F1B 91,08           DINC @CCC1
[2341] 8F1D BE,E0,09        ST   254,V@CNT(@PABPTR) Set the character count of P
       8F20 04,FE
[2342] 8F22 BF,56,00 G8F1C  DST  254,@FFF1         @FFF1 byte count
       8F25 FE
[2343] 8F26 0F,8B           XML  GVWITE            Move data from ERAM to VDP
[2344] 8F28 06,97,64        CALL IOCALL            Call device service routine
[2345] 8F2B 03              BYTE CZWRIT
[2346] 8F2C A3,54,00        DADD 254,@DDD1         Update the source addr on ERA
       8F2F FE
[2347] 8F30 A7,08,00        DSUB 254,@CCC1         # of bytes left to move
       8F33 FE
[2348] 8F34 6F,4A           BS   GSAV1             No more bytes to save
[2349] 8F36 CB,08,00        DCHE 254,@CCC1         Leave the last record alone
       8F39 FE
[2350] 8F3A 6F,22           BS   G8F1C
[2351]               * Move the last @CCC1 bytes from ERAM to VDP
[2352] 8F3C BD,56,08        DST  @CCC1,@FFF1       @FFF1 : Byte count
[2353] 8F3F 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[2354] 8F41 BC,E0,09        ST   @CCC1+1,V@CNT(@PABPTR) Update the character cou
       8F44 04,09
[2355]               *                                   in PAB
[2356] 8F46 06,97,64        CALL IOCALL            Call device service routine
[2357] 8F49 03              BYTE CZWRIT
[2358] 8F4A 06,97,64 GSAV1  CALL IOCALL
[2359] 8F4D 01              BYTE CZCLOS          * Close the file
[2360] 8F4E 4E,B7           BR   LRTOPL            Continue
[2361]               ***********************************************************
[2362]               * Move the program text & line # table to VDP, and relocate
[2363] 8F50 BD,0C,30 GVMOV  DST  @STLN,@BBB1       Save STLN, ENLN for later use
[2364] 8F53 BD,08,32        DST  @ENLN,@CCC1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0042 
FLMGR-359
[2365] 8F56 BD,54,30        DST  @STLN,@DDD1       Source addr on ERAM
[2366] 8F59 BD,58,10        DST  @VAR5,@EEE1       Destination addr on VDP
[2367] 8F5C BD,0A,58        DST  @EEE1,@STADDR     Use later for RELOCA
[2368] 8F5F BD,56,80        DST  @RAMTOP,@FFF1
       8F62 84
[2369] 8F63 A5,56,30        DSUB @STLN,@FFF1       # of bytes to move
[2370] 8F66 91,56           DINC @FFF1             @FFF1 : byte count for GVWITE
[2371] 8F68 0F,8B           XML  GVWITE            Move from ERAM to VDP
[2372] 8F6A BD,A3,BC        DST  @RAMTOP,V@OLDTOP  Set up @RAMTOP for old top
       8F6D 80,84
[2373]               *                             of memory
[2374] 8F6F BD,A3,BE        DST  @>8370,V@NEWTOP   Set up @>8370 for new top
       8F72 70
[2375]               *                             of memory
[2376] 8F73 06,8D,3C        CALL RELOCA            Relocate the program
[2377] 8F76 BD,40,30        DST  @STLN,@FREPTR     Set up @FREPTR
[2378] 8F79 93,40           DDEC @FREPTR
[2379] 8F7B 00              RTN
[2380]               ***********************************************************
[2381]               * Save the crunched form of a program into a file.
[2382]               * Move the line number and text to the crunch buffer, then
[2383]               * write to the file one line at a time.
[2384]               ***********************************************************
[2385]               * Open the file with:
[2386]               *  I/O opcode            : OPEN
[2387]               *  File type             : SEQUENTIAL file
[2388]               *  Mode of operation     : OUTPUT
[2389]               *  Data type             : DISPLAY type data
[2390]               *  Record type           : VARIABLE LENGTH records
[2391]               *  Data buffer address   : Crunch buffer address
[2392]               *  Logical record length : 163 (length of curnch buffer + 2
[2393]               *                                bytes for line #) maximum
[2394] 8F7C 31,00,09 SAVMG  MOVE 9,G@PAB1,V@4(@PABPTR) Build PAB
       8F7F E0,04,04
       8F82 8F,FF
[2395] 8F84 06,97,6B        CALL IOCLZ1         Call the DSR routine to open fil
[2396] 8F87 BD,50,32        DST  @ENLN,@FAC6    Start from the first line #
[2397] 8F8A A7,50,00        DSUB 3,@FAC6        @FAC6 now points to the 1st line
       8F8D 03
[2398]               *                          Write to the file from crunch bu
[2399]               *                           one line at a time
[2400] 8F8E 86,00    G8F88  CLR  @VAR0             Make it a two byte later
[2401] 8F90 8E,80,84        CZ   @RAMTOP           If ERAM exists then
[2402] 8F93 6F,BC           BS   G8FB6
[2403] 8F95 BD,54,50        DST  @FAC6,@DDD1       Write the 4 bytes (line # and
[2404]               *                              line pointer) from ERAM to
[2405]               *                              crunch buffer
[2406]               *                             @DDD1 : Source address on ERA
[2407] 8F98 BF,58,08        DST  CRNBUF,@EEE1      @EEE1 : Destination address
       8F9B 20
[2408]               *                                      on VDP
[2409] 8F9C BF,56,00        DST  4,@FFF1           @FFF1 : byte count
       8F9F 04
[2410] 8FA0 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[2411] 8FA2 BD,54,A8        DST  V@CRNBUF+2,@DDD1  Line pointer now points to
       8FA5 22
[2412]               *                              length byte
[2413] 8FA6 93,54           DDEC @DDD1             Get the length of this line
[2414]               *                             @DDD1 : Source address on ERA
[2415] 8FA8 91,56           DINC @FFF1             @FFF1 : Byte count, coming ba
[2416]               *                                     from GVWITE above, =0
[2417] 8FAA 0F,8C           XML  GREAD1            Read the length byte from ERA
[2418] 8FAC BC,01,58        ST   @EEE1,@VAR0+1     @EEE1 : Destination addr on C
[2419] 8FAF BF,58,08        DST  CRNBUF+2,@EEE1    Write the text from ERAM to 3

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0043 
FLMGR-359
       8FB2 22
[2420]               *                             byte of crunch buffer
[2421]               *                             @EEE1 : Destination addr on V
[2422]               *                             @DDD1 : Source addr on ERAM
[2423] 8FB3 91,54           DINC @DDD1             Back to point to the text
[2424] 8FB5 BD,56,00        DST  @VAR0,@FFF1       @FFF1 : Byte count
[2425] 8FB8 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[2426] 8FBA 4F,D3           BR   G8FCD             ERAM not exist : line # table
[2427]               *                              and text in VDP
[2428] 8FBC BD,A8,20 G8FB6  DST  V*FAC6,V@CRNBUF   PUT THE LINE # IN
       8FBF B0,50
[2429] 8FC1 BD,4C,E0        DST  V@2(@FAC6),@FAC2  Get the line pointer out
       8FC4 02,50
[2430] 8FC6 93,4C           DDEC @FAC2             Line pointer now points to th
[2431]               *                              length byte
[2432] 8FC8 BC,01,B0        ST   V*FAC2,@VAR0+1    Get the length out
       8FCB 4C
[2433]               * Move the text into the crunch buffer
[2434] 8FCC 34,00,A8        MOVE @VAR0,V@1(@FAC2),V@CRNBUF+2
       8FCF 22,E0,01
       8FD2 4C
[2435] 8FD3 B2,A8,20 G8FCD  AND  >7F,V@CRNBUF      Reset possible breakpoint
       8FD6 7F
[2436] 8FD7 95,00           DINCT @VAR0    * Total length=text length+line # len
[2437] 8FD9 BC,E0,09        ST   @VAR0+1,V@CNT(@PABPTR) Store in the cahracter c
       8FDC 04,01
[2438] 8FDE 06,97,64        CALL IOCALL            Call the device service routi
[2439] 8FE1 03              BYTE CZWRIT          * Write
[2440] 8FE2 A7,50,00        DSUB 4,@FAC6           Go to the next line #
       8FE5 04
[2441] 8FE6 C9,50,30        DCHE @STLN,@FAC6       Finish moving all
[2442] 8FE9 6F,8E           BS   G8F88
[2443] 8FEB BF,A8,20        DST  >FFFF,V@CRNBUF    Set up a EOF for the last rec
       8FEE FF,FF
[2444] 8FF0 BE,E0,09        ST   2,V@CNT(@PABPTR)  Only write this 2 bytes
       8FF3 04,02
[2445] 8FF5 06,97,64        CALL IOCALL            Call the device service routi
[2446] 8FF8 03              BYTE CZWRIT          * Write
[2447] 8FF9 06,97,64        CALL IOCALL            Call the device service routi
[2448] 8FFC 01              BYTE CZCLOS          * Close the file
[2449] 8FFD 4E,B7           BR   LRTOPL            Go back to top level
[2450] 8FFF 00,12,08 PAB1   BYTE >00,>12,>08,>20,>A3,>00,>00,>00,>60 * DV163
       9002 20,A3,00
       9005 00,00,60
[2451]               *           >0820 = CRNBUF
[2452]               *           >A3   = 163
[2453]               *           >60   = OFFSET
[2454]               ***********************************************************
[2455]               *                   MERGE ROUTINE
[2456]               * MERGE load a file which is in crunched program form into
[2457]               * the CRNBUF one record (one in) at a time then take the
[2458]               * line # out in FAC, text length into @CHAT, and edit it
[2459]               * into the program. Identify EOF by the last record which
[2460]               * is set up at SAVE time.
[2461]               ***********************************************************
[2462] 9008 06,92,3B MERGE  CALL GPNAME            Close all file, set up PAB
[2463] 900B DA,45,80        CLOG >80,@FLAG         Check PROTECTION VIOLATION
[2464] 900E 57,E1           BR   ERRPV
[2465]               * To fix the bug #06 in MERGE
[2466] 9010 0F,79           XML  PGMCHR            Check EOL
[2467] 9012 8E,42           CZ   @CHAT
[2468] 9014 41,0F           BR   ERRSYN            Not EOL : SYNTAX ERROR
[2469]               * Open the file with
[2470]               *  I/O opcode            : OPEN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0044 
FLMGR-359
[2471]               *  File type             : SEQUENTIAL file
[2472]               *  Mode of operation     : INPUT
[2473]               *  Data type             : DISPLAY type data
[2474]               *  Record type           : VARIABLE LENGTH records
[2475]               *  Data buffer address   : crunch address
[2476]               *  Logical record length : 163 maximum
[2477] 9016 31,00,09        MOVE 9,G@PAB1,V@4(@PABPTR)  Set up PAB
       9019 E0,04,04
       901C 8F,FF
[2478] 901E 94,E0,05        INCT V@FLG(@PABPTR)    Put in correct I/O mode : >14
       9021 04
[2479] 9022 06,97,6B        CALL IOCLZ1            Call the device service routi
[2480]               *                              to open the file
[2481] 9025 06,97,64        CALL IOCALL            Call the device service routi
[2482] 9028 02              BYTE CZREAD          *  to read
[2483] 9029 D7,A8,20        DCEQ >FFFF,V@CRNBUF    If 1st rec is EOF
       902C FF,FF
[2484] 902E 77,9A           BS   ERRZ2B
[2485] 9030 87,80,D6 G902A  DCLR @>83D6            Read in one line and edit it
[2486]               *                              program
[2487] 9033 BC,42,E0        ST   V@CNT(@PABPTR),@CHAT Length of this record
       9036 09,04
[2488] 9038 96,42           DECT @CHAT             Text length = total length-2
[2489]               *                                          (line # length)
[2490]               *                              Put it in @CHAT for EDITLN
[2491] 903A BD,4A,A8        DST  V@CRNBUF,@FAC     Put the line # in @FAC for ED
       903D 20
[2492] 903E 86,56           CLR  @FAC12            Make it a double byte
[2493] 9040 BC,57,42        ST   @CHAT,@FAC13
[2494]               * Move the text up 2 bytes
[2495] 9043 34,56,A8        MOVE @FAC12,V@CRNBUF+2,V@CRNBUF
       9046 20,A8,22
[2496] 9049 BD,A3,B8        DST  @PABPTR,V@MRGPAB  SAVE PAB POINTER
       904C 04
[2497] 904D 06,60,32        CALL EDITLN            EDIT IT TO THE PROGRAM
[2498] 9050 87,04           DCLR @PABPTR           Clear temporary PAB pointer
[2499] 9052 C1,04,A3        DEX  V@MRGPAB,@PABPTR  Restore old PAB pointer
       9055 B8
[2500] 9056 06,97,64        CALL IOCALL            CALL THE DEVICE SERVICE ROUTI
[2501] 9059 02              BYTE CZREAD          *  read another record or anoth
[2502]               *                              line
[2503] 905A D7,A8,20        DCEQ >FFFF,V@CRNBUF    End of EOF
       905D FF,FF
[2504] 905F 50,30           BR   G902A
[2505]               * Double check EOF record
[2506] 9061 D6,E0,09 MERGZ1 CEQ  2,V@CNT(@PABPTR)  I/O ERROR
       9064 04,02
[2507] 9066 57,9A           BR   ERRZ2B
[2508] 9068 06,97,64        CALL IOCALL            Call the device service routi
[2509] 906B 01              BYTE CZCLOS          *  close the file
[2510] 906C 4E,B7           BR   LRTOPL            Go back to top level
[2511]               ***********************************************************
[2512]               *                  LIST ROUTINE
[2513]               * List lists a readable copy of the current program imnage
[2514]               * to the specified device. In case no device is specified,
[2515]               * the listing is copied to the screen.
[2516]               *  This routine uses the fact that ERRZZ returns to the
[2517]               * caller if the call has been issued in EDIT which will
[2518]               * reinitiate the variable stuff.
[2519]               ***********************************************************
[2520] 906E DA,45,80 LIST   CLOG >80,@FLAG         PROTECTION VILOATION ERROR  <
[2521] 9071 57,E1           BR   ERRPV                                         <
[2522] 9073 87,14           DCLR @CURLIN           Create some kind of control <
[2523] 9075 87,0E           DCLR @CURINC            for defaults               <

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0045 
FLMGR-359
[2524] 9077 BE,08,2D        ST   MINUS,@VARC       Select "-" as separator     <
[2525]               * GKXB GKLIST label
[2526] 907A 06,7A,06        CALL GTLIST            GKXB pick up length
[2527]               * If either CURLIN or CURINC is non-zero, use it
[2528]               * For zero values replace the default (ENLN-3, STLN)
[2529] 907D 8F,14           DCZ  @CURLIN
[2530] 907F 50,9A           BR   G9094
[2531] 9081 BD,54,32        DST  @ENLN,@DDD1       Get the first lines line #
[2532] 9084 A7,54,00        DSUB 3,@DDD1           DDD1 : Source address on ERAM
       9087 03
[2533] 9088 06,91,C2        CALL GRSUB3            Read the line # from ERAM/VDP
[2534] 908B 54              BYTE DDD1            * @DDD1 : Source address on ERA
[2535]               *                             Reset possible breakpoint too
[2536] 908C BD,14,58        DST @EEE1,@CURLIN      Use standard default
[2537] 908F 8F,0E           DCZ @CURINC
[2538] 9091 50,9A           BR  G9094
[2539] 9093 06,91,C2 LISTZ0 CALL GRSUB3            Read last line # from ERAM/VD
[2540] 9096 30              BYTE STLN           *  @STLN : Source address on ERA
[2541]               *                             Reset possible breakpoint too
[2542] 9097 BD,0E,58        DST  @EEE1,@CURINC     @EEE1 : Destination address o
[2543]               *                             Also default for end line
[2544]               * Now first evaluate what we've got in CURLIN
[2545] 909A 8F,0E    G9094  DCZ  @CURINC           Check for combination xxx-
[2546] 909C 50,AC           BR   G90A6
[2547] 909E 93,20    G9098  DDEC @VARW             Backup to the separation mark
[2548] 90A0 D6,B0,20        CEQ  SPACE+OFFSET,V*VARW
       90A3 80
[2549] 90A4 70,9E           BS   G9098
[2550] 90A6 D6,B0,20        CEQ  MINUS+OFFSET,V*VARW Select last
       90A9 8D
[2551] 90AA 70,93           BS   LISTZ0
[2552] 90AC C9,0E,14 G90A6  DCHE @CURLIN,@CURINC   If something like LIST 15-11
[2553] 90AF 70,B4           BS   G90AE
[2554] 90B1 BD,0E,14        DST  @CURLIN,@CURINC   Replace byt LIST 15-15
[2555] 90B4 BD,4A,14 G90AE  DST  @CURLIN,@FAC      Prepare for line # search
[2556] 90B7 0F,7E           XML  SPEED             Search the line number table
[2557] 90B9 03              BYTE SEETWO
[2558] 90BA BD,14,2E        DST  @EXTRAM,@CURLIN   Get first real line # in CURL
[2559] 90BD BD,4A,0E        DST  @CURINC,@FAC
[2560] 90C0 0F,7E           XML  SPEED
[2561] 90C2 03              BYTE SEETWO          * Evaluate second line #
[2562] 90C3 06,91,C2        CALL GRSUB3            Read 2 bytes of data from ERA
[2563] 90C6 2E              BYTE EXTRAM          * @EXTRAM : Source addr on ERAM
[2564]               *                             Reset possible breakpoint too
[2565] 90C7 C5,58,0E        DCH  @CURINC,@EEE1
[2566] 90CA 50,D0           BR   G90CA
[2567] 90CC A3,2E,00        DADD 4,@EXTRAM         Else take next lower line
       90CF 04
[2568] 90D0 BD,0E,2E G90CA  DST  @EXTRAM,@CURINC   Which could be equal to CURLI
[2569] 90D3 BD,2E,14        DST  @CURLIN,@EXTRAM   For use below by LIST
[2570] 90D6 93,2C           DDEC @PGMPTR           Backup to last CHAT
[2571] 90D8 0F,79           XML  PGMCHR            Retrieve last CHAT
[2572] 90DA 8E,42           CZ   @CHAT             Device name available
[2573] 90DC 71,38           BS   G9132
[2574] 90DE 06,81,FA        CALL CLSALL            Close all files that are open
[2575] 90E1 BF,6E,09        DST  VRAMVS,@VSPTR     Re-initialize the V-stack
       90E4 58
[2576] 90E5 BD,24,6E        DST  @VSPTR,@STVSPT    And it's base
[2577] 90E8 0F,79           XML  PGMCHR            Get name length in CHAT
[2578] 90EA BF,04,09        DST  VRAMVS+16,@PABPTR Get entrypoint in PAB
       90ED 68
[2579] 90EE 86,17           CLR  @DSRFLG           Indicate device I/O
[2580] 90F0 31,00,09        MOVE 9,G@PAB,V@4(@PABPTR)
       90F3 E0,04,04

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0046 
FLMGR-359
       90F6 91,76
[2581] 90F8 BF,08,09        DST  VRAMVS+16+NLEN,@CCPADR Select start address
       90FB 75
[2582]               *                                   for copy
[2583]               * GKXB GTLENGTH label
[2584] 90FC 06,97,F3        CALL GTLENG            GKXB Set length in PAB
[2585] 90FF 90,4C           INC  @FAC2             Plus length byte
[2586] 9101 BC,B0,08 LISTZ1 ST   @CHAT,V*CCPADR    Copy the bytes one by one
       9104 42
[2587] 9105 0F,79           XML  PGMCHR            Get next character
[2588] 9107 91,08           DINC @CCPADR           CCPADR ends up with highest a
[2589] 9109 92,4C           DEC  @FAC2             Count total # of characters
[2590] 910B 51,01           BR   LISTZ1
[2591] 910D 06,97,6B        CALL IOCLZ1            Preform OPEN on DSR
[2592] 9110 86,4A           CLR  @FAC              Create double byte PAB length
[2593] 9112 BC,07,E0        ST   V@LEN(@PABPTR),@RECLEN Get record length
       9115 08,04
[2594] 9117 BC,4B,07        ST   @RECLEN,@FAC1     Get highest address used
[2595] 911A A1,4A,08        DADD @CCPADR,@FAC      Compute record length
[2596] 911D BD,E0,06        DST  @CCPADR,V@BUF(@PABPTR) Store it
       9120 04,08
[2597] 9122 8E,80,84        CZ   @RAMTOP           If ERAM exists then
[2598] 9125 71,2E           BS   G9128
[2599] 9127 C5,4A,70        DCH  @>8370,@FAC       Compare with top of
[2600]               *                    VDP : if higher then 'not enough room'
[2601] 912A 77,C1           BS   ERRIO
[2602] 912C 51,33           BR   G912D
[2603] 912E C5,4A,30 G9128  DCH  @STLN,@FAC        Not enough room
[2604] 9131 77,C1           BS   ERRIO
[2605] 9133 BE,06,01 G912D  ST   1,@CCPPTR         Clear first line in output
[2606] 9136 51,3E           BR   G9138
[2607] 9138 BE,7F,1F G9132  ST   VWIDTH+3,@XPT     For common code usage
[2608] 913B 06,97,45        CALL INITKB            Reset current record length
[2609] 913E 8E,80,84 G9138  CZ   @RAMTOP           If ERAM exist then
[2610] 9141 71,46           BS   G9140
[2611] 9143 06,91,7F        CALL GRMLST            Fake it : move each line to t
[2612]               *                              CRUNCH buffer form ERAM
[2613] 9146 06,6A,74 G9140  CALL LLIST             List the current line
[2614] 9149 03              SCAN                   Test for a break key
[2615] 914A 51,54           BR   LISTZ3            No key
[2616] 914C D6,75,02        CEQ  BREAK,@RKEY
[2617] 914F 71,65           BS   LISTZ4
[2618] 9151 03       LISTZ5 SCAN
[2619] 9152 51,51           BR   LISTZ5
[2620] 9154 8E,80,84 LISTZ3 CZ   @RAMTOP           If ERAM exists
[2621] 9157 71,5C           BS   G9156
[2622] 9159 BD,2E,58        DST  @FAC14,@EXTRAM    Restore the @EXTRAM
[2623] 915C A7,2E,00 G9156  DSUB 4,@EXTRAM         Pointer to next line
       915F 04
[2624] 9160 C5,0E,2E        DCH  @EXTRAM,@CURINC   Display all lines in range
[2625] 9163 51,3E           BR   G9138
[2626] 9165 8E,17    LISTZ4 CZ   @DSRFLG           Device I/O -> output last rec
[2627] 9167 51,73           BR   G916D
[2628] 9169 06,96,AB        CALL OUTREC            Output the last record
[2629] 916C 06,97,64        CALL IOCALL            Close the device properly
[2630] 916F 01              BYTE CZCLOS
[2631] 9170 05,60,1A        B    TOPL10
[2632] 9173 05,60,12 G916D  B    TOPL15            Restart the variable too
[2633]               * PAB image used in LIST function
[2634] 9176 00,12,00 PAB    BYTE 0,>12,0,0,0,0,0,0,OFFSET
       9179 00,00,00
       917C 00,00,60
[2635]               * Move each line in ERAM to CRNBUF area, put line number in
[2636]               * (CRNBUF), put CRNBUF+4 in (CRNBUF+2) which is the line

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0047 
FLMGR-359
[2637]               * pointer field, put the text itself from ERAM to (CRNBUF+4
[2638]               * before call LLIST, trick it by moving CRNBUF to @EXTRAM
[2639] 917F 06,91,C2 GRMLST CALL GRSUB3            Get line # from ERAM(use GREA
[2640] 9182 2E              BYTE EXTRAM          * @EXTRAM : Source address on E
[2641]               *                             Reset possible breakpoint too
[2642] 9183 BD,A8,20        DST  @EEE1,V@CRNBUF    Put it in CRNBUF
       9186 58
[2643] 9187 BF,A8,22        DST  CRNBUF+4,V@CRNBUF+2 Put CRNBUF+4 into
       918A 08,24
[2644]               *                              the line pointer field
[2645] 918C 95,54           DINCT @DDD1            Get the pointer to the text
[2646]               *                              from GRAM
[2647] 918E 06,91,B0        CALL GRSUB4            Read the line pointer in (use
[2648]               *                              GREAD1)
[2649] 9191 93,58           DDEC @EEE1             Get the ptr to the length byt
[2650] 9193 06,91,AA        CALL GRSUB2            Read th length from ERAM, use
[2651] 9196 58              BYTE EEE1           *   GREAD1, @EEE1 : Source addre
[2652]               *                               on ERAM
[2653] 9197 BC,57,58        ST   @EEE1,@FFF1+1     Use the length as byte count
[2654]               *                             to move the text from ERAM to
[2655]               *                             VDP CRNBUF+4 area
[2656] 919A BF,58,08        DST  CRNBUF+4,@EEE1    EEE1 : Destination address on
       919D 24
[2657] 919E 91,54           DINC @DDD1             DDD1 : Source address on ERAM
[2658] 91A0 0F,8B           XML  GVWITE            Move data from ERAM to VDP
[2659] 91A2 BD,58,2E        DST  @EXTRAM,@FAC14    Save for later use
[2660] 91A5 BF,2E,08        DST  CRNBUF,@EXTRAM    Fake it
       91A8 20
[2661] 91A9 00              RTN
[2662]               * SUBROUTINE TO READ 2 BYTES OF DATA FROM ERAM OR VDP WITH
[2663]               * THE OPTION TO RESET THE POSSIBLE BREAKPOINT
[2664] 91AA 88,56    GRSUB2 FETCH @FFF1            Fetch the source address on
[2665] 91AC BD,54,90        DST  *FFF1,@DDD1        ERAM or VDP
       91AF 56
[2666]                
[2667]               *                             @DDD1 : Source addr  on ERAM
[2668]               *                             or VDP
[2669] 91B0 8E,80,84 GRSUB4 CZ   @RAMTOP           If ERAM exists
[2670] 91B3 71,BD           BS   G91B7
[2671] 91B5 BF,56,00        DST  2,@FFF1           @FFF1 : Byte count
       91B8 02
[2672] 91B9 0F,8C           XML  GREAD1            Read data from ERAM to CPU
[2673] 91BB 51,C1           BR   G91BB
[2674] 91BD BD,58,B0 G91B7  DST  V*DDD1,@EEE1      Read data from VDP to CPU
       91C0 54
[2675] 91C1 00       G91BB  RTN
[2676] 91C2 88,56    GRSUB3 FETCH @FFF1            Fetch the source addr on ERAM
[2677] 91C4 BD,54,90        DST  *FFF1,@DDD1        or VDP
       91C7 56
[2678]               *                             @DDD1 : Source addr on ERAM/V
[2679] 91C8 06,91,B0        CALL GRSUB4            Do the actual read
[2680] 91CB B3,58,7F        DAND >7FFF,@EEE1       Reset possible breakpoint
       91CE FF
[2681] 91CF 00              RTN
[2682]               *********** REC ROUTINE ***********************************
[2683]               * REC(X) returns the current record to which file X is
[2684]               *  positioned.
[2685] 91D0 BD,5C,04 SUBREC DST  @PABPTR,@ARG      Save the current PAB & set ne
[2686] 91D3 06,92,24        CALL SUBEOF            Try to find the correct PAB
[2687] 91D6 C1,5C,04        DEX  @PABPTR,@ARG      @ARG : new PAB
[2688]               *                             @PABPTR : restore current PAB
[2689] 91D9 52,18           BR   EOFZ2             Didn't find the corresponding
[2690] 91DB BD,4A,E0        DST  V@RNM(@ARG),@FAC  Obtain integer record number
       91DE 0A,5C

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0048 
FLMGR-359
[2691] 91E0 0F,80           XML  CIF               Convert integer to floating
[2692] 91E2 0F,75           XML  CONT               and continue
[2693]               ***********************************************************
[2694]               *                         EOF ROUTINE
[2695]               * EOF(X) returns status codes on file X. The meaning of the
[2696]               * result codes is:
[2697]               *           -1  Physical End Of File
[2698]               *            0  Not at End Of File yet
[2699]               *            1  Logical End Of File
[2700]               ***********************************************************
[2701] 91E4 BD,5C,04 EOF    DST  @PABPTR,@ARG      Save the current PAB and set
[2702]               *                              the new one in SUBEOF
[2703] 91E7 06,92,24        CALL SUBEOF            Try to find the PAB somewhere
[2704] 91EA 57,DD           BR   ERRFE             Can't file
[2705] 91EC BE,5E,09        ST   CZSTAT,@ARG2      Select status code without
[2706] 91EF C0,E0,04        EX   @ARG2,V@COD(@PABPTR) destorying original code
       91F2 04,5E
[2707] 91F4 06,97,6B        CALL IOCLZ1            Get the info from DSR
[2708] 91F7 C1,04,5C        DEX  @ARG,@PABPTR      Restore original PAB and orig
[2709] 91FA BC,E0,04        ST   @ARG2,V@COD(@ARG)  I/O code
       91FD 5C,5E
[2710] 91FF BC,5E,E0        ST   V@SCR(@ARG),@ARG2 And pick up STATUS
       9202 0C,5C
[2711] 9204 31,00,08        MOVE 8,G@FLOAT1,@FAC   Get floating 1
       9207 4A,92,1C
[2712] 920A DA,5E,03        CLOG 3,@ARG2           Test EOF bits
[2713] 920D 72,18           BS   EOFZ2             No EOF indication
[2714] 920F DA,5E,02        CLOG 2,@ARG2           Physical EOF
[2715] 9212 72,16           BS   G9210
[2716] 9214 83,4A           DNEG @FAC              Make result -1
[2717] 9216 0F,75    G9210  XML  CONT
[2718] 9218 87,4A    EOFZ2  DCLR @FAC              Create result 0
[2719] 921A 0F,75           XML  CONT
[2720] 921C 40,01,00 FLOAT1 BYTE >40,1,0,0,0,0,0,0   * Floating point -1
       921F 00,00,00
       9222 00,00
[2721] 9224 D6,42,B7 SUBEOF CEQ  LPARZ,@CHAT       * SYNTAX ERROR
[2722] 9227 41,0F           BR   ERRSYN
[2723] 9229 0F,74           XML  PARSE             Parse up to the matching ")"
[2724] 922B FF              BYTE >FF
[2725] 922C 06,93,62        CALL CHKCNV            Convert and search for PAB
[2726] 922F 77,D1           BS   ERRBV             Avoid 0's and negatives bad v
[2727] 9231 BC,62,17        ST   @DSRFLG,@ARG6     @DSRFLG got changed in CHKCON
[2728] 9234 06,93,77        CALL CHKCON            Check and search tiven filenu
[2729] 9237 BC,17,62        ST   @ARG6,@DSRFLG     @DSRFLG to changed CHKCON
[2730] 923A 01              RTNC                   Condition set : file # exists
[2731]               ***********************************************************
[2732]               *      LOAD / SAVE / MERGE UTILITY ROUTINE
[2733]               * GPNAME gets program name from OLD and SAVE
[2734]               * Can also be used for future implementation of REPLACE
[2735]               * statement. Also gives valuable contribution to updating
[2736]               * of program pointers (VSPTR, STVSPT, FLAG, etc...) and
[2737]               * creation of LOAD/SAVE PAB
[2738]               ***********************************************************
[2739] 923B B2,45,80 GPNAME AND  >80,@FLAG         Avoid returns from ERRZZ rout
[2740] 923E D6,42,C7        CEQ  STRINZ,@CHAT
[2741] 9241 72,48           BS   G9242
[2742] 9243 D6,42,C8        CEQ  NUMZ,@CHAT        * SYNTAX ERROR
[2743] 9246 41,0F           BR   ERRSYN
[2744] 9248 06,81,FA G9242  CALL CLSALL            First close all open files
[2745] 924B 06,60,22        CALL KILSYM            Kill the symbol table
[2746] 924E BF,04,09        DST  VRAMVS+8,@PABPTR  Create PAB as low as possible
       9251 60
[2747] 9252 86,B0,04        CLR  V*PABPTR          Clear PAB with ripple-move

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0049 
FLMGR-359
[2748] 9255 35,00,09        MOVE PABLEN-5,V*PABPTR,V@1(@PABPTR)
       9258 E0,01,04
       925B B0,04
[2749] 925D 0F,79           XML  PGMCHR            Get length of file-specificat
[2750] 925F A7,04,00        DSUB 4,@PABPTR         Make it a regular PAB
       9262 04
[2751] 9263 BC,E0,0D        ST   @CHAT,V@NLEN(@PABPTR) Copy name length to PAB
       9266 04,42
[2752] 9268 BD,0A,E0        DST  V@NLEN-1(@PABPTR),@STADDR Avoid problems(bugs!)
       926B 0C,04
[2753] 926D 8E,80,89        CZ   @RAMFLG           If ERAM not exist or imperati
[2754] 9270 52,7B           BR   G9275
[2755] 9272 34,0A,E0        MOVE @STADDR,V*PGMPTR,V@NLEN+1(@PABPTR)
       9275 0E,04,B0
       9278 2C
[2756] 9279 52,8A           BR   G9284
[2757] 927B BD,56,0A G9275  DST  @STADDR,@FFF1     @FFF1 : Byte count
[2758] 927E BD,54,2C        DST  @PGMPTR,@DDD1     Source address on ERAM
[2759] 9281 BD,58,04        DST  @PABPTR,@EEE1
[2760] 9284 A3,58,00        DADD NLEN+1,@EEE1      Destination address on VDP
       9287 0E
[2761] 9288 0F,8B           XML  GVWITE            Write from ERAM to VDP
[2762] 928A A1,2C,0A G9284  DADD @STADDR,@PGMPTR   Skip the string
[2763]               * OLD and SAVE can only be imperative
[2764] 928D 86,34           CLR  @DATA             Clear DATA line
[2765] 928F 00              RTN                    That's all folks
[2766]               ***********************************************************
[2767]               *           READ / INPUT UTILITY ROUTINES
[2768]               ***********************************************************
[2769] 9290 BD,0A,2C GETVAR DST  @PGMPTR,@STADDR   Save token pointer to first c
[2770] 9293 86,10           CLR  @VAR5             Clear # of parsed variables
[2771] 9295 BD,0E,6E        DST  @VSPTR,@VAR4      Save first entry in V-stack
[2772]               * Start parse cycle for IMPUT statement
[2773] 9298 CA,42,80 GETVZ0 CHE  >80,@CHAT         Make sure of varialbe name
[2774] 929B 61,0F           BS   ERRSYN
[2775] 929D 0F,7A           XML  SYM               Get correct symbol table entr
[2776] 929F 86,11           CLR  @VAR6             Start with zero paren nesting
[2777] 92A1 D6,42,B7 GETVZ1 CEQ  LPARZ,@CHAT       Increment counter for "("
[2778] 92A4 52,A8           BR   G92A2
[2779] 92A6 90,11           INC  @VAR6
[2780] 92A8 8E,11    G92A2  CZ   @VAR6             Watch out for final balance
[2781] 92AA 72,BC           BS   G92B6
[2782] 92AC 06,95,B3        CALL CHKEND            Check for unbalenced parenthe
[2783] 92AF 61,0F           BS   ERRSYN            Somebody forgot something!!!!
[2784] 92B1 D6,42,B6        CEQ  RPARZ,@CHAT       Decrement for ")"
[2785] 92B4 52,B8           BR   G92B2
[2786] 92B6 92,11           DEC  @VAR6
[2787] 92B8 0F,79    G92B2  XML  PGMCHR            Get character following last
[2788] 92BA 52,A1           BR   GETVZ1
[2789] 92BC 0F,77    G92B6  XML  VPUSH             Push entry to V-stack
[2790] 92BE 90,10           INC  @VAR5             Count all pushed variables
[2791] 92C0 06,95,B3        CALL CHKEND            Next should either be EOS or
[2792] 92C3 72,D2           BS   GETVZ2            Found it EOS!!!!
[2793] 92C5 0F,7E           XML  SPEED             Must be at a
[2794] 92C7 00              BYTE SYNCHK          *  comma else
[2795] 92C8 B3              BYTE COMMAZ          *   its an error
[2796] 92C9 06,95,B3        CALL CHKEND            Check for end of statement
[2797] 92CC 52,98           BR   GETVZ0            Haven't found it yet
[2798] 92CE 8E,17           CZ   @DSRFLG           Error for keyboard I/O
[2799] 92D0 41,0F           BR   ERRSYN
[2800] 92D2 00       GETVZ2 RTN
[2801]               * Create a temporary string in memory. BYTES contains the l
[2802] 92D3 BF,4C,65 CTSTR  DST  >6500,@FAC2       Indicate string in FAC
       92D6 00

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0050 
FLMGR-359
[2803] 92D7 BD,50,0C CTSTR0 DST  @BYTES,@FAC6      Copy string length in FAC6
[2804] 92DA 0F,71           XML  GETSTR            Reserve the string
[2805] 92DC BD,4E,1C        DST  @SREF,@FAC4       Copy start address of string
[2806] 92DF BF,4A,00        DST  >001C,@FAC        And indicate temp. string >00
       92E2 1C
[2807] 92E3 00              RTN
[2808]               * Create a temporary string from TEMP5. Length is given
[2809]               * in BYTES.
[2810] 92E4 06,92,D3 CTMPST CALL CTSTR             Create the temporary string
[2811] 92E7 8E,51           CZ   @FAC7
[2812] 92E9 72,F1           BS   G92EB
[2813] 92EB 34,0C,B0        MOVE @BYTES,V*TEMP5,V*SREF
       92EE 1C,B0,66
[2814] 92F1 00       G92EB  RTN                    Non-empty
[2815]               * CHKNUM - Check for numeric argument
[2816] 92F2 D6,01,C8 CHKNUM CEQ  NUMZ,@VAR0+1
[2817] 92F5 53,09           BR   G9303
[2818] 92F7 06,93,12        CALL GETRAM            Get string length
[2819] 92FA BD,56,34        DST  @DATA,@FAC12      Store entry for conversion
[2820] 92FD 86,00           CLR  @VAR0             Prepare for double action
[2821] 92FF A1,34,00        DADD @VAR0,@DATA       Get end of data field
[2822] 9302 06,A0,12        CALL CONV1             Convert data to FAC #
[2823]               * Conversion should also end at end of field
[2824] 9305 D5,A3,90        DCEQ @DATA,V@CSNTMP    Set COND according to equalit
       9308 34
[2825] 9309 01       G9303  RTNC                   Back to caller
[2826] 930A BC,4D,80 GETGFL ST   @RAMTOP,@FAC3     Select target memory
       930D 84
[2827] 930E 8E,4D    GETDAT CZ   @FAC3             Get everything from RAM
[2828] 9310 53,1A           BR   G9314
[2829] 9312 BC,01,B0 GETRAM ST   V*DATA,@VAR0+1    Get data in VAR0+1
       9315 34
[2830] 9316 86,4D           CLR  @FAC3             Be sure FAC3 = 0 !!!!
[2831] 9318 53,26           BR   G9320
[2832] 931A BF,56,00 G9314  DST  1,@FFF1           FFF1 : byte count
       931D 01
[2833] 931E BD,54,34        DST  @DATA,@DDD1       DDD1 : source addr on ERAM
[2834] 9321 0F,8C           XML  GREAD1            Read data from ERAM
[2835] 9323 BC,01,58        ST   @EEE1,@VAR0+1     EEE1 : Destination addr on CP
[2836] 9326 91,34    G9320  DINC @DATA             Go to next datum for next tim
[2837] 9328 00              RTN
[2838] 9329 87,50    CHKSTR DCLR @FAC6             Assume we'll have an empty st
[2839] 932B D6,01,C7        CEQ  STRINZ,@VAR0+1
[2840] 932E 73,35           BS   CHKSZ0
[2841] 9330 D6,01,C8        CEQ  NUMZ,@VAR0+1      See ............
[2842] 9333 53,44           BR   EMPSTR
[2843] 9335 06,93,0E CHKSZ0 CALL GETDAT            Next datum is length byte
[2844] 9338 86,50           CLR  @FAC6             Be sure high byte = 0 !!!!
[2845] 933A BC,51,01        ST   @VAR0+1,@FAC7     Prepare FAC for string assign
[2846] 933D BD,66,34        DST  @DATA,@TEMP5      Save string addr for assignme
[2847] 9340 A1,34,50        DADD @FAC6,@DATA       Update DATA for end of field
[2848] 9343 00              RTN
[2849]               * Empty strings are handled below
[2850] 9344 D6,01,B3 EMPSTR CEQ  COMMAZ,@VAR0+1
[2851] 9347 73,4E           BS   G9348
[2852] 9349 06,93,51        CALL DATEND            Check for end of data stateme
[2853] 934C 53,92           BR   RTC               Return with COND if not EOS
[2854] 934E 93,34    G9348  DDEC @DATA             Backup data pointer for empti
[2855] 9350 00              RTN
[2856] 9351 C0,42,01 DATEND EX   @VAR0+1,@CHAT
[2857] 9354 06,95,B3        CALL CHKEND            Check for EOS (=EOL or "::")
[2858] 9357 C0,42,01        EX   @VAR0+1,@CHAT     Restore original situation
[2859] 935A 01              RTNC
[2860]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0051 
FLMGR-359
[2861]               *           OPEN / CLOSE / RESTORE UTILITY ROUTNE
[2862]               * CHKFN - Check for token = "#" and collect and check
[2863]               * filenumber. Also convert filenumber to (two byte) integer
[2864]               * and check for range 0<x<256
[2865]               ***********************************************************
[2866] 935B 0F,7E    CHKFN  XML  SPEED             Must be at a
[2867] 935D 00              BYTE SYNCHK         *   '#' else
[2868] 935E FD              BYTE NUMBEZ         *    its an error
[2869] 935F 0F,74           XML  PARSE             Parse argument up to ":"
[2870] 9361 B5              BYTE COLONZ
[2871]               * Code to check for negative or zero result in floating poi
[2872]               * accumilator. If not... convert to integer and return two
[2873]               * byte integer in FAC
[2874] 9362 D6,4C,65 CHKCNV CEQ  STRVAL,@FAC2      String/number mismatch
[2875] 9365 77,C5           BS   ERRSNM
[2876] 9367 86,54           CLR  @FAC10            Clear error-code byte
[2877] 9369 0F,12           XML  CFI               Convert to two byte integer
[2878] 936B 8E,54           CZ   @FAC10            BAD VALUE ERROR
[2879] 936D 57,D1           BR   ERRBV
[2880] 936F DA,4A,80        CLOG >80,@FAC          Negative result
[2881] 9372 53,92           BR   RTC
[2882] 9374 8F,4A           DCZ  @FAC              And return with COND set/rese
[2883] 9376 01              RTNC
[2884] 9377 BC,17,4B CHKCON ST   @FAC1,@FNUM       Move result into FNUM
[2885]               * Check for high byte not zero (>0255)
[2886] 937A 8E,4A           CZ   @FAC              Bad value error
[2887] 937C 57,D1           BR   ERRBV
[2888]               * Search routine - Search for a given file number in the
[2889]               * chain of allocated PABs.
[2890]               * IOSTRT contains the start of the PAB - chain
[2891] 937E BD,04,3C        DST  @IOSTRT,@PABPTR   Get first link in the chain
[2892]               * Check for last PAB in the chain and exit if found
[2893] 9381 8F,04    CHKFZ1 DCZ  @PABPTR           Check if file # is correct
[2894] 9383 73,95           BS   G938F
[2895] 9385 D4,E0,02        CEQ  @FNUM,V@FIL(@PABPTR)
       9388 04,17
[2896] 938A 73,92           BS   RTC
[2897] 938C BD,04,B0        DST  V*PABPTR,@PABPTR  Try the next PAB
       938F 04
[2898] 9390 53,81           BR   CHKFZ1
[2899] 9392 D4,00,00 RTC    CEQ  @>8300,@>8300     Force COND to "SET"
[2900] 9395 01       G938F  RTNC                   Exit with no COND change
[2901]               ***********************************************************
[2902]               * OUTEOF outputs the last record if this record is
[2903]               * non-empty, and if the PAB is open for non-imput mode
[2904]               * (UPDATE, APPEND or OUTPUT).
[2905]               ***********************************************************
[2906] 9396 86,17    OUTEOF CLR  @DSRFLG
[2907] 9398 D6,E0,04        CEQ  CZWRIT,V@COD(@PABPTR) Non-input mode
       939B 04,03
[2908] 939D 53,AB           BR   G93A5
[2909] 939F 8E,E0,03        CZ   V@OFS(@PABPTR)    Non-empty record
       93A2 04
[2910] 93A3 73,AB           BS   G93A5
[2911] 93A5 06,96,FB        CALL PRINIT            Initiate for output
[2912] 93A8 06,96,AB        CALL OUTREC            Output and remove pending con
[2913] 93AB 00       G93A5  RTN                    Return to whoever called
[2914]               ***********************************************************
[2915]               * DELPAB routine - delete a given PAB from chain under the
[2916]               * assumption that the PAB exists
[2917]               ***********************************************************
[2918]               * First compute start and end address for block move
[2919] 93AC BD,0A,E0 DELPAB DST  V@BUF(@PABPTR),@STADDR Get lowest used address
       93AF 06,04

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0052 
FLMGR-359
[2920] 93B1 93,0A           DDEC @STADDR           Make that an addr following P
[2921] 93B3 86,08           CLR  @CCPADR           Get highest addr in CCPADR (2
[2922] 93B5 BC,09,E0        ST   V@NLEN(@PABPTR),@CCPADR+1 complete the two byte
       93B8 0D,04
[2923] 93BA A2,09,0D        ADD  PABLEN-1,@CCPADR+1 Add PAB length-1
[2924] 93BD A1,08,04        DADD @PABPTR,@CCPADR   Compute actual addr within RA
[2925] 93C0 D5,3C,04        DCEQ @PABPTR,@IOSTRT   Watch out for first PAB
[2926] 93C3 73,EC           BS   G93E6
[2927] 93C5 BD,02,3C        DST  @IOSTRT,@MNUM     Figure out where link to PAB
[2928] 93C8 D5,B0,02 G93C2  DCEQ @PABPTR,V*MNUM    Continue while not found
       93CB 04
[2929] 93CC 73,D4           BS   G93CE
[2930] 93CE BD,02,B0        DST  V*MNUM,@MNUM      Defer to next link in chain
       93D1 02
[2931] 93D2 53,C8           BR   G93C2             Short end for code-savings
[2932] 93D4 BD,B0,02 G93CE  DST  V*PABPTR,V*MNUM   Copy link over deleted PAB
       93D7 B0,04
[2933] 93D9 8F,B0,02        DCZ  V*MNUM            Adjust link only if not done
[2934] 93DC 73,E6           BS   G93E0
[2935] 93DE A1,B0,02        DADD @CCPADR,V*MNUM    Add deleted # of bytes for
       93E1 08
[2936] 93E2 A5,B0,02        DSUB @STADDR,V*MNUM     link correction
       93E5 0A
[2937] 93E6 BD,04,B0 G93E0  DST  V*MNUM,@PABPTR    Get new PABPTR
       93E9 02
[2938] 93EA 53,FD           BR   G93F7
[2939] 93EC BD,3C,B0 G93E6  DST  V*PABPTR,@IOSTRT  Update first link
       93EF 04
[2940] 93F0 8F,3C           DCZ  @IOSTRT           Only adjust if not last link
[2941] 93F2 73,FA           BS   G93F4
[2942] 93F4 A1,3C,08        DADD @CCPADR,@IOSTRT   Add deleted # of bytes
[2943] 93F7 A5,3C,0A        DSUB @STADDR,@IOSTRT
[2944] 93FA BD,04,3C G93F4  DST  @IOSTRT,@PABPTR   Get new PABPTR
[2945]               * Move the bytes below the deleted block up in memory. This
[2946]               * includes both variables and PABs
[2947] 93FD BD,02,0A G93F7  DST  @STADDR,@MNUM     Get # of bytes to move
[2948] 9400 A5,02,40        DSUB @FREPTR,@MNUM
[2949] 9403 BD,06,08        DST  @CCPADR,@CCPPTR   Save destination address
[2950] 9406 8F,02    G9400  DCZ  @MNUM
[2951] 9408 74,17           BS   G9411
[2952] 940A BC,B0,08        ST   V*STADDR,V*CCPADR Move byte by byte
       940D B0,0A
[2953] 940F 93,0A           DDEC @STADDR           Update source
[2954] 9411 93,08           DDEC @CCPADR            and destination pointers
[2955] 9413 93,02           DDEC @MNUM             Also update counter value
[2956] 9415 54,06           BR   G9400
[2957] 9417 A5,08,0A G9411  DSUB @STADDR,@CCPADR   Compute # of bytes of old PAB
[2958] 941A 8F,04           DCZ  @PABPTR           Avoid trouble with last PAB
[2959] 941C 74,37           BS   G9431
[2960] 941E 8F,B0,04 G9418  DCZ  V*PABPTR          Ad infinitum (or fundum)
[2961] 9421 74,32           BS   G942C
[2962] 9423 A1,B0,04        DADD @CCPADR,V*PABPTR  Adjust link to next PAB
       9426 08
[2963] 9427 A1,E0,06        DADD @CCPADR,V@BUF(@PABPTR) Update the buffer link
       942A 04,08
[2964] 942C BD,04,B0        DST  V*PABPTR,@PABPTR  Get next link in chain
       942F 04
[2965] 9430 54,1E           BR   G9418
[2966] 9432 A1,E0,06 G942C  DADD @CCPADR,V@BUF(@PABPTR) Update buffer link
       9435 04,08
[2967]               * Adjust symbol table links
[2968] 9437 8F,3E    G9431  DCZ  @SYMTAB
[2969] 9439 74,BA           BS   G94B4
[2970] 943B D1,3E,06        DCGE @CCPPTR,@SYMTAB   Only update lower links

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0053 
FLMGR-359
[2971] 943E 74,BA           BS   G94B4
[2972] 9440 A1,3E,08        DADD @CCPADR,@SYMTAB   Get symbol table pointer back
[2973] 9443 BD,04,3E        DST  @SYMTAB,@PABPTR   Get pointer for update
[2974] 9446 8E,80,84 DELPZ1 CZ   @RAMTOP
[2975] 9449 54,52           BR   DELPZ2
[2976] 944B D1,E0,04        DCGE @STLN,V@4(@PABPTR) If imperative
       944E 04,30
[2977] 9450 74,57           BS   G9451
[2978] 9452 A1,E0,04 DELPZ2 DADD @CCPADR,V@4(@PABPTR) Adjust name pointer
       9455 04,08
[2979] 9457 D2,B0,04 G9451  CGE  0,V*PABPTR        If string-fix breakpoints
       945A 00
[2980] 945B 74,A1           BS   G949B
[2981] 945D BE,4A,07        ST   >07,@FAC          Mask to get # of dims
[2982] 9460 B0,4A,B0        AND  V*PABPTR,@FAC     Get # of dims
       9463 04
[2983] 9464 BD,4C,04        DST  @PABPTR,@FAC2     Pointer to 1st dim max
[2984] 9467 A3,4C,00        DADD 6,@FAC2            or string pointer
       946A 06
[2985] 946B BF,50,00        DST  1,@FAC6           Number of pointers to change
       946E 01
[2986] 946F 86,4E           CLR  @FAC4             For 2 byte use of option base
[2987] 9471 8E,4A    G946B  CZ   @FAC              While more dimendions
[2988] 9473 74,89           BS   G9483
[2989] 9475 BE,4F,01        ST   1,@FAC5           Assume option base 0
[2990] 9478 A4,4F,43        SUB  @BASE,@FAC5       But correct if base 1
[2991] 947B A1,4E,B0        DADD V*FAC2,@FAC4      Get dim maximum
       947E 4C
[2992] 947F A9,4E,50        DMUL @FAC6,@FAC4       Multiply it in
[2993] 9482 92,4A           DEC  @FAC              Next dim
[2994] 9484 95,4C           DINCT @FAC2
[2995] 9486 05,94,71        B    G946B
[2996]               * FAC2 now points at the 1st string pointer
[2997]               * FAC6 contains the # of pointers that need to be changed
[2998] 9489 8F,50    G9483  DCZ  @FAC6             While pointers to cheange
[2999] 948B 74,A1           BS   G949B
[3000] 948D BD,4A,B0        DST  V*FAC2,@FAC       Get pointer to string
       9490 4C
[3001] 9491 8F,4A           DCZ  @FAC              If sting is non-null
[3002] 9493 74,9B           BS   G9495
[3003] 9495 BD,EF,FF        DST  @FAC2,V@-3(@FAC)  Fix backpointer
       9498 FD,4A,4C
[3004] 949B 95,4C    G9495  DINCT @FAC2            Point to next pointer
[3005] 949D 93,50           DDEC @FAC6             One less pointer to change
[3006] 949F 54,89           BR   G9483
[3007] 94A1 8F,E0,02 G949B  DCZ  V@2(@PABPTR)
       94A4 04
[3008] 94A5 74,BA           BS   G94B4
[3009] 94A7 D1,E0,02        DCGE @CCPPTR,V@2(@PABPTR)
       94AA 04,06
[3010] 94AC 74,BA           BS   G94B4
[3011] 94AE A1,E0,02        DADD @CCPADR,V@2(@PABPTR) Adjust next value link
       94B1 04,08
[3012] 94B3 BD,04,E0        DST  V@2(@PABPTR),@PABPTR Next entry
       94B6 02,04
[3013] 94B8 54,46           BR   DELPZ1
[3014] 94BA A1,40,08 G94B4  DADD @CCPADR,@FREPTR   Update free word pointer
[3015] 94BD 00              RTN
[3016]               ***********************************************************
[3017]               * CNVDEF - Convert to 2 byte integer and default to 1 on
[3018]               *          negative or 0 ....
[3019]               ***********************************************************
[3020] 94BE 06,93,62 CNVDEF CALL CHKCNV            Check and convert
[3021] 94C1 54,C7           BR   CNVDZ0

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0054 
FLMGR-359
[3022] 94C3 BF,4A,00        DST  1,@FAC            Default to 1 or minus and 0
       94C6 01
[3023] 94C7 00       CNVDZ0 RTN                    And return without COND set
[3024]               ***********************************************************
[3025]               * PARREC parses a possible REC clause in INPUT, PRINT or
[3026]               * RESTORE. In case a comma is detected without a REC clause
[3027]               * following it, the COND is set upon return. In case a REC
[3028]               * clause is specified for a file opened for SEQUENTIAL
[3029]               * access, a * FILE ERROR is given.
[3030]               ***********************************************************
[3031] 94C8 D6,42,B3 PARREC CEQ  COMMAZ,@CHAT      Only check if we have a ","
[3032] 94CB 54,F4           BR   G94EE
[3033] 94CD 0F,79           XML  PGMCHR            Check next token for REC
[3034] 94CF D6,42,DE        CEQ  RECZ,@CHAT        May be USING clause
[3035] 94D2 53,92           BR   RTC
[3036] 94D4 DA,E0,05        CLOG 1,V@FLG(@PABPTR)
       94D7 04,01
[3037] 94D9 77,DD           BS   ERRFE
[3038] 94DB 0F,79           XML  PGMCHR            Get first character of expres
[3039] 94DD 06,93,96        CALL OUTEOF            Output possible pending outpu
[3040] 94E0 86,E0,03        CLR  V@OFS(@PABPTR)    Clear record offset
       94E3 04
[3041] 94E4 0F,74           XML  PARSE             Translate the expression in R
[3042] 94E6 B5              BYTE COLONZ
[3043] 94E7 06,93,62        CALL CHKCNV            Check numeric and convert to
[3044] 94EA D2,4A,00        CGE  0,@FAC             2 byte integer, Bad Value
[3045] 94ED 57,D1           BR   ERRBV
[3046] 94EF BD,E0,0A        DST  @FAC,V@RNM(@PABPTR) Store actual record number
       94F2 04,4A
[3047] 94F4 00       G94EE  RTN
[3048]               ***********************************************************
[3049]               *              DISPLAY / ACCEPT UTILITIES
[3050]               ***********************************************************
[3051] 94F5 06,97,45 DISACC CALL INITKB            PABPTR is used as flag (no DS
[3052] 94F8 D6,42,EF DISPZ1 CEQ  ERASEZ,@CHAT      Check for ERASE ALL
[3053] 94FB 55,1E           BR   G9518
[3054] 94FD DA,04,01        CLOG 1,@PABPTR          already used once
[3055] 9500 41,0F           BR   ERRSYN
[3056] 9502 0F,79           XML  PGMCHR            Check next token for ALL
[3057] 9504 0F,7E           XML  SPEED
[3058] 9506 00              BYTE SYNCHK          *  has to be ALL
[3059] 9507 EC              BYTE ALLZ
[3060] 9508 07,80           ALL  BKGD+OFFSET       Clear screen to background co
[3061] 950A BE,7F,03        ST   3,@XPT            Reset pending output pointer
[3062] 950D DA,04,04        CLOG 4,@PABPTR         Didn't use AT yet
[3063] 9510 55,19           BR   G9513
[3064] 9512 BE,06,01        ST   1,@CCPPTR         Reset column pointer
[3065] 9515 BF,08,02        DST  SCRNBS+2,@CCPADR   and screen base address
       9518 E2
[3066] 9519 B6,04,01 G9513  OR   1,@PABPTR         Set "ERASE USED" flag
[3067] 951C 54,F8           BR   DISPZ1            Try next token
[3068] 951E D6,42,EE G9518  CEQ  BEEPZ,@CHAT        delay action for BEEP
[3069] 9521 55,2F           BR   G9529
[3070] 9523 DA,04,02        CLOG 2,@PABPTR         Use it only once
[3071] 9526 41,0F           BR   ERRSYN
[3072] 9528 B6,04,02        OR   2,@PABPTR         No syntax error detected here
[3073] 952B 0F,79           XML  PGMCHR            Evaluate next token
[3074] 952D 54,F8           BR   DISPZ1            Get set for second pass
[3075] 952F D6,42,F0 G9529  CEQ  ATZ,@CHAT         Generate "AT" clause
[3076] 9532 55,77           BR   G9571
[3077] 9534 DA,04,04        CLOG 4,@PABPTR         Second usage not
[3078] 9537 41,0F           BR   ERRSYN
[3079] 9539 0F,79           XML  PGMCHR             allowed....
[3080] 953B 0F,7E           XML  SPEED

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0055 
FLMGR-359
[3081] 953D 00              BYTE SYNCHK          * Skip left parenthesis
[3082] 953E B7              BYTE LPARZ
[3083] 953F 0F,74           XML  PARSE             Now parse any expression
[3084] 9541 B3              BYTE COMMAZ
[3085] 9542 0F,7E           XML  SPEED
[3086] 9544 00              BYTE SYNCHK          * Check for "," and skip it
[3087] 9545 B3              BYTE COMMAZ
[3088] 9546 06,94,BE        CALL CNVDEF            Convert to 2 byte numeric
[3089] 9549 BE,4C,18        ST   24,@FAC2          Convert modulo 24 (# screen l
[3090] 954C 06,96,20        CALL COMMOD            Compute remainder
[3091] 954F 92,4B           DEC  @FAC1             Convert back to 0 (range was
[3092] 9551 AA,4B,20        MUL  32,@FAC1          Convert to line base address
[3093] 9554 BD,08,4B        DST  @FAC1,@CCPADR     And repalce CCPADR
[3094] 9557 0F,74           XML  PARSE             Parse column expression
[3095] 9559 B6              BYTE RPARZ
[3096] 955A 0F,7E           XML  SPEED
[3097] 955C 00              BYTE SYNCHK          * Check for ")" at end
[3098] 955D B6              BYTE RPARZ
[3099] 955E 06,94,BE        CALL CNVDEF            Again convert to two byte int
[3100] 9561 BE,4C,1C        ST   VWIDTH,@FAC2      Convert modulo video width
[3101] 9564 06,96,20        CALL COMMOD            Compute remainder
[3102] 9567 BC,06,4B        ST   @FAC1,@CCPPTR     Select current column
[3103] 956A A1,08,4A        DADD @FAC,@CCPADR      Compute full address
[3104] 956D 91,08           DINC @CCPADR           Adjust for column 0 (offset-1
[3105] 956F B6,04,04        OR   4,@PABPTR         Set "AT-CLAUSE" used flag
[3106] 9572 B6,04,20        OR   32,@PABPTR        Set "NON-STANDARD SCREEN ADDR
[3107] 9575 54,F8           BR   DISPZ1            Continue for next item
[3108] 9577 D6,42,EB G9571  CEQ  SIZEZ,@CHAT       "SIZE" clause
[3109] 957A 55,A6           BR   G95A0
[3110] 957C DA,04,08        CLOG 8,@PABPTR         Only use once
[3111] 957F 41,0F           BR   ERRSYN
[3112] 9581 0F,79           XML  PGMCHR            Get character following the S
[3113] 9583 D6,42,B7        CEQ  LPARZ,@CHAT        has to open "("
[3114] 9586 41,0F           BR   ERRSYN
[3115] 9588 0F,74           XML  PARSE             And close again ")"
[3116] 958A FE              BYTE VALIDZ
[3117] 958B D2,4A,00        CGE  0,@FAC            Change to positive argument
[3118] 958E 75,95           BS   G958F
[3119] 9590 83,4A           DNEG @FAC              For ACCEPT statement with siz
[3120] 9592 B6,04,80        OR   >80,@PABPTR        indicate in highest bit
[3121] 9595 06,93,62 G958F  CALL CHKCNV
[3122] 9598 77,D1           BS   ERRBV             * BAD VALUE
[3123] 959A 8E,4A           CZ   @FAC              Also for args >255 (less then
[3124] 959C 57,D1           BR   ERRBV
[3125] 959E BC,05,4B        ST   @FAC1,@PABPTR+1   Copy to PABPTR (always used)
[3126] 95A1 B6,04,08        OR   8,@PABPTR         Prevent further use
[3127] 95A4 54,F8           BR   DISPZ1             and go on
[3128] 95A6 D6,42,FE G95A0  CEQ  VALIDZ,@CHAT      Exclude VALIDATE option
[3129] 95A9 75,BF           BS   G95B9
[3130]               * Start evaluating ERASE clause here
[3131] 95AB DA,04,08        CLOG 8,@PABPTR
[3132] 95AE 75,B3           BS   CHKEND
[3133] 95B0 06,95,E5        CALL SIZE1             Evaluate field defined in SIZ
[3134]               * If it's no DISPLAY keyword ( AT, SIZE, BEEP or USING) it
[3135]               * has to be a print separator or colon ":"
[3136]               * If anything is specified is has to be a colon or end of
[3137]               * line... for end-of-line output current record
[3138]               * Check for end of statement
[3139] 95B3 DA,42,80 CHKEND CLOG >80,@CHAT
[3140] 95B6 75,BD           BS   G95B7
[3141] 95B8 CA,42,84        CHE  TREMZ+1,@CHAT
[3142] 95BB 53,92           BR   RTC
[3143] 95BD 8E,42    G95B7  CZ   @CHAT             Set COND according to CHAT
[3144] 95BF 01       G95B9  RTNC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0056 
FLMGR-359
[3145]               ***********************************************************
[3146]               * NXTCHR - Get next program character - skip all strings,
[3147]               *          numerics and line references...
[3148]               ***********************************************************
[3149] 95C0 06,95,B3 NXTCHR CALL CHKEND            Check for end of statements
[3150] 95C3 73,92           BS   RTC               Avoid end of statement
[3151] 95C5 D6,42,C7        CEQ  STRINZ,@CHAT      Skip all strings
[3152] 95C8 75,CF           BS   NXTCZ0
[3153] 95CA D6,42,C8        CEQ  NUMZ,@CHAT         and numerics/unquoted string
[3154] 95CD 55,DB           BR   G95D5
[3155] 95CF 0F,79    NXTCZ0 XML  PGMCHR            Get string length
[3156] 95D1 BC,4B,42        ST   @CHAT,@FAC1       Make that a double please...
[3157] 95D4 86,4A           CLR  @FAC              Hic.... Oops, sorry
[3158] 95D6 A1,2C,4A        DADD @FAC,@PGMPTR      Back to the serious stuff
[3159] 95D9 55,E2           BR   G95DC
[3160] 95DB D6,42,C9 G95D5  CEQ  LNZ,@CHAT         Line # = skip 2 tokens
[3161] 95DE 55,E2           BR   G95DC
[3162] 95E0 95,2C           DINCT @PGMPTR          <----------- That's the skip
[3163] 95E2 0F,79    G95DC  XML   PGMCHR           Get the next token
[3164] 95E4 00              RTN
[3165]               ***********************************************************
[3166]               *                 PRINT / DISPLAY UTILITES
[3167]               * Use the parameters specified in SIZE for further
[3168]               * evaluation of the limited field length
[3169]               ***********************************************************
[3170] 95E5 DA,04,04 SIZE1  CLOG 4,@PABPTR         Not "AT" clause used
[3171] 95E8 56,02           BR   G95FC
[3172] 95EA D6,06,01        CEQ  1,@CCPPTR         Might have to print current
[3173] 95ED 76,02           BS   G95FC
[3174] 95EF BC,4A,06        ST   @CCPPTR,@FAC      Compute final position after
[3175] 95F2 A0,4A,05        ADD  @PABPTR+1,@FAC     in FAC and compare with reco
[3176] 95F5 92,4A           DEC  @FAC
[3177] 95F7 C4,4A,07        CH   @RECLEN,@FAC      Size clause too long
[3178] 95FA 56,02           BR   G95FC
[3179]               * We can't get here for AT( , ) output, since right margin
[3180]               * limited there
[3181] 95FC 06,96,AB        CALL OUTREC            Advance to next line
[3182] 95FF 06,96,D2        CALL SCRO              Scroll the screeen
[3183] 9602 A4,07,06 G95FC  SUB  @CCPPTR,@RECLEN   Limit field size to available
[3184] 9605 90,07           INC  @RECLEN            space... including current p
[3185] 9607 C4,07,05        CH   @PABPTR+1,@RECLEN
[3186] 960A 56,CE           BR   INITZ1
[3187] 960C BC,07,05        ST   @PABPTR+1,@RECLEN Only accept if available
[3188] 960F 56,CE           BR   INITZ1            Reinitialize CCPPTR
[3189]               * Copy (converted) numerical datum in string
[3190] 9611 BC,0D,56 RSTRING ST  @FAC12,@BYTES+1   Get actual string length
[3191] 9614 86,0C           CLR  @BYTES            Create double byte value
[3192] 9616 06,92,D3        CALL CTSTR             Create a temporary string
[3193] 9619 34,0C,B0        MOVE @BYTES,*FAC11,V*SREF Copy value string
       961C 1C,90,55
[3194] 961F 00              RTN
[3195]               * COMMOD - Compute FAC module FAC2
[3196] 9620 AC,4A,4C COMMOD DIV  @FAC2,@FAC        Compute remainder
[3197] 9623 8E,4B           CZ   @FAC1             Avoid zero remainders
[3198] 9625 56,2A           BR   G9624
[3199] 9627 BC,4B,4C        ST   @FAC2,@FAC1       Assume maximum remainder
[3200] 962A 86,4A    G9624  CLR  @FAC              Clear upper byte
[3201] 962C 00              RTN
[3202]               * TSTSEP tests for separator in print and branches to the
[3203]               * correct evaluation routine.
[3204]               * If no separator is found, simple return.
[3205]               * Test case end of line
[3206] 962D 06,95,B3 TSTSEP CALL CHKEND
[3207] 9630 56,37           BR   TSTSZ0

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0057 
FLMGR-359
[3208] 9632 BF,90,73        DST  EOLEX,*SUBSTK     Replace return address with E
       9635 83,9B
[3209] 9637 CA,42,B3 TSTSZ0 CHE  COMMAZ,@CHAT
[3210] 963A 56,5F           BR   TSTSZ1
[3211] 963C C6,42,B5        CH   COLONZ,@CHAT
[3212] 963F 76,5F           BS   TSTSZ1
[3213] 9641 BF,90,73        DST  PRSEM,*SUBSTK     Expect it to be a ";"
       9644 83,80
[3214] 9646 06,83,CB        CALL TSTINT            Test for INTERNAL files
[3215] 9649 56,5F           BR   TSTSZ1            Treat all separators as ";"
[3216] 964B D6,42,B3        CEQ  COMMAZ,@CHAT
[3217] 964E 56,55           BR   G964F
[3218] 9650 BF,90,73        DST  PRTCOM,*SUBSTK
       9653 83,62
[3219] 9655 D6,42,B5 G964F  CEQ  COLONZ,@CHAT
[3220] 9658 56,5F           BR   TSTSZ1
[3221] 965A BF,90,73        DST  PRCOL,*SUBSTK
       965D 83,7D
[3222] 965F 00       TSTSZ1 RTN
[3223]               * PARFN - Parse string expression and create PAB automatica
[3224]               *         continue in CSTRIN for copy string to PAB
[3225]               * Exit on non-string values
[3226]               *
[3227]               * First evaluate string expression
[3228] 9660 0F,74    PARFN  XML  PARSE             Parse up to next comma    <<<
[3229] 9662 B3              BYTE COMMAZ          *                           <<<
[3230] 9663 D6,4C,65        CEQ  STRVAL,@FAC2      Check for "STRING"        <<<
[3231] 9666 57,C5           BR   ERRSNM
[3232] 9668 BD,02,50        DST  @FAC6,@MNUM       Copy length byte in MNUM
[3233] 966B A2,03,0E        ADD  PABLEN,@MNUM+1    Account for PAB length+contro
[3234] 966E 0F,77           XML  VPUSH             Save start of string somewher
[3235] 9670 BD,4A,02        DST  @MNUM,@FAC        Setup for MEMCHK - check for
[3236] 9673 0F,72           XML  MEMCHK             memory overflow
[3237] 9675 77,CD           BS   ERRMEM            * MEMORY FULL
[3238] 9677 0F,78           XML  VPOP              Restore all FAC information a
[3239] 9679 A5,40,02        DSUB @MNUM,@FREPTR     Update free word pointer
[3240] 967C BD,04,40        DST  @FREPTR,@PABPTR   Assign PAB entry address
[3241] 967F 91,04           DINC @PABPTR           Correct for byte within PAB
[3242] 9681 86,B0,04        CLR  V*PABPTR          Clear PAB plus control info
[3243] 9684 35,00,0D        MOVE PABLEN-1,V*PABPTR,V@1(@PABPTR)  Ripple byte
       9687 E0,01,04
       968A B0,04
[3244] 968C BC,E0,03        ST   @MNUM+1,V@OFS(@PABPTR) Save length of PAB
       968F 04,03
[3245] 9691 BC,02,51        ST   @FAC7,@MNUM       Compute # of bytes in name
[3246] 9694 BC,E0,0D        ST   @FAC7,V@NLEN(@PABPTR) Store name length
       9697 04,51
[3247] 9699 BC,E0,02        ST   @FNUM,V@FIL(@PABPTR) Copy file number in PAB
       969C 04,17
[3248] 969E BD,08,04        DST  @PABPTR,@CCPADR   Get start addr for string des
[3249] 96A1 A3,08,00        DADD NLEN+1,@CCPADR    Add offset to actual start ad
       96A4 0E
[3250]               * TRICKY - OPTFLG also results offset added in CSTRIN
[3251] 96A5 86,17           CLR  @OPTFLG           Clear all option flags
[3252] 96A7 0F,84           XML  IO                CSTRIN I/O UTILITY
[3253] 96A9 02              BYTE CSTRIN
[3254] 96AA 00              RTN
[3255]               ***********************************************************
[3256]               *                      OUTREC
[3257]               * OUTREC and INITRC are used to output a record to either
[3258]               * screen or external I/O devices, and to initiate pointers
[3259]               * for further I/O.
[3260]               ***********************************************************
[3261] 96AB BC,03,07 OUTREC ST   @RECLEN,@MNUM+1   Compute number of characters

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0058 
FLMGR-359
[3262] 96AE 90,03           INC  @MNUM+1            positions we should fill
[3263] 96B0 8E,17           CZ   @DSRFLG           Screen I/O
[3264] 96B2 76,D9           BS   G96D3
[3265] 96B4 0F,84           XML  IO                Fill the remainder of the rec
[3266] 96B6 01              BYTE FILSPC          *  with appropriate fillers
[3267] 96B7 DA,04,08        CLOG 8,@PABPTR           block output on size
[3268] 96BA 53,92           BR   RTC
[3269] 96BC DA,04,04        CLOG 4,@PABPTR         "AT CLAUSE USED"
[3270] 96BF 76,D2           BS   SCRO
[3271]               * Next test for xing the end of screen
[3272] 96C1 A3,08,00        DADD 4,@CCPADR
       96C4 04
[3273] 96C5 CA,08,03        CHE  3,@CCPADR
[3274] 96C8 56,CE           BR   INITZ1
[3275] 96CA BF,08,00        DST  2,@CCPADR         Restart at upper left hand
       96CD 02
[3276]               *                              corner of screen
[3277] 96CE BE,06,01 INITZ1 ST   1,@CCPPTR         Reset current column pointer
[3278] 96D1 00              RTN
[3279] 96D2 0F,83    SCRO   XML  SCROLL            Scroll the screen one line
[3280] 96D4 BE,06,01        ST   1,@CCPPTR         Reinitialize CCPPTR
[3281] 96D7 57,5A           BR   INTKB0             and reinitialize
[3282]               * This is also entry for last record output
[3283] 96D9 DA,E0,05 G96D3  CLOG >10,V@FLG(@PABPTR) FIXED records
       96DC 04,10
[3284] 96DE 56,E8           BR   G96E2
[3285] 96E0 BC,03,07        ST   @RECLEN,@MNUM+1   Ready for space filling
[3286] 96E3 90,03           INC  @MNUM+1           Move to first position outsid
[3287]               *                              record
[3288] 96E5 0F,84           XML  IO                And do it up to end of record
[3289] 96E7 01              BYTE FILSPC
[3290] 96E8 92,06    G96E2  DEC  @CCPPTR           Update last character positio
[3291] 96EA BC,E0,09        ST   @CCPPTR,V@CNT(@PABPTR) Store # of characters
       96ED 04,06
[3292] 96EF 86,E0,03        CLR  V@OFS(@PABPTR)    Undo pending record offsets
       96F2 04
[3293] 96F3 06,97,64        CALL IOCALL            Call DSR
[3294] 96F6 03              BYTE CZWRIT          *  for WRITE mode
[3295] 96F7 86,09           CLR  @CCPADR+1         Get address at buffer start
[3296] 96F9 57,07           BR   PRZZ0
[3297]               * PRINIT initializes the variable CCPADR, CCPPTR, RECLEN an
[3298]               * DSRFLG, for a given PABPTR.
[3299] 96FB 86,17    PRINIT CLR  @DSRFLG           Indicate external I/O in DSRF
[3300] 96FD BC,07,E0        ST   V@LEN(@PABPTR),@RECLEN  Pick up record length
       9700 08,04
[3301] 9702 BC,09,E0        ST   V@OFS(@PABPTR),@CCPADR+1 Get offset in record
       9705 03,04
[3302] 9707 BC,06,09 PRZZ0  ST   @CCPADR+1,@CCPPTR  Compute columnar position
[3303] 970A 90,06           INC  @CCPPTR           And convert from offset
[3304] 970C 86,08           CLR  @CCPADR           Clear upper byte
[3305] 970E A1,08,E0        DADD V@BUF(@PABPTR),@CCPADR Compute actual address
       9711 06,04
[3306] 9713 00              RTN
[3307]               ***********************************************************
[3308]               * OSTRNG - Copy the value of the string expression to the
[3309]               *          screen.
[3310]               ***********************************************************
[3311] 9714 BC,0C,51 OSTRNG ST   @FAC7,@BYTES      Pick up the string length
[3312] 9717 8E,0C    G9711  CZ   @BYTES            Output as many records as req
[3313] 9719 77,44           BS   G973E
[3314]               * CHKREC check available space in current record.
[3315]               * If the string to be output is too long, it is chuncked up
[3316]               * into digestable pieces. If the current record is partly
[3317]               * filled up, it is output before any chuncking is done.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0059 
FLMGR-359
[3318] 971B BC,03,06 CHKREC ST   @CCPPTR,@MNUM+1   Use MNUM for current offset i
[3319] 971E BC,02,07 CHKRZ0 ST   @RECLEN,@MNUM     Compute remaining area
[3320] 9721 A4,02,06        SUB  @CCPPTR,@MNUM      between column and end
[3321] 9724 90,02           INC  @MNUM             Also count current column
[3322] 9726 C8,02,0C        CHE  @BYTES,@MNUM      Won't fit in current record
[3323] 9729 77,36           BS   G9730
[3324] 972B D6,03,01        CEQ  1,@MNUM+1         Unused record
[3325] 972E 77,39           BS   CHKRZ1
[3326] 9730 06,96,AB        CALL OUTREC            Output whatever we have
[3327] 9733 57,1B           BR   CHKREC            And try again
[3328] 9735 00              RTN
[3329] 9736 BC,02,0C G9730  ST   @BYTES,@MNUM      Use actual count if fit
[3330] 9739 A4,0C,02 CHKRZ1 SUB  @MNUM,@BYTES      Update remaining chars count
[3331] 973C A0,06,02        ADD  @MNUM,@CCPPTR     Also new column pointer
[3332] 973F 0F,84           XML  IO                Copy string to output
[3333] 9741 02              BYTE CSTRIN
[3334] 9742 57,17           BR   G9711             Continue as long as needed
[3335] 9744 00       G973E  RTN
[3336]               ***********************************************************
[3337]               * INITKB - Initialize the variable needed for keyboard outp
[3338]               ***********************************************************
[3339] 9745 86,04    INITKB CLR  @PABPTR           Don't use any DISPLAY options
[3340] 9747 BE,17,60        ST   OFFSET,@DSRFLG    Load for correction of screen
[3341] 974A BE,06,01        ST   1,@CCPPTR         Assume un-initialized XPT
[3342] 974D C6,7F,02        CH   2,@XPT            * Patch for un-initialized XP
[3343] 9750 57,57           BR   G9751
[3344] 9752 BC,06,7F        ST   @XPT,@CCPPTR      Initialize CCPPTR
[3345] 9755 96,06           DECT @CCPPTR           Correct for incorrect XPT off
[3346] 9757 BE,07,1C G9751  ST   VWIDTH,@RECLEN    Get video screen width
[3347] 975A BC,09,06 INTKB0 ST   @CCPPTR,@CCPADR+1 Initialize screen address
[3348] 975D 86,08           CLR  @CCPADR           Clear upper byte CCPADR
[3349] 975F A3,08,02        DADD SCRNBS+1,@CCPADR  Add start-addr plus comenstat
       9762 E1
[3350] 9763 00              RTN
[3351] 9764 88,56    IOCALL FETCH @FAC12           I/O code to FAC12 (BUG!!!)
[3352] 9766 BC,E0,04        ST   @FAC12,V@COD(@PABPTR) Pick up the I/O code
       9769 04,56
[3353] 976B 06,97,71 IOCLZ1 CALL CDSR              Call the DSR routine
[3354] 976E 57,9D           BR   ERRZ2             Give I/O error on error
[3355] 9770 00              RTN                    Or else return
[3356]               * DSR CALL ROUTINE - NORMAL ENTRY
[3357] 9771 BE,E0,0C CDSR   ST   OFFSET,V@SCR(@PABPTR)   Always set screen offse
       9774 04,60
[3358] 9776 35,00,1E        MOVE 30,@FAC,V@VROAZ   Save FAC area
       9779 A3,C0,4A
[3359] 977C BD,56,04        DST  @PABPTR,@FAC12    Get PAB pointer in FAC
[3360] 977F A3,56,00        DADD NLEN,@FAC12       Get PAB pointer in FAC
       9782 0D
[3361] 9783 B2,E0,05        AND  >1F,V@FLG(@PABPTR) Clear error bits for ON ERRO
       9786 04,1F
[3362]               *                       time, I/O process can still be
[3363]               *                        continued
[3364] 9788 06,00,10        CALL CALDSR            Call actual DSR link routine
[3365] 978B 08              BYTE 8
[3366] 978C 35,00,1E        MOVE 30,V@VROAZ,@FAC
       978F 4A,A3,C0
[3367]               * MOVE does not affect status
[3368] 9792 77,99           BS   CDSRZ0            ERROR = ERROR = ERROR
[3369] 9794 DA,E0,05        CLOG >E0,V@FLG(@PABPTR) Set COND if no error
       9797 04,E0
[3370] 9799 01       CDSRZ0 RTNC
[3371]               * ERROR MESSAGES
[3372] 979A 06,81,01 ERRZ2B CALL CLRFRE            Undo allocation of PAB
[3373]               * First check is it error coming from AUTOLD

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0060 
FLMGR-359
[3374]               * If it is then do not print the error messege and
[3375]               *  go back to TOPL02
[3376] 979D 31,00,02 ERRZ2  MOVE 2,G@TOPL02,V@AUTTMP
       97A0 A3,94,60
       97A3 30
[3377] 97A4 D5,80,8A        DCEQ V@AUTTMP,@RSTK+2
       97A7 A3,94
[3378] 97A9 57,AF           BR   G97A9
[3379] 97AB BE,73,8A        ST   RSTK+2,@SUBSTK
[3380] 97AE 00              RTN
[3381]               ***********************************************************
[3382]               * Next code is to avoid recursion of errors in CLSALL
[3383]               * routine. If this entry is taken from CLSALL, the stack
[3384]               * will contain CLSLBL as a retrun address in the third leve
[3385]               ***********************************************************
[3386] 97AF A6,73,04 G97A9  SUB  4,@SUBSTK
[3387] 97B2 D7,90,73        DCEQ CLSLBL,*SUBSTK
       97B5 81,EF
[3388] 97B7 57,BE           BR   G97B8
[3389] 97B9 06,6A,82 WRNIO  CALL WARNZZ            Give warning to the user
[3390] 97BC 23              BYTE 35                * I/O ERROR but warning
[3391] 97BD 00              RTN                    And return to close routine
[3392] 97BE A2,73,04 G97B8  ADD  4,@SUBSTK         Back up two levels for OLD/SA
[3393] 97C1 06,6A,84 ERRIO  CALL ERRZZ
[3394] 97C4 24              BYTE 36                * I/O ERROR
[3395]               * ERROR messages called in this file
[3396] 97C5 06,6A,84 ERRSNM CALL ERRZZ
[3397] 97C8 07              BYTE 7                 * STRING-NUMBER MISMATCH
[3398] 97C9 06,6A,84 ERRIM  CALL ERRZZ
[3399] 97CC 0A              BYTE 10                * IMAGE ERROR
[3400] 97CD 06,6A,84 ERRMEM CALL ERRZZ
[3401] 97D0 0B              BYTE 11                * MEMORY FULL
[3402] 97D1 06,6A,84 ERRBV  CALL ERRZZ
[3403] 97D4 1E              BYTE 30                * BAD VALUE
[3404] 97D5 06,6A,84 ERRINP CALL ERRZZ
[3405] 97D8 20              BYTE 32                * INPUT ERROR
[3406] 97D9 06,6A,84 ERRDAT CALL ERRZZ
[3407] 97DC 21              BYTE 33                * DATA ERROR
[3408] 97DD 06,6A,84 ERRFE  CALL ERRZZ
[3409] 97E0 22              BYTE 34                * FILE ERROR
[3410] 97E1 06,6A,84 ERRPV  CALL ERRZZ
[3411] 97E4 27              BYTE 39                * PROTECTION VIOLATION
[3412] 97E5 06,6A,84 ERRMUV CALL ERRZZ
[3413] 97E8 09              BYTE 9                 * IMPROPERLY USED NAME
[3414]               * Other errors called in file
[3415]               * ERRSYN    * SYNTAX ERROR                        BYTE  3
[3416]               * ERRST     * STRING TRUNCATED ERROR              BYTE 19
[3417]               * WRNNPP    * NO PROGRAM PRESENT                  BYTE 29
[3418]               * WRNINP    * INPUT ERROR            (WARNING)    BYTE 32
[3419]               * ERRIO     * I/O ERROR                           BYTE 36
[3420]               * WRNIO     * I/O ERROR              (WARNING)    BYTE 36
[3421]               * WRNSNM    * STRING NO. MISMATCH    (WARNING)    BYTE  7
[3422]               ***********************************************************
[3423]               * The following section has been added to fix bugs in INPUT
[3424]               * ACCEPT, and LINPUT statements.
[3425]               ***********************************************************
[3426] 97E9 CA,42,80 BUG01  CHE  >80,@CHAT         Make sure of variable name
[3427] 97EC 61,0F           BS   ERRSYN
[3428] 97EE 0F,7A           XML  SYM               Get the information of the
[3429] 97F0 0F,7B           XML  SMB                variable.
[3430] 97F2 00              RTN
[3431]               ***********************************************************
[3432]               * GKXB CODE HERE
[3433] 97F3 BC,4C,42 GTLENG ST   @CHAT,@FAC+2      Moved from LIST routine

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0061 
FLMGR-359
[3434] 97F6 BC,E0,08        ST   @XSTLN,V@8(@PABPTR) Store length
       97F9 04,64
[3435] 97FB 00              RTN                       and return
[3436]               ***********************************************************
[3437]               * RXB ROUTINE TO NOT ALLOW ACCEPT IN EDIT MODE
[3438] 97FC 8E,44    ACCPMM  CZ   @PRGFLG         * EDIT MODE?
[3439] 97FE 49,74            BR   ACCEP2          * No, program mode return
[3440] 9800 0F,83            XML  SCROLL          * Scroll screen for error
[3441] 9802 06,6A,84         CALL ERRZZ           * If imperative - error
[3442] 9805 1B               BYTE 27              * Only legal in a program
[3443]               ***********************************************************
[3444] 9806 D7,E0,02 CIV254 DCEQ >4956,V@2(@PGMPTR) * IV?
       9809 2C,49,56
[3445] 980C 41,0F           BR   ERRSYN
[3446] 980E D7,E0,04        DCEQ >3235,V@4(@PGMPTR) * 25?
       9811 2C,32,35
[3447] 9814 41,0F           BR   ERRSYN
[3448] 9816 D6,E0,06        CEQ  >34,V@6(@PGMPTR)   * 4?
       9819 2C,34
[3449] 981B 41,0F           BR   ERRSYN
[3450] 981D 8E,80,84        CZ   @RAMTOP
[3451] 9820 6E,31           BS   SAZ1  
[3452] 9822 BD,02,80        DST  @RAMTOP,@MNUM     Top of memory in ERAM
       9825 84
[3453] 9826 A5,02,30        DSUB @STLN,@MNUM       Last line of program 
[3454] 9829 91,02           DINC @MNUM             # of bytes total in ERAM
[3455] 982B CB,02,01        DCHE 288,@MNUM         * 302 bytes
       982E 20
[3456] 982F 6E,BD           BS   GSAVE             * IV254 FORMAT 
[3457] 9831 4E,31           BR   SAZ1              * PROGRAM FORMAT
[3458]               ***********************************************************
[3459]                      END

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0062 
FLMGR-359
Symbol Table #1 (New,alpha)  
834C AAA        8302 AAA1       00CB ABSZ       8974 ACCEP2     8971 ACCEPT     
00A4 ACCEPZ     85EB ACCNM      97FC ACCPMM     8A4D ACCPZ1     8A95 ACCPZ2     
8AD1 ACCPZ3     8B3C ACCPZ4     8A82 ACCPZ5     8B30 ACCPZ6     8A7A ACCPZ7     
8B02 ACCPZ8     8A55 ACCPZ9     03B7 ACCTRY     8302 ACCUM      03AE ACCVRA     
03AC ACCVRW     00EC ALLZ       00BB ANDZ       00F9 APPENZ     835D ARG1       
8367 ARG11      836B ARG15      836C ARG16      835E ARG2       835F ARG3       
8360 ARG4       8361 ARG5       8362 ARG6       8363 ARG7       8364 ARG8       
00DC ASCZ       007C ASSGNV     00CC ATNZ       0022 ATNZZ      00F0 ATZ        
0394 AUTTMP     8A8C AZ1        0008 BACK       8343 BASE       00F1 BASEZ      
8350 BBB        830C BBB1       00EE BEEPZ      0020 BKGD       0002 BREAK      
008E BREAKZ     0006 BUF        038E BUFEND     8346 BUFLEV     038C BUFSRT     
97E9 BUG01      830C BYTES      0010 CALDSR     830A CALIST     009D CALLZ      
834E CCC        8308 CCC1       8308 CCPADD     8308 CCPADR     8306 CCPPTR     
9771 CDSR       9799 CDSRZ0     0012 CFI        0018 CHAR2Z     004A CHAR3Z     
8342 CHAT       8113 CHECK      9362 CHKCNV     9377 CHKCON     95B3 CHKEND     
935B CHKFN      9381 CHKFZ1     92F2 CHKNUM     80A5 CHKPAR     971B CHKREC     
883A CHKRM      971E CHKRZ0     9739 CHKRZ1     832E CHKSEP     9329 CHKSTR     
9335 CHKSZ0     000D CHRTN      00D6 CHRZZ      830E CHSAV      0080 CIF        
00C5 CIRCUZ     9806 CIV254     819C CLOSE      00A0 CLOSEZ     81CD CLOSZ1     
8101 CLRFRE     0007 CLRLN      81FA CLSALL     81E7 CLSAZ0     81EF CLSLBL     
0009 CNT        94BE CNVDEF     94C7 CNVDZ0     0004 COD        00B5 COLONZ     
002C COMMA      00B3 COMMAZ     9620 COMMOD     0070 COMPCT     00B8 CONCZ      
03BB CONFLG     82CF CONPRT     0075 CONT       0081 CONTIN     A012 CONV1      
00CD COSZ       03BC CPTEMP     A040 CPUBAS     0820 CRNBUF     08BE CRNEND     
007F CRUNCH     0390 CSNTMP     03BA CSNTP1     0002 CSTRIN     92E4 CTMPST     
92D3 CTSTR      92D7 CTSTR0     830E CURINC     8314 CURLIN     007E CURSOR     
0001 CZCLOS     0007 CZDELE     0005 CZLOAD     0000 CZOPEN     0002 CZREAD     
0004 CZREST     0006 CZSAVE     0008 CZSCR      0009 CZSTAT     0003 CZWRIT     
8334 DATA       A008 DATAST     0093 DATAZ      9351 DATEND     8354 DDD1       
0089 DEFZ       8182 DELET      0099 DELETZ     93AC DELPAB     9446 DELPZ1     
9452 DELPZ2     0087 DELREP     8306 DFLTLM     00E9 DIGITZ     008A DIMZ       
94F5 DISACC     825D DISPL1     00A2 DISPLZ     94F8 DISPZ1     00C4 DIVIZ      
0003 DLETE      0024 DOLLAR     000A DOWN       8317 DSRFLG     000A DWNARR     
007F EDGECH     6032 EDITLN     8350 EEE        8358 EEE1       0081 ELSEZ      
9344 EMPSTR     02FE ENDSCR     008B ENDZ       8332 ENLN       91E4 EOF        
9218 EOFZ2      839B EOLEX      00BE EQUALZ     00EF ERASEZ     837C ERCODE     
97D1 ERRBV      8322 ERRCOD     97D9 ERRDAT     97DD ERRFE      97C9 ERRIM      
97D5 ERRINP     97C1 ERRIO      038A ERRLN      97CD ERRMEM     97E5 ERRMUV     
00A5 ERRORZ     97E1 ERRPV      97C5 ERRSNM     810F ERRSYN     979D ERRZ2      
979A ERRZ2B     6A84 ERRZZ      8376 EXPZ       00CE EXPZZ      832E EXTRAM     
834B FAC1       8354 FAC10      8355 FAC11      8356 FAC12      8357 FAC13      
8358 FAC14      8359 FAC15      835A FAC16      835B FAC17      834C FAC2       
834D FAC3       834E FAC4       834F FAC5       8350 FAC6       8351 FAC7       
8352 FAC8       8353 FAC9       834E FFF        8356 FFF1       0002 FIL        
0001 FILSPC     8126 FILZZ      00FA FIXEDZ     8345 FLAG       0005 FLG        
921C FLOAT1     8317 FNUM       8317 FORNET     0009 FORW       008C FORZ       
8340 FREPTR     812B G8125      812D G8127      8137 G8131      815D G8157      
8160 G815A      816B G8165      816F G8169      81BE G81B8      81E3 G81DD      
8239 G8233      8254 G824E      828E G8288      8299 G8293      82C4 G82BE      
82F2 G82EC      8313 G830D      8355 G834F      83A7 G83A1      83B7 G83B1      
83C1 G83BB      83C9 G83C3      8429 G8423      8434 G842E      8436 G8430      
843E G8438      844E G8448      8466 G8460      8469 G8463      84A8 G84A2      
84C9 G84C3      84E1 G84DB      8521 G851B      852D G8527      8546 G8540      
8568 G8562      8576 G8570      8582 G857C      8587 G8581      859C G8596      
85AA G85A4      85B7 G85B1      8611 G860B      8624 G861E      8649 G8643      
8656 G8650      8667 G8661      8682 G867C      8684 G867E      86B1 G86AB      
86B3 G86AD      86CC G86C6      86E1 G86DB      8734 G872E      8740 G873A      
8758 G8752      8760 G875A      878C G8786      87D5 G87CF      87EC G87E6      
87F0 G87EA      8815 G880F      8846 G8840      8862 G885C      8881 G887B      
888B G8885      8899 G8893      88B5 G88AF      88C5 G88BF      88DE G88D8      
88E2 G88DC      88E7 G88E1      8911 G890B      8947 G8941      8960 G895A      
8991 G898B      89B0 G89AA      89C6 G89C0      89E6 G89E0      89F9 G89F3      
8A03 G89FD      8A19 G8A13      8A29 G8A23      8A39 G8A33      8A3B G8A35      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0063 
FLMGR-359
8A5E G8A58      8A6C G8A66      8AA4 G8A9E      8AB8 G8AB2      8ABD G8AB7      
8ACA G8AC4      8ACE G8AC8      8AE2 G8ADC      8AF1 G8AEB      8B10 G8B0A      
8B26 G8B20      8B3E G8B38      8B71 G8B6B      8B79 G8B73      8B95 G8B8F      
8BB9 G8BB3      8C1B G8C15      8C1D G8C17      8CC3 G8CBD      8CC5 G8CBF      
8CEF G8CE9      8D75 G8D6F      8D84 G8D7E      8DB1 G8DAB      8DB5 G8DAF      
8DFA G8DF4      8E39 G8E33      8E48 G8E42      8E97 G8E91      8EB3 G8EAD      
8F01 G8EFB      8F22 G8F1C      8F8E G8F88      8FBC G8FB6      8FD3 G8FCD      
9030 G902A      909A G9094      909E G9098      90AC G90A6      90B4 G90AE      
90D0 G90CA      912E G9128      9133 G912D      9138 G9132      913E G9138      
9146 G9140      915C G9156      9173 G916D      91BD G91B7      91C1 G91BB      
9216 G9210      9248 G9242      927B G9275      928A G9284      92A8 G92A2      
92B8 G92B2      92BC G92B6      92F1 G92EB      9309 G9303      931A G9314      
9326 G9320      934E G9348      9395 G938F      93AB G93A5      93C8 G93C2      
93D4 G93CE      93E6 G93E0      93EC G93E6      93FA G93F4      93FD G93F7      
9406 G9400      9417 G9411      941E G9418      9432 G942C      9437 G9431      
9457 G9451      9471 G946B      9489 G9483      949B G9495      94A1 G949B      
94BA G94B4      94F4 G94EE      9519 G9513      951E G9518      952F G9529      
9577 G9571      9595 G958F      95A6 G95A0      95BD G95B7      95BF G95B9      
95DB G95D5      95E2 G95DC      9602 G95FC      962A G9624      9655 G964F      
96D9 G96D3      96E8 G96E2      9717 G9711      9736 G9730      9744 G973E      
9757 G9751      97AF G97A9      97BE G97B8      008E GDTECT     930E GETDAT     
930A GETGFL     9312 GETRAM     0071 GETSTR     9290 GETVAR     9298 GETVZ0     
92A1 GETVZ1     92D2 GETVZ2     0087 GOSUBZ     0086 GOTOZ      0085 GOZ        
923B GPNAME     0085 GREAD      008C GREAD1     00C0 GREATZ     917F GRMLST     
91AA GRSUB2     91C2 GRSUB3     91B0 GRSUB4     8F4A GSAV1      8EBD GSAVE      
97F3 GTLENG     7A06 GTLIST     8F50 GVMOV      008B GVWITE     0086 GWRITE     
6036 GWSUB      8370 HIVDP      0084 IFZ        00A3 IMAGEZ     9745 INITKB     
6014 INITPG     96CE INITZ1     85F6 INPUT      03AA INPUTP     0092 INPUTZ     
8933 INPUZ2     8771 INPUZ3     8796 INPUZ4     87BA INPUZ5     87DA INPUZ6     
8828 INPUZ7     876E INPZ2      86D2 INPZ3      86EF INPZ31     872E INPZ32     
876B INPZ33     892D INPZ37     893C INPZ39     87FC INPZ65     881E INPZ67     
0004 INSRT      88EE INSU1      890C INSUB1     8941 INSUB2     00F5 INTERZ     
975A INTKB0     8338 INTRIN     8621 INTRZ0     8633 INTRZ1     86A5 INTRZ2     
00CF INTZ       0084 IO         9764 IOCALL     976B IOCLZ1     833C IOSTRT     
8374 KEYBD      6022 KILSYM     0008 LEN        00D5 LENZ       00BF LESSZ      
008D LETZ       A006 LINE       8865 LINP10     8847 LINPUT     00AA LINPUZ     
8312 LINUM      906E LIST       0002 LISTZ      9093 LISTZ0     9101 LISTZ1     
9154 LISTZ3     9165 LISTZ4     9151 LISTZ5     A002 LITS05     6A74 LLIST      
8336 LNBUF      00C9 LNZ        0371 LODFLG     00D0 LOGZ       00B7 LPARZ      
8EB7 LRTOPL     8D38 LRTOPZ     8348 LSUBP      00DF MAXZ       0072 MEMCHK     
9008 MERGE      0008 MERGEZ     9061 MERGZ1     002D MINUS      00C2 MINUSZ     
00E0 MINZ       8302 MNUM       837A MOTION     03B8 MRGPAB     00C3 MULTZ      
0088 MVDN       0089 MVUP       03BE NEWTOP     0096 NEXTZ      000D NLEN       
02E2 NLNADD     8314 NMLEN      830C NMPTR      0374 NOTONE     00BD NOTZ       
8328 NUDTAB     00FD NUMBEZ     0000 NUMBR      00C8 NUMCOZ     00E8 NUMERZ     
00C8 NUMZ       95C0 NXTCHR     95CF NXTCZ0     0060 OFFSET     0003 OFS        
8BCA OLD        8BD0 OLD1       8225 OLDCD      822D OLDCZ0     8240 OLDCZ1     
8D33 OLDER      03BC OLDTOP     0005 OLDZ       8D94 OLDZ2      8C69 OLDZ3      
8C38 OLDZ5      8C60 OLDZ7      8D1C OLDZ9      8CE4 OLDZZ      009B ONZ        
8032 OPEN       009F OPENZ      810C OPERR      8317 OPTFLG     804B OPTION     
009E OPTIOZ     804D OPTIZ0     8052 OPTIZ1     8078 OPTZ0      80C4 OPTZ01     
8082 OPTZ02     80EB OPTZ03     8087 OPTZ1      80AE OPTZ2      80B3 OPTZ3      
80BD OPTZ4      80C9 OPTZ5      80E1 OPTZ55     80F0 OPTZ6      80FA OPTZ7      
00BA ORZ        9714 OSTRNG     830E OTHEZ0     8309 OTHEZ1     9396 OUTEOF     
00F7 OUTPUZ     96AB OUTREC     9176 PAB        8FFF PAB1       8D2A PAB3       
000E PABLEN     8304 PABPTR     9660 PARFN      94C8 PARREC     0074 PARSE      
00FB PERMAZ     0079 PGMCHR     832C PGMPTR     00DD PIZ        00C1 PLUSZ      
039E PMEM       00D9 POSZ       837D PRCOL      83AA PREXIT     8344 PRGFLG     
96FB PRINIT     826C PRINT      009C PRINTZ     82B7 PRINZ0     82CA PRINZ1     
82AB PRNZ10     8380 PRSEM      8387 PRSMZ1     8333 PRTAB      8362 PRTCOM     
83CE PRTNFN     9707 PRZZ0      03B7 PSCFG      0022 QUOTE      8389 RAMFLG     
8386 RAMFRE     830A RAMPTR     8384 RAMTOP     8378 RANDOM     0095 RANDOZ     
8B40 READ       6A86 READL1     6A76 READLN     0097 READZ      0006 RECALL     
08C0 RECBUF     882D RECENT     8307 RECLEN     00DE RECZ       00F4 RELATZ     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0064 
FLMGR-359
8D3C RELOCA     8DB9 RELOZ1     009A REMZ       0006 RESEQZ     8202 RESTOR     
0094 RESTOZ     0088 RETURZ     8375 RKEY       00D7 RNDZ       000A RNM        
00B6 RPARZ      00E1 RPTZZ      8388 RSTK       9611 RSTRING    9392 RTC        
8326 RTNG       00A9 RUNZ       03B9 SAPROT     8DBE SAVE       0388 SAVEVP     
0007 SAVEZ      8F7C SAVMG      8E31 SAZ1       0384 SBUFLV     007D SCHSYM     
008F SCNSMT     000C SCR        02E0 SCRNBS     96D2 SCRO       0083 SCROLL     
8840 SCRZ       8B9F SEARCH     0003 SEETWO     00D8 SEGZZ      00B4 SEMICZ     
00F6 SEQUEZ     89A8 SETVW      0386 SEXTRM     0398 SFLAG      00D1 SGNZZ      
00D2 SINZ       03B4 SIZCCP     95E5 SIZE1      00EB SIZEZ      03B6 SIZREC     
03B8 SIZXPT     0396 SLSUBP     007B SMB        831E SMTSRT     0020 SPACE      
007E SPEED      0382 SPGMPT     00D3 SQRZ       8B9C SRDATA     8BC3 SRDAZ0     
8BBB SRDAZ1     831C SREF       0082 SSEPZ      039A SSTEMP     039C SSTMP2     
8372 STACK      830A STADDR     0372 START      00B2 STEPZ      83BD STKMAX     
83AF STKMIN     8330 STLN       0098 STOPZ      8302 STPT       831A STREND     
00C7 STRINZ     8318 STRSP      0065 STRVAL     00DB STRZZ      8324 STVSPT     
9224 SUBEOF     00A8 SUBNDZ     91D0 SUBREC     833A SUBTAB     00A7 SUBXTZ     
00A1 SUBZ       007A SYM        0376 SYMBOL     833E SYMTAB     0000 SYNCHK     
0392 TABSAV     00FC TABZ       00D4 TANZ       8366 TEMP5      00B0 THENZ      
8379 TIMER      0034 TONE1      0036 TONE2      6030 TOPL02     601A TOPL10     
6012 TOPL15     8310 TOPSTK     00B1 TOZ        0090 TRACEZ     0083 TREMZ      
83CB TSTINT     962D TSTSEP     9637 TSTSZ0     965F TSTSZ1     00EA UALPHZ     
A020 UBSUB      008F UNBREZ     00C8 UNQSTZ     0091 UNTRAZ     000B UPARR      
00F8 UPDATZ     000B UPMV       83D5 USING      00ED USINGZ     8458 USNGZ0     
8464 USNGZ1     847E USNGZ3     8499 USNGZ4     8539 USNGZ5     85C9 USNGZ9     
84EF USNZ42     856A USNZ55     85B0 USNZ67     85C4 USNZ68     85D9 USNZ95     
00DA VAL        A016 VALCD      03B2 VALIDL     03B0 VALIDP     00FE VALIDZ     
8300 VAR0       8301 VAR1       830E VAR4       8310 VAR5       8311 VAR6       
8316 VAR9       832A VARA       8308 VARC       00F3 VARIAZ     8320 VARW       
8304 VARY       8306 VARY2      837B VDPSTS     008A VGWITE     89CA VLIDZ0     
0078 VPOP       0077 VPUSH      0958 VRAMVS     03C0 VROAZ      8E6F VSAVZ      
001C VWIDTH     00A6 WARNZ      6A82 WARNZZ     87C1 WRNINP     97B9 WRNIO      
8232 WRNNPP     8AFE WRNSNM     87C5 WRZZ5      0073 XCNS       8316 XFLAG      
00BC XORZ       8364 XSTLN      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0065 
FLMGR-359
Symbol Table #2 (New,value)  
0000 CZOPEN     0000 NUMBR      0000 SYNCHK     0001 CZCLOS     0001 FILSPC     
0002 BREAK      0002 CSTRIN     0002 CZREAD     0002 FIL        0002 LISTZ      
0003 CZWRIT     0003 DLETE      0003 OFS        0003 SEETWO     0004 COD        
0004 CZREST     0004 INSRT      0005 CZLOAD     0005 FLG        0005 OLDZ       
0006 BUF        0006 CZSAVE     0006 RECALL     0006 RESEQZ     0007 CLRLN      
0007 CZDELE     0007 SAVEZ      0008 BACK       0008 CZSCR      0008 LEN        
0008 MERGEZ     0009 CNT        0009 CZSTAT     0009 FORW       000A DOWN       
000A DWNARR     000A RNM        000B UPARR      000B UPMV       000C SCR        
000D CHRTN      000D NLEN       000E PABLEN     0010 CALDSR     0012 CFI        
0018 CHAR2Z     001C VWIDTH     0020 BKGD       0020 SPACE      0022 ATNZZ      
0022 QUOTE      0024 DOLLAR     002C COMMA      002D MINUS      0034 TONE1      
0036 TONE2      004A CHAR3Z     0060 OFFSET     0065 STRVAL     0070 COMPCT     
0071 GETSTR     0072 MEMCHK     0073 XCNS       0074 PARSE      0075 CONT       
0077 VPUSH      0078 VPOP       0079 PGMCHR     007A SYM        007B SMB        
007C ASSGNV     007D SCHSYM     007E CURSOR     007E SPEED      007F CRUNCH     
007F EDGECH     0080 CIF        0081 CONTIN     0081 ELSEZ      0082 SSEPZ      
0083 SCROLL     0083 TREMZ      0084 IFZ        0084 IO         0085 GOZ        
0085 GREAD      0086 GOTOZ      0086 GWRITE     0087 DELREP     0087 GOSUBZ     
0088 MVDN       0088 RETURZ     0089 DEFZ       0089 MVUP       008A DIMZ       
008A VGWITE     008B ENDZ       008B GVWITE     008C FORZ       008C GREAD1     
008D LETZ       008E BREAKZ     008E GDTECT     008F SCNSMT     008F UNBREZ     
0090 TRACEZ     0091 UNTRAZ     0092 INPUTZ     0093 DATAZ      0094 RESTOZ     
0095 RANDOZ     0096 NEXTZ      0097 READZ      0098 STOPZ      0099 DELETZ     
009A REMZ       009B ONZ        009C PRINTZ     009D CALLZ      009E OPTIOZ     
009F OPENZ      00A0 CLOSEZ     00A1 SUBZ       00A2 DISPLZ     00A3 IMAGEZ     
00A4 ACCEPZ     00A5 ERRORZ     00A6 WARNZ      00A7 SUBXTZ     00A8 SUBNDZ     
00A9 RUNZ       00AA LINPUZ     00B0 THENZ      00B1 TOZ        00B2 STEPZ      
00B3 COMMAZ     00B4 SEMICZ     00B5 COLONZ     00B6 RPARZ      00B7 LPARZ      
00B8 CONCZ      00BA ORZ        00BB ANDZ       00BC XORZ       00BD NOTZ       
00BE EQUALZ     00BF LESSZ      00C0 GREATZ     00C1 PLUSZ      00C2 MINUSZ     
00C3 MULTZ      00C4 DIVIZ      00C5 CIRCUZ     00C7 STRINZ     00C8 NUMCOZ     
00C8 NUMZ       00C8 UNQSTZ     00C9 LNZ        00CB ABSZ       00CC ATNZ       
00CD COSZ       00CE EXPZZ      00CF INTZ       00D0 LOGZ       00D1 SGNZZ      
00D2 SINZ       00D3 SQRZ       00D4 TANZ       00D5 LENZ       00D6 CHRZZ      
00D7 RNDZ       00D8 SEGZZ      00D9 POSZ       00DA VAL        00DB STRZZ      
00DC ASCZ       00DD PIZ        00DE RECZ       00DF MAXZ       00E0 MINZ       
00E1 RPTZZ      00E8 NUMERZ     00E9 DIGITZ     00EA UALPHZ     00EB SIZEZ      
00EC ALLZ       00ED USINGZ     00EE BEEPZ      00EF ERASEZ     00F0 ATZ        
00F1 BASEZ      00F3 VARIAZ     00F4 RELATZ     00F5 INTERZ     00F6 SEQUEZ     
00F7 OUTPUZ     00F8 UPDATZ     00F9 APPENZ     00FA FIXEDZ     00FB PERMAZ     
00FC TABZ       00FD NUMBEZ     00FE VALIDZ     02E0 SCRNBS     02E2 NLNADD     
02FE ENDSCR     0371 LODFLG     0372 START      0374 NOTONE     0376 SYMBOL     
0382 SPGMPT     0384 SBUFLV     0386 SEXTRM     0388 SAVEVP     038A ERRLN      
038C BUFSRT     038E BUFEND     0390 CSNTMP     0392 TABSAV     0394 AUTTMP     
0396 SLSUBP     0398 SFLAG      039A SSTEMP     039C SSTMP2     039E PMEM       
03AA INPUTP     03AC ACCVRW     03AE ACCVRA     03B0 VALIDP     03B2 VALIDL     
03B4 SIZCCP     03B6 SIZREC     03B7 ACCTRY     03B7 PSCFG      03B8 MRGPAB     
03B8 SIZXPT     03B9 SAPROT     03BA CSNTP1     03BB CONFLG     03BC CPTEMP     
03BC OLDTOP     03BE NEWTOP     03C0 VROAZ      0820 CRNBUF     08BE CRNEND     
08C0 RECBUF     0958 VRAMVS     6012 TOPL15     6014 INITPG     601A TOPL10     
6022 KILSYM     6030 TOPL02     6032 EDITLN     6036 GWSUB      6A74 LLIST      
6A76 READLN     6A82 WARNZZ     6A84 ERRZZ      6A86 READL1     7A06 GTLIST     
8032 OPEN       804B OPTION     804D OPTIZ0     8052 OPTIZ1     8078 OPTZ0      
8082 OPTZ02     8087 OPTZ1      80A5 CHKPAR     80AE OPTZ2      80B3 OPTZ3      
80BD OPTZ4      80C4 OPTZ01     80C9 OPTZ5      80E1 OPTZ55     80EB OPTZ03     
80F0 OPTZ6      80FA OPTZ7      8101 CLRFRE     810C OPERR      810F ERRSYN     
8113 CHECK      8126 FILZZ      812B G8125      812D G8127      8137 G8131      
815D G8157      8160 G815A      816B G8165      816F G8169      8182 DELET      
819C CLOSE      81BE G81B8      81CD CLOSZ1     81E3 G81DD      81E7 CLSAZ0     
81EF CLSLBL     81FA CLSALL     8202 RESTOR     8225 OLDCD      822D OLDCZ0     
8232 WRNNPP     8239 G8233      8240 OLDCZ1     8254 G824E      825D DISPL1     
826C PRINT      828E G8288      8299 G8293      82AB PRNZ10     82B7 PRINZ0     
82C4 G82BE      82CA PRINZ1     82CF CONPRT     82F2 G82EC      8300 VAR0       

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0066 
FLMGR-359
8301 VAR1       8302 AAA1       8302 ACCUM      8302 MNUM       8302 STPT       
8304 PABPTR     8304 VARY       8306 CCPPTR     8306 DFLTLM     8306 VARY2      
8307 RECLEN     8308 CCC1       8308 CCPADD     8308 CCPADR     8308 VARC       
8309 OTHEZ1     830A CALIST     830A RAMPTR     830A STADDR     830C BBB1       
830C BYTES      830C NMPTR      830E CHSAV      830E CURINC     830E OTHEZ0     
830E VAR4       8310 TOPSTK     8310 VAR5       8311 VAR6       8312 LINUM      
8313 G830D      8314 CURLIN     8314 NMLEN      8316 VAR9       8316 XFLAG      
8317 DSRFLG     8317 FNUM       8317 FORNET     8317 OPTFLG     8318 STRSP      
831A STREND     831C SREF       831E SMTSRT     8320 VARW       8322 ERRCOD     
8324 STVSPT     8326 RTNG       8328 NUDTAB     832A VARA       832C PGMPTR     
832E CHKSEP     832E EXTRAM     8330 STLN       8332 ENLN       8333 PRTAB      
8334 DATA       8336 LNBUF      8338 INTRIN     833A SUBTAB     833C IOSTRT     
833E SYMTAB     8340 FREPTR     8342 CHAT       8343 BASE       8344 PRGFLG     
8345 FLAG       8346 BUFLEV     8348 LSUBP      834B FAC1       834C AAA        
834C FAC2       834D FAC3       834E CCC        834E FAC4       834E FFF        
834F FAC5       8350 BBB        8350 EEE        8350 FAC6       8351 FAC7       
8352 FAC8       8353 FAC9       8354 DDD1       8354 FAC10      8355 FAC11      
8355 G834F      8356 FAC12      8356 FFF1       8357 FAC13      8358 EEE1       
8358 FAC14      8359 FAC15      835A FAC16      835B FAC17      835D ARG1       
835E ARG2       835F ARG3       8360 ARG4       8361 ARG5       8362 ARG6       
8362 PRTCOM     8363 ARG7       8364 ARG8       8364 XSTLN      8366 TEMP5      
8367 ARG11      836B ARG15      836C ARG16      8370 HIVDP      8372 STACK      
8374 KEYBD      8375 RKEY       8376 EXPZ       8378 RANDOM     8379 TIMER      
837A MOTION     837B VDPSTS     837C ERCODE     837D PRCOL      8380 PRSEM      
8384 RAMTOP     8386 RAMFRE     8387 PRSMZ1     8388 RSTK       8389 RAMFLG     
839B EOLEX      83A7 G83A1      83AA PREXIT     83AF STKMIN     83B7 G83B1      
83BD STKMAX     83C1 G83BB      83C9 G83C3      83CB TSTINT     83CE PRTNFN     
83D5 USING      8429 G8423      8434 G842E      8436 G8430      843E G8438      
844E G8448      8458 USNGZ0     8464 USNGZ1     8466 G8460      8469 G8463      
847E USNGZ3     8499 USNGZ4     84A8 G84A2      84C9 G84C3      84E1 G84DB      
84EF USNZ42     8521 G851B      852D G8527      8539 USNGZ5     8546 G8540      
8568 G8562      856A USNZ55     8576 G8570      8582 G857C      8587 G8581      
859C G8596      85AA G85A4      85B0 USNZ67     85B7 G85B1      85C4 USNZ68     
85C9 USNGZ9     85D9 USNZ95     85EB ACCNM      85F6 INPUT      8611 G860B      
8621 INTRZ0     8624 G861E      8633 INTRZ1     8649 G8643      8656 G8650      
8667 G8661      8682 G867C      8684 G867E      86A5 INTRZ2     86B1 G86AB      
86B3 G86AD      86CC G86C6      86D2 INPZ3      86E1 G86DB      86EF INPZ31     
872E INPZ32     8734 G872E      8740 G873A      8758 G8752      8760 G875A      
876B INPZ33     876E INPZ2      8771 INPUZ3     878C G8786      8796 INPUZ4     
87BA INPUZ5     87C1 WRNINP     87C5 WRZZ5      87D5 G87CF      87DA INPUZ6     
87EC G87E6      87F0 G87EA      87FC INPZ65     8815 G880F      881E INPZ67     
8828 INPUZ7     882D RECENT     883A CHKRM      8840 SCRZ       8846 G8840      
8847 LINPUT     8862 G885C      8865 LINP10     8881 G887B      888B G8885      
8899 G8893      88B5 G88AF      88C5 G88BF      88DE G88D8      88E2 G88DC      
88E7 G88E1      88EE INSU1      890C INSUB1     8911 G890B      892D INPZ37     
8933 INPUZ2     893C INPZ39     8941 INSUB2     8947 G8941      8960 G895A      
8971 ACCEPT     8974 ACCEP2     8991 G898B      89A8 SETVW      89B0 G89AA      
89C6 G89C0      89CA VLIDZ0     89E6 G89E0      89F9 G89F3      8A03 G89FD      
8A19 G8A13      8A29 G8A23      8A39 G8A33      8A3B G8A35      8A4D ACCPZ1     
8A55 ACCPZ9     8A5E G8A58      8A6C G8A66      8A7A ACCPZ7     8A82 ACCPZ5     
8A8C AZ1        8A95 ACCPZ2     8AA4 G8A9E      8AB8 G8AB2      8ABD G8AB7      
8ACA G8AC4      8ACE G8AC8      8AD1 ACCPZ3     8AE2 G8ADC      8AF1 G8AEB      
8AFE WRNSNM     8B02 ACCPZ8     8B10 G8B0A      8B26 G8B20      8B30 ACCPZ6     
8B3C ACCPZ4     8B3E G8B38      8B40 READ       8B71 G8B6B      8B79 G8B73      
8B95 G8B8F      8B9C SRDATA     8B9F SEARCH     8BB9 G8BB3      8BBB SRDAZ1     
8BC3 SRDAZ0     8BCA OLD        8BD0 OLD1       8C1B G8C15      8C1D G8C17      
8C38 OLDZ5      8C60 OLDZ7      8C69 OLDZ3      8CC3 G8CBD      8CC5 G8CBF      
8CE4 OLDZZ      8CEF G8CE9      8D1C OLDZ9      8D2A PAB3       8D33 OLDER      
8D38 LRTOPZ     8D3C RELOCA     8D75 G8D6F      8D84 G8D7E      8D94 OLDZ2      
8DB1 G8DAB      8DB5 G8DAF      8DB9 RELOZ1     8DBE SAVE       8DFA G8DF4      
8E31 SAZ1       8E39 G8E33      8E48 G8E42      8E6F VSAVZ      8E97 G8E91      
8EB3 G8EAD      8EB7 LRTOPL     8EBD GSAVE      8F01 G8EFB      8F22 G8F1C      
8F4A GSAV1      8F50 GVMOV      8F7C SAVMG      8F8E G8F88      8FBC G8FB6      
8FD3 G8FCD      8FFF PAB1       9008 MERGE      9030 G902A      9061 MERGZ1     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0067 
FLMGR-359
906E LIST       9093 LISTZ0     909A G9094      909E G9098      90AC G90A6      
90B4 G90AE      90D0 G90CA      9101 LISTZ1     912E G9128      9133 G912D      
9138 G9132      913E G9138      9146 G9140      9151 LISTZ5     9154 LISTZ3     
915C G9156      9165 LISTZ4     9173 G916D      9176 PAB        917F GRMLST     
91AA GRSUB2     91B0 GRSUB4     91BD G91B7      91C1 G91BB      91C2 GRSUB3     
91D0 SUBREC     91E4 EOF        9216 G9210      9218 EOFZ2      921C FLOAT1     
9224 SUBEOF     923B GPNAME     9248 G9242      927B G9275      928A G9284      
9290 GETVAR     9298 GETVZ0     92A1 GETVZ1     92A8 G92A2      92B8 G92B2      
92BC G92B6      92D2 GETVZ2     92D3 CTSTR      92D7 CTSTR0     92E4 CTMPST     
92F1 G92EB      92F2 CHKNUM     9309 G9303      930A GETGFL     930E GETDAT     
9312 GETRAM     931A G9314      9326 G9320      9329 CHKSTR     9335 CHKSZ0     
9344 EMPSTR     934E G9348      9351 DATEND     935B CHKFN      9362 CHKCNV     
9377 CHKCON     9381 CHKFZ1     9392 RTC        9395 G938F      9396 OUTEOF     
93AB G93A5      93AC DELPAB     93C8 G93C2      93D4 G93CE      93E6 G93E0      
93EC G93E6      93FA G93F4      93FD G93F7      9406 G9400      9417 G9411      
941E G9418      9432 G942C      9437 G9431      9446 DELPZ1     9452 DELPZ2     
9457 G9451      9471 G946B      9489 G9483      949B G9495      94A1 G949B      
94BA G94B4      94BE CNVDEF     94C7 CNVDZ0     94C8 PARREC     94F4 G94EE      
94F5 DISACC     94F8 DISPZ1     9519 G9513      951E G9518      952F G9529      
9577 G9571      9595 G958F      95A6 G95A0      95B3 CHKEND     95BD G95B7      
95BF G95B9      95C0 NXTCHR     95CF NXTCZ0     95DB G95D5      95E2 G95DC      
95E5 SIZE1      9602 G95FC      9611 RSTRING    9620 COMMOD     962A G9624      
962D TSTSEP     9637 TSTSZ0     9655 G964F      965F TSTSZ1     9660 PARFN      
96AB OUTREC     96CE INITZ1     96D2 SCRO       96D9 G96D3      96E8 G96E2      
96FB PRINIT     9707 PRZZ0      9714 OSTRNG     9717 G9711      971B CHKREC     
971E CHKRZ0     9736 G9730      9739 CHKRZ1     9744 G973E      9745 INITKB     
9757 G9751      975A INTKB0     9764 IOCALL     976B IOCLZ1     9771 CDSR       
9799 CDSRZ0     979A ERRZ2B     979D ERRZ2      97AF G97A9      97B9 WRNIO      
97BE G97B8      97C1 ERRIO      97C5 ERRSNM     97C9 ERRIM      97CD ERRMEM     
97D1 ERRBV      97D5 ERRINP     97D9 ERRDAT     97DD ERRFE      97E1 ERRPV      
97E5 ERRMUV     97E9 BUG01      97F3 GTLENG     97FC ACCPMM     9806 CIV254     
A002 LITS05     A006 LINE       A008 DATAST     A012 CONV1      A016 VALCD      
A020 UBSUB      A040 CPUBAS     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0068 
FLMGR-359
Symbol Table #4 (Def,alpha)  
0034 ACCTON     835C ARG        0032 ATN        0036 BADTON     003B BITREV     
0012 CFI        0014 CNS        002C COS        0010 CSN        8372 DATSTK     
0001 DIVZER     0003 ERRIOV     0006 ERRLOG     0005 ERRNIP     0002 ERRSNN     
0004 ERRSQR     0028 EXP        834A FAC        0006 FADD       000A FCOMP      
0009 FDIV       0008 FMUL       836C FPERAD     0007 FSUB       0038 GETSPACE   
0022 INT        0010 LINK       0018 LOCASE     002A LOG        8370 MEMSIZ     
003D NAMLNK     8300 PAD        0024 PWR        0012 RETURN     000B SADD       
000F SCOMP      000E SDIV       8375 SGN        002E SIN        000D SMUL       
8400 SOUND      0026 SQR        000C SSUB       837C STATUS     0016 STCASE     
8373 SUBSTK     0030 TAN        0007 TRIGER     004A UPCASE     836E VSPTR      
0001 WRNOV      837F XPT        837E YPT        

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0069 
FLMGR-359
Symbol Table #8 (Def,value)  
0001 DIVZER     0001 WRNOV      0002 ERRSNN     0003 ERRIOV     0004 ERRSQR     
0005 ERRNIP     0006 ERRLOG     0006 FADD       0007 FSUB       0007 TRIGER     
0008 FMUL       0009 FDIV       000A FCOMP      000B SADD       000C SSUB       
000D SMUL       000E SDIV       000F SCOMP      0010 CSN        0010 LINK       
0012 CFI        0012 RETURN     0014 CNS        0016 STCASE     0018 LOCASE     
0022 INT        0024 PWR        0026 SQR        0028 EXP        002A LOG        
002C COS        002E SIN        0030 TAN        0032 ATN        0034 ACCTON     
0036 BADTON     0038 GETSPACE   003B BITREV     003D NAMLNK     004A UPCASE     
8300 PAD        834A FAC        835C ARG        836C FPERAD     836E VSPTR      
8370 MEMSIZ     8372 DATSTK     8373 SUBSTK     8375 SGN        837C STATUS     
837E YPT        837F XPT        8400 SOUND      
