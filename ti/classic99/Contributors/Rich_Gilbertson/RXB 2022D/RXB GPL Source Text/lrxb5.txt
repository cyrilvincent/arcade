99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0001 
Version 2.0 (Weiand 1985)     Options : LCSFPF#########                         
[0001]               ***********************************************************
[0002]                      TITL 'RXB 2022'
[0003]               ***********************************************************
[0004]                      GROM >A000
[0005]               ***********************************************************
[0006]               *           GROM ADDRESSES
[0007]               ***********************************************************
[0008]               *    EQUATES FOR ROUTINES FROM OTHER GROM SECTIONS
[0009]               * GROM >0000
[0010]               * LINK    EQU  >0010          GPLDSRLNK
[0011]               * RETURN  EQU  >0012          Return to GPL inderpeter
[0012]               * STCASE  EQU  >0016          Standard Case
[0013] 0022          GRINT  EQU  >0022             Greatest integer
[0014]               * ACCTON  EQU  >0034          ACCEPT TONE
[0015]               * BADTON  EQU  >0036          HONK TONE
[0016]               * UPCASE  EQU  >004A          Upper Case  
[0017]               * GROM >6000 EQUATES
[0018] 6016          SPRINT EQU  >6016             Initialize sprites
[0019] 601C          CHRTAB EQU  >601C             Load default character set
[0020] 601E          SZRUN  EQU  >601E
[0021] 6034          GRSUB1 EQU  >6034             Read data (2 bytes) from ERAM
[0022] 6036          GWSUB  EQU  >6036             Write a few bytes of data to
[0023] 6372          TOPLEV EQU  >6372             RXB CALL USER branch
[0024] 6A78          CHKEND EQU  >6A78             Check end of statement
[0025] 6A7C          DISO   EQU  >6A7C
[0026] 6A7E          ENTER  EQU  >6A7E
[0027] 6A80          ENT09  EQU  >6A80
[0028] 6A82          WARNZZ EQU  >6A82             WARNING MESSAGE ROUTINE
[0029] 6A84          ERRZZ  EQU  >6A84             ERROR MESSAGE ROUTINE
[0030] 63A5          SZNEW  EQU  >63A5             RXB CALL NEW branch
[0031] 63DD          TOPL15 EQU  >63DD             RXB CALL USER branch
[0032]               * GROM >8000
[0033] 8000          DISPL1 EQU  >8000
[0034] 8002          DELET  EQU  >8002
[0035] 8004          PRINT  EQU  >8004
[0036] 8006          INPUT  EQU  >8006
[0037] 8008          OPEN   EQU  >8008
[0038] 800A          CLOSE  EQU  >800A
[0039] 800C          RESTOR EQU  >800C
[0040] 800E          NREAD  EQU  >800E
[0041] 8012          CLSALL EQU  >8012             RXB branch
[0042] 801C          EOF    EQU  >801C
[0043] 801E          ACCEPT EQU  >801E
[0044] 8020          SRDATA EQU  >8020
[0045] 8022          REC    EQU  >8022
[0046] 802C          GRSUB2 EQU  >802C
[0047] 802E          GRSUB3 EQU  >802E
[0048] 8030          LINPUT EQU  >8030
[0049]               * CHARS                       RXB CHARACTERS IN ROM 3 NOW
[0050]               *                             RXB Character Definitions
[0051]               * GROM >E000
[0052] E025          GE025  EQU  >E025             RXB branch EA module
[0053]               ***********************************************************
[0054]               *    Equates for XMLs
[0055] 0000          SYNCHK EQU  >00               SYNCHK XML selector
[0056] 0001          PARCOM EQU  >01               PARse to a COMma selector
[0057] 0002          RANGE  EQU  >02               RANGE selector
[0058]               * FADD   EQU  >06               Floating ADD *RXB RND*
[0059] 0008          FMUL   EQU  >08               Floating MULtiply
[0060] 0009          FDIV   EQU  >09               Floating DIVide
[0061] 000A          FCOMP  EQU  >0A               Floating COMPare
[0062]               * SADD   EQU  >0B               Stack ADD *RXB RND*
[0063] 000C          SSUB   EQU  >0C               Stack SUBtract
[0064] 0010          CSNUM  EQU  >10               Convert String to Number
[0065] 0012          CFI    EQU  >12               Convert floating to integer

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0002 
RXB 2022
[0066] 0071          GETSTR EQU  >71               SYSTEM GET STRING
[0067] 0073          XBCNS  EQU  >73               Convert number to string
[0068] 0074          PARSE  EQU  >74               Parse a value
[0069] 0075          CONT   EQU  >75               Continue parsing
[0070] 0076          EXECG  EQU  >76               Execute a XB stmt or program
[0071] 0077          VPUSH  EQU  >77               Push on value stack
[0072] 0078          VPOP   EQU  >78               Pop off value stack
[0073] 0079          PGMCHR EQU  >79               GET PROGRAM CHARACTER
[0074] 007A          SYM    EQU  >7A               Find SYMBOL entry
[0075] 007B          SMB    EQU  >7B               Find symbol table entry
[0076] 007C          ASSGNV EQU  >7C               Assign VARIABLE
[0077] 007E          SPEED  EQU  >7E               SPEED UP XML
[0078] 0080          CIF    EQU  >80               Convert INT to FP
[0079] 0082          RTNB   EQU  >82               Return
[0080] 0083          SCROLL EQU  >83               SCROLL THE SCREEN
[0081] 008B          GVWITE EQU  >8B               WRITE DATA FROM GRAM TO VRAM
[0082] 008C          GREAD1 EQU  >8C               READ DATA FROM ERAM
[0083]               * XML for ROM3
[0084] 0074          HCHAR  EQU  >74               HCHAR ASSEMBLY
[0085] 0075          VCHAR  EQU  >75               VCHAR ASSEMBLY
[0086] 0076          ASCHEX EQU  >76               ASC TO HEX ASSEMBLY
[0087] 0077          HPUT   EQU  >77               HPUT ASSEMBLY
[0088] 0078          VPUT   EQU  >78               VPUT ASSEMBLY 
[0089] 007F          CHRLDR EQU  >7F               LOAD CHARACTER DEFINITIONS
[0090] 0080          COLLSP EQU  >80               COLLIDE SPRITES
[0091]               ***********************************************************
[0092]               *    Temporary workspaces in EDIT
[0093]               * PAD   EQU  >8300            TEMPORARY
[0094] 8300          SP00   EQU  >8300            SPRITE value
[0095] 8300          PTFBSL EQU  >8300            Ptr to 1st byte in SPEAK list
[0096] 8300          PHLEN  EQU  >8300            PHrom data LENgth
[0097] 8301          PAD1   EQU  >8301            TEMPORARY
[0098] 8301          PHRADD EQU  >8301            PHRom ADDress
[0099] 8302          PAD2   EQU  >8302            TEMP
[0100] 8302          ACCUM  EQU  >8302            # OF BYTES ACCUMULATOR (4 BYTE
[0101] 8302          MNUM   EQU  >8302            Ussually a counter
[0102] 8302          SP02   EQU  >8302            SPRITE value
[0103] 8302          PTLBSL EQU  >8302            Ptr to last byte in SPEAK list
[0104] 8303          PAD3   EQU  >8303            TEMP
[0105] 8304          PAD4   EQU  >8304            TEMP
[0106] 8304          VARY   EQU  >8304            TEMP
[0107] 8304          SP04   EQU  >8304            SPRITE value
[0108] 8304          PTEBSL EQU  >8304            Ptr to end byte in SPEAK list
[0109]               * NOTE: PTEBSL points to the end of the temporary speak lis
[0110]               *       whereas PTLBSL points to the last byte actually use
[0111]               *       i.e.    PTFBSL <= PTLBSL <= PTEBSL
[0112]               *
[0113] 8306          VARY2  EQU  >8306            Use in MVDN only
[0114] 8306          CCPPTR EQU  >8306            OFFSET WITHIN RECORED (1)
[0115]               *                             or Pointer to current column
[0116] 8306          SP06   EQU  >8306            SPRITE value
[0117] 8306          PTFCIS EQU  >8306            Ptr to 1st character in string
[0118] 8306          PAD6   EQU  >8306            TEMP
[0119] 8308          PAD8   EQU  >8308            TEMP
[0120] 8308          SPSAL  EQU  >8308            Location of sprite attribute l
[0121] 8308          PTCCIS EQU  >8308            Ptr to current character in st
[0122] 830A          PADA   EQU  >830A            TEMP
[0123] 830A          STADDR EQU  >830A            Start address - usually for co
[0124] 830A          SPTMP  EQU  >830A            Temporary variable
[0125] 830A          PTLCIS EQU  >830A            Ptr to last character in strin
[0126] 830B          PADB   EQU  >830B
[0127] 830C          BYTES  EQU  >830C            BYTE COUNTER
[0128]               *                             or String length for GETSTR
[0129] 830C          PTFCIP EQU  >830C            Ptr to 1st character in phrase

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0003 
RXB 2022
[0130] 830E          VAR4   EQU  >830E
[0131] 830E          PTCCIP EQU  >830E            Ptr to current character in ph
[0132] 8310          TOPSTK EQU  >8310            Top of data stack pointer
[0133] 8310          VAR5   EQU  >8310            VAR5 through VAR5+3 used in RA
[0134] 8310          PTLCIP EQU  >8310            Ptr to last character in phras
[0135] 8311          VAR6   EQU  >8311
[0136] 8312          PTFBPH EQU  >8312            Ptr to 1st byte in PHrom
[0137] 8312          VAR7   EQU  >8312            Used in CHARLY
[0138] 8312          STRPTR EQU  >8312            RXB PATCH CODE
[0139] 8314          PTCCPH EQU  >8314            Ptr to current byte in PHrom
[0140] 8314          VAR9   EQU  >8314             Used in CHARLY
[0141] 8316          XFLAG  EQU  >8316            SCAN FLAG-BITS USED AS BELOW
[0142] 8316          PTLCPH EQU  >8316            Ptr to last byte in PHrom
[0143] 8317          FNUM   EQU  >8317            Current file number for search
[0144]               ***********************************************************
[0145]               *    Permanent workspace variables
[0146] 831C          SREF   EQU  >831C            Temporary string pointer
[0147] 8320          VARW   EQU  >8320            Screen address (CURSOR)
[0148] 8322          ERRCOD EQU  >8322            Return error code from ALC
[0149] 8324          STVSPT EQU  >8324            Value-stack base
[0150] 8326          RTNG   EQU  >8326            Return vector from 9900 code
[0151] 8328          NUDTAB EQU  >8328            Start of NUD table
[0152] 832C          PGMPTR EQU  >832C            Program text pointer (TOKEN)
[0153] 832E          EXTRAM EQU  >832E            Line number table pointer
[0154] 8330          STLN   EQU  >8330            Start of line number table
[0155] 8332          ENLN   EQU  >8332            End of line number table
[0156] 8334          DATA   EQU  >8334            Data pointer for READ
[0157] 8336          LNBUF  EQU  >8336            Line table pointer for READ
[0158] 833E          SYMTAB EQU  >833E            Symbol table pointer
[0159] 8340          FREPTR EQU  >8340            Free space pointer
[0160] 8342          CHAT   EQU  >8342            Current charater/token
[0161] 8344          PRGFLG EQU  >8344            Program/imperative flag
[0162] 8345          FLAG   EQU  >8345            General 8-bit flag
[0163] 8346          BUFLEV EQU  >8346            Crunch-buffer destruction leve
[0164] 8348          LSUBP  EQU  >8348            Last subprogram block on stack
[0165]               * FAC  EQU  >834A            Floating-point ACcurmulator
[0166] 834A          CCHAR  EQU  >834A            Current character
[0167] 834B          FAC1   EQU  FAC+1
[0168] 834B          SPLFLG EQU  >834B            SPelL out phrase FLaG
[0169] 834C          FAC2   EQU  FAC+2
[0170] 834C          TOTTIM EQU  >834C            TOTal wait TIMe
[0171]               * NOTE: DATAD must follow immediately after TOTTIM. The
[0172]               *       routine STDATA is counting on this fact!
[0173] 834D          FAC3   EQU  FAC+3
[0174] 834D          DATAAD EQU  >834D            Speech DATA ADdress
[0175] 834E          FAC4   EQU  FAC+4
[0176] 834E          CCC    EQU  FAC+4
[0177] 834E          FFF    EQU  FAC+4
[0178] 834F          FAC5   EQU  FAC+5            Was for original RNDX
[0179] 834F          PTLCIL EQU  >834F            Pointer To Last Character In L
[0180] 8350          FAC6   EQU  FAC+6
[0181] 8350          EEE    EQU  FAC+6
[0182] 8351          FAC7   EQU  FAC+7
[0183] 8351          TIMLEN EQU  >8351             TIMe LENgth of timing charact
[0184] 8352          FAC8   EQU  FAC+8
[0185] 8353          FAC9   EQU  FAC+9
[0186] 8354          FAC10  EQU  FAC+10
[0187] 8354          DDD1   EQU  FAC+10
[0188] 8354          TEMP1  EQU  >8354            TEMPorary CPU location 1
[0189] 8355          FAC11  EQU  FAC+11
[0190] 8356          FAC12  EQU  FAC+12
[0191] 8356          FFF1   EQU  FAC+12
[0192] 8356          TEMP2  EQU  >8356            TEMPorary CPU location 2
[0193] 8358          FAC14  EQU  FAC+14

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0004 
RXB 2022
[0194] 8358          EEE1   EQU  FAC+14
[0195] 8358          READ   EQU  >8358            Address of speech peripheral
[0196]               *                             READ byte interface
[0197] 8359          FAC15  EQU  FAC+15
[0198] 835A          WRITE  EQU  >835A            Address of speech peripheral
[0199]               *                             WRITE byte interface
[0200]               * ARG  EQU  >835C            Floating-point ARGument
[0201] 835D          ARG1   EQU  >835D
[0202] 835D          PHDATA EQU  >835D            PHrom DATA
[0203] 835E          ARG2   EQU  ARG+2
[0204] 835E          PTCBED EQU  >835E            Ptr To Current Byte Ext Data
[0205] 8360          ARG4   EQU  ARG+4
[0206] 8360          LENCST EQU  >8360            LEN of Current ext data STring
[0207] 8362          ARG6   EQU  ARG+6
[0208] 8362          LENWST EQU  >8362            LEN of Whole ext data STring
[0209] 8363          ARG7   EQU  ARG+7
[0210] 8364          ARG8   EQU  ARG+8
[0211] 8364          STRLEN EQU  >8364            STRing LENgth
[0212] 8364          TEMP4  EQU  >8364
[0213] 8366          TEMP5  EQU  >8366
[0214]               * NOTE: BYTE1, BYTE2, and BYTE3 must be in consecutive memo
[0215]               *       locations, and in the following order for SPGET to
[0216]               *       work!
[0217] 8366          BYTE1  EQU  >8366            BYTE 1
[0218] 8367          BYTE2  EQU  >8367            BYTE 2
[0219] 8368          BYTE3  EQU  >8368            BYTE 3
[0220] 8368          TEMP6  EQU  >8368
[0221] 8369          SPKSTS EQU  >8369            SPeaK StaTus
[0222]               * FPERAD EQU  >836C          Value stack pointer
[0223]               * VSPTR  EQU  >836E          Value stack pointer
[0224]               ***********************************************************
[0225]               * MEMSIZ EQU  >8370           MEMORY SIZE
[0226]               * DATSTK EQU  >8372           DATA STACK
[0227]               * SUBSTK EQU  >8373           SUBROUTINE STACK
[0228] 8374          KEYBD  EQU  >8374             KEYBOARD SELCTION
[0229] 8375          RKEY   EQU  >8375             KEY CODE
[0230] 8376          JOYY   EQU  >8376             JOYSTICK Y POSITION
[0231] 8377          JOYX   EQU  >8377             JOYSTICK X POSITION
[0232] 8378          RANDOM EQU  >8378             RANDOM NUMBER GENERATOR
[0233] 8379          TIMER  EQU  >8379             TIMING REGISTER
[0234] 837A          NOMSPR EQU  >837A             NUMBER OF MOVING SPRITES
[0235] 837B          VDPSTT EQU  >837B             VDP STATUS REGISTER
[0236]               * STATUS EQU  >837C            GPL STATUS BYTE
[0237] 837C          ERCODE EQU  >837C             STATUS REGISTER
[0238] 837D          CB     EQU  >837D             Character Buffer
[0239]               * YPT    EQU  >837E            Screen Location Col 
[0240]               * XPT    EQU  >837F            Screen Location Row 
[0241]               ***********************************************************
[0242] 8384          RAMTOP EQU  >8384            Highest address in ERAM
[0243] 8386          RAMFRE EQU  >8386            Free pointer in the ERAM
[0244] 8389          RAMFLG EQU  >8389            ERAM flag
[0245] 83CE          PRTNFN EQU  >83CE            Sound - previous tone finished
[0246] 83D4          VDPR1  EQU  >83D4      CONTENTS OF VDP REGISTER 1 (KEYSCAN)
[0247]               ***********************************************************
[0248]               *    VDP addresses
[0249] 02E2          NLNADD EQU  >02E2             New LiNe ADDress
[0250] 0300          SPRSAL EQU  >0300             Sprite attribute list
[0251] 0371          LODFLG EQU  >0371             Auto-boot flag
[0252] 0372          START  EQU  >0372             Line to start execution at
[0253]               * Temporary
[0254] 0376          SYMBOL EQU  >0376             Saved symbol table pointer
[0255] 0378          ONECHR EQU  >0378             Used for CHRZ
[0256] 0379          VRMSND EQU  >0379             Sound blocks
[0257] 0382          SPGMPT EQU  >0382             Saved PGMPTR for continue

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0005 
RXB 2022
[0258] 0384          SBUFLV EQU  >0384             Saved BUFLEV for contiue
[0259] 0386          SEXTRM EQU  >0386             Saved EXTRAM for continue
[0260] 0388          SAVEVP EQU  >0388             Saved VSPRT for continue
[0261] 038A          ERRLN  EQU  >038A             On-error line pointer
[0262] 0390          CSNTMP EQU  >0390             Use as temporary stored place
[0263]               *                          or CSN TEMPORARY FOR FAC12
[0264] 0396          SLSUBP EQU  >0396             Saved LSUBP for continue
[0265] 0398          SFLAG  EQU  >0398             Saved on-warning/break bits
[0266] 03A0          RNDX2  EQU  >03A0             Random number generator seed
[0267] 03A5          RNDX1  EQU  >03A5             Random number generator seed
[0268] 03AA          SPNUM  EQU  >03AA             Sprite number temporary
[0269] 03BA          CSNTP1 EQU  >03BA             CSN TEMPORARY FOR FAC10
[0270] 03C0          VROAZ  EQU  >03C0             Temporary roll-out area
[0271] 07FF          SPRVB  EQU  >07FF             Sprite velocity block.
[0272] 0820          CRNBUF EQU  >0820             CRuNch BUFfer address
[0273]               ***********************************************************
[0274]               *    IMMEDITATE VALUES
[0275] 0000          NUMBR  EQU  >00               NUMERIC validate
[0276] 0002          LISTZ  EQU  >02
[0277] 0003          X2     EQU  >03
[0278] 0005          OLDZ   EQU  >05
[0279] 0006          RESEQZ EQU  >06
[0280] 0007          SAVEZ  EQU  >07
[0281] 0008          MERGEZ EQU  >08
[0282] 000A          DWNARR EQU  >0A
[0283] 000B          UPARR  EQU  >0B
[0284] 000D          CHRTN  EQU  >0D
[0285] 0020          BKGD   EQU  >20               BACKGROUND CHARACTER
[0286] 0060          OFFSET EQU  >60               OFFSET FOR VIDEO TABLES
[0287] 0065          STRVAL EQU  >65               Value in accum. is string val
[0288]               ***********************************************************
[0289]               * Editting command equates & keys or symbols
[0290] 0002          BREAK  EQU  >02               Break key
[0291] 0003          DLETE  EQU  >03               Delete key
[0292] 0004          INSRT  EQU  >04               Insert key
[0293] 0006          RECALL EQU  >06               Edit-buffer recall
[0294] 0007          CLRLN  EQU  >07               Clear-line key
[0295] 0008          BACK   EQU  >08               Back-space key
[0296] 0009          FORW   EQU  >09               Forward-space key
[0297] 000A          DOWN   EQU  >0A               Down-arrow key
[0298] 000B          UPMV   EQU  >0B               Up-arrow key
[0299] 001C          VWIDTH EQU  >1C               Screen width (PRINT)
[0300] 0020          SPACE  EQU  >20               Space key
[0301] 0022          QUOTE  EQU  >22               "
[0302] 0023          NUMBER EQU  >23               #
[0303] 0024          DOLLAR EQU  >24               $
[0304] 007E          CURSOR EQU  >1E+OFFSET        CURSOR
[0305] 007F          EDGECH EQU  >1F+OFFSET        EDGE character
[0306] 002B          PLUS   EQU  >2B               +
[0307] 002C          COMMAT EQU  >2C               ,
[0308] 002D          MINUS  EQU  >2D               -
[0309] 002D          HYPEN  EQU  >2D               +
[0310] 002E          PERIOD EQU  >2E               .
[0311] 0030          ZERO   EQU  >30               0
[0312] 0039          NINE   EQU  >39               9
[0313] 003A          COLON  EQU  >3A               :
[0314] 003B          SEMICO EQU  >3B               ;
[0315] 003C          LESS   EQU  >3C               <
[0316] 003E          GREAT  EQU  >3E               >
[0317] 0041          A      EQU  >41               A
[0318] 0046          F      EQU  >46               F
[0319]               ***********************************************************
[0320]               *    BASIC TOKEN TABLE
[0321]               *      EQU  >80               spare token

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0006 
RXB 2022
[0322] 0081          ELSEZ  EQU  >81               ELSE
[0323] 0082          SSEPZ  EQU  >82               ::
[0324] 0083          TREMZ  EQU  >83               $
[0325] 0084          IFZ    EQU  >84               IF
[0326] 0085          GOZ    EQU  >85               GO
[0327] 0086          GOTOZ  EQU  >86               GOTO
[0328] 0087          GOSUBZ EQU  >87               GOSUB
[0329] 0088          RETURZ EQU  >88               RETURN
[0330] 0089          DEFZ   EQU  >89               DEF
[0331] 008A          DIMZ   EQU  >8A               DIM
[0332] 008B          ENDZ   EQU  >8B               END
[0333] 008C          FORZ   EQU  >8C               FOR
[0334] 008D          LETZ   EQU  >8D               LET   * RXB REMOVED
[0335] 008E          BREAKZ EQU  >8E               BREAK
[0336] 008F          UNBREZ EQU  >8F               UNBREAK
[0337] 0090          TRACEZ EQU  >90               TRACE
[0338] 0091          UNTRAZ EQU  >91               UNTRACE
[0339] 0092          INPUTZ EQU  >92               INPUT
[0340] 0093          DATAZ  EQU  >93               DATA
[0341] 0094          RESTOZ EQU  >94               RESTORE
[0342] 0095          RANDOZ EQU  >95               RANDOMIZE
[0343] 0096          NEXTZ  EQU  >96               NEXT
[0344] 0097          READZ  EQU  >97               READ
[0345] 0098          STOPZ  EQU  >98               STOP
[0346] 0099          DELETZ EQU  >99               DELETE
[0347] 009A          REMZ   EQU  >9A               REM
[0348] 009B          ONZ    EQU  >9B               ON
[0349] 009C          PRINTZ EQU  >9C               PRINT
[0350] 009D          CALLZ  EQU  >9D               CALL
[0351] 009E          OPTIOZ EQU  >9E               OPTION
[0352] 009F          OPENZ  EQU  >9F               OPEN
[0353] 00A0          CLOSEZ EQU  >A0               CLOSE
[0354] 00A1          SUBZ   EQU  >A1               SUB
[0355] 00A2          DISPLZ EQU  >A2               DISPLAY
[0356] 00A3          IMAGEZ EQU  >A3               IMAGE
[0357] 00A4          ACCEPZ EQU  >A4               ACCEPT
[0358] 00A5          ERRORZ EQU  >A5               ERROR
[0359] 00A6          WARNZ  EQU  >A6               WARNING
[0360] 00A7          SUBXTZ EQU  >A7               SUBEXIT
[0361] 00A8          SUBNDZ EQU  >A8               SUBEND
[0362] 00A9          RUNZ   EQU  >A9               RUN
[0363] 00AA          LINPUZ EQU  >AA               LINPUT
[0364]               *      EQU  >AB               spare token (LIBRARY)
[0365]               *      EQU  >AC               spare token (REAL)
[0366]               *      EQU  >AD               spare token (INTEGER)
[0367]               *      EQU  >AE               spare token (SCRATCH)
[0368]               *      EQU  >AF               spare token
[0369] 00B0          THENZ  EQU  >B0               THEN
[0370] 00B1          TOZ    EQU  >B1               TO
[0371] 00B2          STEPZ  EQU  >B2               STEP
[0372] 00B3          COMMAZ EQU  >B3               ,
[0373] 00B4          SEMICZ EQU  >B4               ;
[0374] 00B5          COLONZ EQU  >B5               :
[0375] 00B6          RPARZ  EQU  >B6               )
[0376] 00B7          LPARZ  EQU  >B7               (
[0377] 00B8          CONCZ  EQU  >B8               &          (CONCATENATE)
[0378]               *      EQU  >B9               spare token
[0379] 00BA          ORZ    EQU  >BA               OR
[0380] 00BB          ANDZ   EQU  >BB               AND
[0381] 00BC          XORZ   EQU  >BC               XOR
[0382] 00BD          NOTZ   EQU  >BD               NOT
[0383] 00BE          EQUALZ EQU  >BE               =
[0384] 00BF          LESSZ  EQU  >BF               <
[0385] 00C0          GREATZ EQU  >C0               >

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0007 
RXB 2022
[0386] 00C1          PLUSZ  EQU  >C1               +
[0387] 00C2          MINUSZ EQU  >C2               -
[0388] 00C3          MULTZ  EQU  >C3               *
[0389] 00C4          DIVIZ  EQU  >C4               /
[0390] 00C5          CIRCUZ EQU  >C5               ^
[0391]               *      EQU  >C6               spare token
[0392] 00C7          STRINZ EQU  >C7               QUOTED STRING
[0393] 00C8          UNQSTZ EQU  >C8               UNQUOTED STRING
[0394] 00C8          NUMZ   EQU  >C8               ALSO NUMERICAL STRING
[0395] 00C8          NUMCOZ EQU  >C8               ALSO UNQUOTED STRING
[0396] 00C9          LNZ    EQU  >C9               LINE NUMBER CONSTANT
[0397]               *      EQU  >CA               spare token
[0398] 00CB          ABSZ   EQU  >CB               ABS
[0399] 00CC          ATNZ   EQU  >CC               ATN
[0400] 00CD          COSZ   EQU  >CD               COS
[0401] 00CE          EXPZZ  EQU  >CE               EXP
[0402] 00CF          INTZ   EQU  >CF               INT
[0403] 00D0          LOGZ   EQU  >D0               LOG
[0404] 00D1          SGNZZ  EQU  >D1               SGN
[0405] 00D2          SINZ   EQU  >D2               SIN
[0406] 00D3          SQRZ   EQU  >D3               SQR
[0407] 00D4          TANZ   EQU  >D4               TAN
[0408] 00D5          LENZ   EQU  >D5               LEN
[0409] 00D6          CHRZZ  EQU  >D6               CHR$
[0410] 00D7          RNDZ   EQU  >D7               RND
[0411] 00D8          SEGZZ  EQU  >D8               SEG$
[0412] 00D9          POSZ   EQU  >D9               POS
[0413] 00DA          VAL    EQU  >DA               VAL
[0414] 00DB          STRZZ  EQU  >DB               STR$
[0415] 00DC          ASCZ   EQU  >DC               ASC
[0416] 00DD          PIZ    EQU  >DD               PI
[0417] 00DE          RECZ   EQU  >DE               REC
[0418] 00DF          MAXZ   EQU  >DF               MAX
[0419] 00E0          MINZ   EQU  >E0               MIN
[0420] 00E1          RPTZZ  EQU  >E1               RPT$
[0421]               *      EQU  >E2               unused
[0422]               *      EQU  >E2               unused
[0423]               *      EQU  >E3               unused
[0424]               *      EQU  >E4               unused
[0425]               *      EQU  >E5               unused
[0426]               *      EQU  >E6               unused
[0427]               *      EQU  >E7               unused
[0428] 00E8          NUMERZ EQU  >E8               NUMERIC
[0429] 00E9          DIGITZ EQU  >E9               DIGIT
[0430] 00EA          UALPHZ EQU  >EA               UALPHA
[0431] 00EB          SIZEZ  EQU  >EB               SIZE
[0432] 00EC          ALLZ   EQU  >EC               ALL
[0433] 00ED          USINGZ EQU  >ED               USING
[0434] 00EE          BEEPZ  EQU  >EE               BEEP
[0435] 00EF          ERASEZ EQU  >EF               ERASE
[0436] 00F0          ATZ    EQU  >F0               AT
[0437] 00F1          BASEZ  EQU  >F1               BASE
[0438]               *      EQU  >F2               spare token (TEMPORARY)
[0439] 00F3          VARIAZ EQU  >F3               VARIABLE
[0440] 00F4          RELATZ EQU  >F4               RELATIVE
[0441] 00F5          INTERZ EQU  >F5               INTERNAL
[0442] 00F6          SEQUEZ EQU  >F6               SEQUENTIAL
[0443] 00F7          OUTPUZ EQU  >F7               OUTPUT
[0444] 00F8          UPDATZ EQU  >F8               UPDATE
[0445] 00F9          APPENZ EQU  >F9               APPEND
[0446] 00FA          FIXEDZ EQU  >FA               FIXED
[0447] 00FB          PERMAZ EQU  >FB               PERMANENT
[0448] 00FC          TABZ   EQU  >FC               TAB
[0449] 00FD          NUMBEZ EQU  >FD               #

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0008 
RXB 2022
[0450] 00FE          VALIDZ EQU  >FE               VALIDATE
[0451]               *      EQU  >FF               ILLEGAL VALUE
[0452]               ***********************************************************
[0453]               * NOTE: FILES EXECSD, SUBS AND PART OF PSCANS ARE IN GROM 5
[0454]               *       AS BELOW:
[0455]               *-------NAME------------------ADDRESS---------BYTES LEFT---
[0456]               *      EXECS                  >A000 - >AD92        5
[0457]               *      SUBS                   >AD98 - >B4DC        2
[0458]               *      PSCANS                 >B4E0 - >B7FA        5
[0459]               *
[0460]               * Some of the error calls at the end of EXECS file are
[0461]               * shared and directly addressed by SUBS file. Any change in
[0462]               * EXECS file which affects the address of error calls will
[0463]               * affect error reference in SUBS file. Make sure to edit
[0464]               * SUBS file in that situation.
[0465]               ***********************************************************
[0466] A000 0F,75           XML  CONT              XML CONT used by subprogram
[0467] A002 43,4C           BR   LITS05            Build FAC entry and GETSTR
[0468] A004 40,90           BR   EXEC              Execute a program
[0469] A006 48,3E           BR   LINE
[0470] A008 47,D9           BR   DATAST
[0471] A00A 47,F5           BR   ASC
[0472] A00C 40,9D           BR   EXEC1
[0473] A00E 41,1F           BR   EXEC6D            Save information on a break
[0474] A010 47,75           BR   DELINK            Delink symbol table entry
[0475] A012 48,50           BR   CONV1
[0476] A014 49,27           BR   SQUISH            Called in error routine in PS
[0477] A016 44,DC           BR   VALCD
[0478] A018 42,81           BR   INTRND
[0479] A01A 4A,BE    GA01A  BR   LNKRT2            End return to XB
[0480] A01C 4A,BA    GA01C  BR   LNKRTN            Check ) and end return to XB
[0481] A01E 48,D1    GA01E  BR   SPCOL             Clear breakpoint in line # ro
[0482] A020 46,67           BR   UBSUB             Spare
[0483] A022 40,22           BR   $
[0484] A024 5C,C4    GA024  BR   CASCII            RXB SIZE ADDRESS DISPLAY
[0485]               *                  *** Please let me know it you address to
[0486]               *                  *** branches here since it will advance
[0487]               *                  *** the address of link list. Sum
[0488] A026 A0,30    LINK1  DATA LINK2
[0489] A028 05,53,4F        STRI 'SOUND'           SOUND
       A02B 55,4E,44
[0490] A02E A9,BB           DATA XSOUND
[0491] A030 A0,3A    LINK2  DATA LINK3
[0492] A032 05,43,4C        STRI 'CLEAR'           CLEAR
       A035 45,41,52
[0493] A038 B5,C2           DATA CLEAR
[0494] A03A A0,44    LINK3  DATA LINK4
[0495] A03C 05,43,4F        STRI 'COLOR'           COLOR
       A03F 4C,4F,52
[0496] A042 A8,65           DATA COLOR
[0497] A044 A0,4E    LINK4  DATA LINK5
[0498] A046 05,47,43        STRI 'GCHAR'           GCHAR 
       A049 48,41,52
[0499] A04C AA,80           DATA GCHARZ
[0500] A04E A0,58    LINK5  DATA LINK6
[0501] A050 05,48,43        STRI 'HCHAR'           HCHAR
       A053 48,41,52
[0502] A056 AA,A8           DATA HCHARZ
[0503] A058 A0,62    LINK6  DATA LINK7
[0504] A05A 05,56,43        STRI 'VCHAR'           VCHAR 
       A05D 48,41,52
[0505] A060 AA,C6           DATA VCHARZ
[0506] A062 A0,6B    LINK7  DATA LINK8
[0507] A064 04,43,48        STRI 'CHAR'            CHAR 

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0009 
RXB 2022
       A067 41,52
[0508] A069 AB,1B           DATA CHARLY
[0509] A06B A0,73    LINK8  DATA LINK9
[0510] A06D 03,4B,45        STRI 'KEY'             KEY
       A070 59
[0511] A071 B8,F8           DATA ZKEY
[0512] A073 A0,7D    LINK9  DATA LINKA
[0513] A075 05,4A,4F        STRI 'JOYST'           JOYST
       A078 59,53,54
[0514] A07B BA,16           DATA ZJOYST
[0515] A07D A0,88    LINKA  DATA LINKB
[0516] A07F 06,53,43        STRI 'SCREEN'          SCREEN
       A082 52,45,45
       A085 4E
[0517] A086 AC,65           DATA BORDER
[0518] A088 AD,9F    LINKB  DATA LINKS1
[0519] A08A 03,45,52        STRI 'ERR'             ERR
       A08D 52
[0520] A08E AC,9B           DATA ERRWXY
[0521]               ***********************************************************
[0522]               *        START EXECUTION OF A PROGRAM OR STATEMENT
[0523]               * DATA:
[0524]               *      RAM(START) points into line number table at the
[0525]               *      first line to execute
[0526]               *      @PGMFLG contains >FF if executing a program or zero
[0527]               *      if imperative statement
[0528]               ***********************************************************
[0529] A090 8E,44    EXEC   CZ   @PRGFLG           If program
[0530] A092 60,A2           BS   GA0AE
[0531] A094 BD,2E,A3        DST  V@START,@EXTRAM   Line to start execution at
       A097 72
[0532] A098 95,2E           DINCT @EXTRAM          Pointer to text pointer
[0533] A09A 06,A2,81        CALL INTRND            Initialize random number
[0534] A09D BE,7F,03 EXEC1  ST   X2,@XPT           Initialize screen display
[0535] A0A0 40,A6           BR   GA0B2
[0536] A0A2 BF,2C,08 GA0AE  DST  CRNBUF,@PGMPTR    Executing out of crunch buffe
       A0A5 20
[0537] A0A6 BF,26,A0 GA0B2  DST  EXEC20,@RTNG      Address of return from ALC
       A0A9 B0
[0538] A0AA BF,28,A1        DST  NUDTB,@NUDTAB     NUD table address for ALC
       A0AD 3B
[0539] A0AE 0F,76           XML  EXECG             Execute XB
[0540] A0B0 8A,23    EXEC20 CASE @ERRCOD+1         Check type of return
[0541] A0B2 40,D3           BR   EXECND            0 - NORMAL END
[0542] A0B4 41,0E           BR   EXECBK            1 - BREAKPOINT
[0543] A0B6 40,E1           BR   EXECTR            2 - TRACE
[0544] A0B8 48,16           BR   ERORZ             3 - ERROR
[0545] A0BA 40,C8           BR   WARNGZ            4 - WARNING
[0546] A0BC 41,CE           BR   ONERR             5 - ON ERROR
[0547] A0BE 46,82           BR   UDF               6 - FUNCTION
[0548] A0C0 42,0C           BR   ONBRK             7 - ON BREAK
[0549] A0C2 43,89           BR   CONCAT            8 - CONCATENATE STRINGS "&"
[0550] A0C4 41,9E           BR   ONWARN            9 - ON WARNING
[0551] A0C6 42,23           BR   GPLCAL            A - CALL STATEMENT
[0552] A0C8 C6,73,B0 WARNGZ CH   >B0,@SUBSTK
[0553] A0CB 6D,69           BS   ERRSO
[0554]               * Stack overflow
[0555]               *                    ALLOW ROOM ON STACK FOR WARNING CALLS
[0556] A0CD 06,6A,82 WRNN01 CALL WARNZZ        ONLY WARNING MSG FROM XB SUPPORT
[0557] A0D0 02              BYTE 2       *         NUMERIC OVERFLOW
[0558] A0D1 41,0A           BR   CLRRTN            Clear ERRCOD and return
[0559]               *                    NORMAL END OF EXECUTION
[0560] A0D3 8E,44    EXECND CZ   @PRGFLG           If imperative mode
[0561] A0D5 40,DD           BR   ERRRDY

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0010 
RXB 2022
[0562] A0D7 06,60,1C        CALL CHRTAB            Load the default character se
[0563] A0DA 05,63,DD        B    TOPL15            Return to top-level
[0564] A0DD 06,6A,84 ERRRDY CALL ERRZZ             Display * READY *
[0565] A0E0 00              BYTE 0
[0566]               * TRACE-MODE turned on - display line number
[0567] A0E1 86,20    EXECTR CLR  @VARW             Clear upper address byte
[0568] A0E3 BC,21,7F        ST   @XPT,@VARW+1      Get current x-pointer
[0569] A0E6 A3,20,02        DADD NLNADD-3,@VARW    Make a valid screen address
       A0E9 DF
[0570] A0EA C7,20,02        DCH  NLNADD+22,@VARW   If might go off screen
       A0ED F8
[0571] A0EE 40,F6           BR   GA102
[0572] A0F0 0F,83           XML  SCROLL            SCROLL to next line
[0573] A0F2 BF,20,02        DST  NLNADD,@VARW      Re-initialize screen address
       A0F5 E2
[0574] A0F6 BE,B0,20 GA102  ST   LESS+OFFSET,V*VARW Display open bracket "("
       A0F9 9C
[0575] A0FA 91,20           DINC @VARW             Increment screen address
[0576] A0FC 06,A7,F5        CALL ASC               Convert line # into ASCII
[0577] A0FF BE,B0,20        ST   GREAT+OFFSET,V*VARW Display close bracket ")"
       A102 9E
[0578] A103 A7,20,02        DSUB NLNADD-4,@VARW    Update the x-pointer
       A106 DE
[0579] A107 BC,7F,21        ST   @VARW+1,@XPT
[0580] A10A 87,22    CLRRTN DCLR @ERRCOD           Clear the return vector
[0581] A10C 0F,82           XML  RTNB              Return to ALC
[0582]               * BREAKPOINT OR BREAK-KEY RECIEVED
[0583] A10E 8E,44    EXECBK CZ   @PRGFLG           If break or program
[0584] A110 61,37           BS   ERRBRK
[0585] A112 BD,52,2E        DST  @EXTRAM,@FAC8     @FAC8 : Source addr in ERAM
[0586] A115 97,52           DDECT @FAC8            Point to the line #
[0587] A117 06,A6,77        CALL UBSUB1            Reset the breakpoint
[0588] A11A 03              SCAN                   Get break key out of queue
[0589] A11B BD,A3,82 EXEC6C DST  @PGMPTR,V@SPGMPT  Save text pointer
       A11E 2C
[0590] A11F BD,A3,86 EXEC6D DST  @EXTRAM,V@SEXTRM  Save line number table pointe
       A122 2E
[0591] A123 BD,A3,88        DST  @VSPTR,V@SAVEVP   Save value stack pointer
       A126 6E
[0592] A127 BD,A3,84        DST  @BUFLEV,V@SBUFLV  Save crunch buffer level
       A12A 46
[0593] A12B BD,A3,96        DST  @LSUBP,V@SLSUBP   Save last subprogram on stack
       A12E 48
[0594] A12F BC,A3,98        ST   @FLAG,V@SFLAG     Save FLAG for continue
       A132 45
[0595] A133 B2,A3,98        AND  >63,V@SFLAG       Only warning and break bits
       A136 63
[0596] A137 06,6A,84 ERRBRK CALL ERRZZ             * BREAKPOINT
[0597] A13A 01              BYTE 1
[0598]               ***********************************************************
[0599]               *               NUD / STATEMENT BRANCH TABLE
[0600]               ***********************************************************
[0601] A13B 41,7D    NUDTB  BR   RECX              'RECORD'              0
[0602] A13D 45,F6           BR   NBREAK            'BREAK'               0
[0603] A13F 46,08           BR   NUNBRK            'UNBREAK'             0
[0604] A141 45,EC           BR   NTRACE            'TRACE'               0
[0605] A143 45,F1           BR   NUNTRC            'UNTRACE'             0
[0606] A145 41,80           BR   NREADX            'READ'                0
[0607] A147 41,83           BR   PRINTX            'PRINT'               0
[0608] A149 41,7A           BR   SZRUNX            'RUN'                 0
[0609] A14B 41,9B           BR   LINPUX            Reserved for LINPUT   1
[0610] A14D 41,86           BR   RESTOX            'RESTORE'             1
[0611] A14F 43,27           BR   NRNDMZ            'RANDOMIZE'           1
[0612] A151 41,89           BR   INPUTX            'INPUT'               1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0011 
RXB 2022
[0613] A153 41,8C           BR   OPENX             'OPEN'                1
[0614] A155 41,8F           BR   CLOSEX            'CLOSE'               1
[0615] A157 42,3C           BR   NPI               'PI'                  1
[0616] A159 42,4C           BR   NMAX              'MAX'                 1
[0617] A15B 42,59           BR   NMIN              'MIN'                 2
[0618] A15D 45,93           BR   RPTZ01            'RPT$'                2
[0619] A15F 41,92           BR   ACCEPX            'ACCEPT'              2
[0620] A161 41,77           BR   EOFX              'EOF'                 2
[0621] A163 44,6B           BR   ASC01             'ASC'                 2
[0622] A165 45,28           BR   POS01             'POS'                 2
[0623] A167 44,A6           BR   VAL01             'VAL'                 2
[0624] A169 44,7C           BR   STRZ01            'STR$'                2
[0625] A16B 43,E1           BR   SEGZ01            'SEG$'                3
[0626] A16D 41,98           BR   DELETX            'DELETE'              3
[0627] A16F 41,95           BR   DISPLX            'DISPLAY'             3
[0628] A171 44,44           BR   LEN01             'LEN'                 3
[0629] A173 44,50           BR   CHRZ01            'CHR$'                3
[0630]               *RXB PATCH CODE FOR BASIC RND REPLACEMENT ***********
[0631] A175 42,87           BR   NRND              'RND'                 3      
[0632]               * The following are long branches to another GROM
[0633] A177 05,80,1C EOFX   B    EOF
[0634] A17A 05,60,1E SZRUNX B    SZRUN
[0635] A17D 05,80,22 RECX   B    REC
[0636] A180 05,80,0E NREADX B    NREAD
[0637] A183 05,80,04 PRINTX B    PRINT
[0638] A186 05,80,0C RESTOX B    RESTOR
[0639] A189 05,80,06 INPUTX B    INPUT
[0640] A18C 05,80,08 OPENX  B    OPEN
[0641] A18F 05,80,0A CLOSEX B    CLOSE
[0642] A192 05,80,1E ACCEPX B    ACCEPT
[0643] A195 05,80,00 DISPLX B    DISPL1
[0644] A198 05,80,02 DELETX B    DELET
[0645] A19B 05,80,30 LINPUX B    LINPUT
[0646]               ***********************************************************
[0647]               * FLAGS USED IN EXECUTION MODE:    this needs to be checked
[0648]               *  @FLAG   BIT   RESET               SET
[0649]               *           0
[0650]               *           1    Warning PRINT       PRINT off
[0651]               *           2    Warning NEXT        STOP
[0652]               *           3    Not in UDF          Executing a UDF
[0653]               *           4    TRACE mode          Normal mode
[0654]               *           5
[0655]               *           6    BREAK allowed       BREAK not allowed
[0656]               *           7    No LST/EDT protect  LIST/EDIT protected
[0657]               ***********************************************************
[0658]               * ON WARNING {NEXT | STOP | PRINT}
[0659]               * ON WARNING NEXT  - Causes warning messages to be ignored
[0660]               *                    and execution to continue as if a
[0661]               *                    warning never occurred
[0662]               * ON WARNING STOP  - Causes a warning to be treated as an
[0663]               *                    error - i.e. the message is displayed
[0664]               *                    and execution is halted
[0665]               * ON WARNING PRINT - Causes the default warning handling to
[0666]               *                    be in effect, i.e. any warning
[0667]               *                    messages are printed and execution
[0668]               *                    continues
[0669]               ***********************************************************
[0670] A19E 0F,79    ONWARN XML  PGMCHR            GET OPTION
[0671] A1A0 D6,42,9C        CEQ  PRINTZ,@CHAT      If print
[0672] A1A3 41,AB           BR   GA1B7
[0673] A1A5 B2,45,F9        AND  >F9,@FLAG         Turn on print and contiue
[0674] A1A8 05,A1,C3        B    ONWRN5
[0675] A1AB D6,42,98 GA1B7  CEQ  STOPZ,@CHAT
[0676] A1AE 41,B8           BR   GA1C4

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0012 
RXB 2022
[0677] A1B0 B2,45,FD        AND  NUMBEZ,@FLAG         Turn on print
[0678] A1B3 B6,45,04        OR   >04,@FLAG         Turn on stop
[0679] A1B6 41,C3           BR   ONWRN5
[0680] A1B8 D6,42,96 GA1C4  CEQ  NEXTZ,@CHAT       * SYNTAX ERROR
[0681] A1BB 4D,59           BR   ERRSYN
[0682] A1BD B6,45,02        OR   >02,@FLAG         Turn off print
[0683] A1C0 B2,45,FB        AND  >FB,@FLAG         Turn off stop
[0684] A1C3 0F,79    ONWRN5 XML  PGMCHR            Check for EOS
[0685] A1C5 06,6A,78 ONWRN7 CALL CHKEND            Error if not EOS
[0686] A1C8 4D,59           BR   ERRSYN            If not EOS
[0687] A1CA 87,22           DCLR @ERRCOD
[0688] A1CC 0F,75           XML  CONT              Continue
[0689]               ***********************************************************
[0690]               * ON ERROR {line number | STOP}
[0691]               * ON ERROR line number - causes the error routine to build
[0692]               *                        an error stack entry and pass
[0693]               *                        control to the line specified in
[0694]               *                        the most-recently executed
[0695]               *                        on-error-statement
[0696]               * ON ERROR STOP - causes the default error handling
[0697]               *                 conditions to be in effect. i.e. any
[0698]               *                 errors that occur cause execution to halt
[0699]               *                 an a message to be displayed
[0700]               ***********************************************************
[0701] A1CE 0F,79    ONERR  XML  PGMCHR            Get option
[0702] A1D0 D6,42,C9        CEQ  LNZ,@CHAT         If line # then find the line
[0703] A1D3 42,02           BR   GA20E
[0704] A1D5 0F,79           XML  PGMCHR            Get upper byte
[0705] A1D7 BC,4A,42        ST   @CHAT,@FAC
[0706] A1DA 0F,79           XML  PGMCHR            Get lower byte
[0707] A1DC BC,4B,42        ST   @CHAT,@FAC1
[0708] A1DF BD,4C,32        DST  @ENLN,@FAC2
[0709] A1E2 A7,4C,00        DSUB 3,@FAC2           Pointing to 1st line #
       A1E5 03
[0710]               * Consider both ERAM and RAM cases to get line # from the
[0711]               * line number table. Also reset the break bit.
[0712] A1E6 06,80,2E ONERR2 CALL GRSUB3            Get 2 bytes from either RAM/E
[0713] A1E9 4C              BYTE FAC2            * FAC2 has the address
[0714] A1EA D5,4A,58        DCEQ @EEE1,@FAC        If found
[0715] A1ED 61,FA           BS   ONERR4
[0716] A1EF C5,4C,30        DCH  @STLN,@FAC2       Not found
[0717] A1F2 4D,85           BR   ERRLNF
[0718] A1F4 A7,4C,00        DSUB 4,@FAC2           Goto next line
       A1F7 04
[0719] A1F8 41,E6           BR   ONERR2
[0720] A1FA 95,4C    ONERR4 DINCT @FAC2
[0721] A1FC BD,A3,8A        DST  @FAC2,V@ERRLN
       A1FF 4C
[0722] A200 42,0A           BR   GA216
[0723] A202 D6,42,98 GA20E  CEQ  STOPZ,@CHAT       * SYNTAX ERROR
[0724] A205 4D,59           BR   ERRSYN
[0725] A207 87,A3,8A        DCLR V@ERRLN           Back to default error handlin
[0726] A20A 41,C3    GA216  BR   ONWRN5            Finish up same as ON WARNING
[0727]               ***********************************************************
[0728]               * ON BREAK {NEXT | STOP}
[0729]               * ON BREAK NEXT - Causes any breakpoints which have been
[0730]               *                 set on statements to be ignored when the
[0731]               *                 statement is encountered and also masks
[0732]               *                 the shift-C key so that it is ignored
[0733]               * ON BREAK STOP - Causes the default break handling to be
[0734]               *                 in force., i.e. execution is halted and
[0735]               *                 the BREAKPOINT message is displayed on
[0736]               *                 the screen
[0737]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0013 
RXB 2022
[0738] A20C 0F,79    ONBRK  XML  PGMCHR            Get next char to find option
[0739] A20E D6,42,98        CEQ  STOPZ,@CHAT       If stop option specified
[0740] A211 42,19           BR   GA225
[0741] A213 B2,45,BF        AND  >BF,@FLAG         break allowed
[0742] A216 05,A2,21        B    GA22D             Don't change this to BR GA22D
[0743] A219 D6,42,96 GA225  CEQ  NEXTZ,@CHAT       If next option number
[0744] A21C 4D,59           BR   ERRSYN            specified then syntax error
[0745] A21E B6,45,40        OR   >40,@FLAG         If next option specified then
[0746]               *                              break NOT allowed
[0747] A221 41,C3    GA22D  BR   ONWRN5            Finish up same as ON WARNING
[0748]               ***********************************************************
[0749]               * GPLCAL - If a call is made to a subprogram that does not
[0750]               *  not exist either in the BASIC program itself or in the
[0751]               *  internal GPL subprogram list then one final attempt is
[0752]               *  made to find the subprogram at execution time by
[0753]               *  searching for the subprogram in the console or a
[0754]               *  peripheral. If not found there, then a
[0755]               *  *SUBPROGRAM NOT FOUND error occurs
[0756]               *
[0757]               *  Input: the subprogram name is in the FAC and the length
[0758]               *         of the name is in FAC15
[0759]               ***********************************************************
[0760] A223 8E,80,89 GPLCAL CZ   @RAMFLG           Can't try if CPU program
[0761] A226 4D,95           BR   ERRSNF
[0762] A228 E7,59,00        DSRL 8,@FAC15          Make name length a double
       A22B 08
[0763] A22C A5,2C,59        DSUB @FAC15,@PGMPTR    Point back at name
[0764] A22F 93,2C           DDEC @PGMPTR           Point at name length
[0765] A231 BD,56,2C        DST  @PGMPTR,@FAC12    Set pointer to name
[0766] A234 06,00,10        CALL LINK              Issue 'Call Program Link'
[0767] A237 0A              BYTE 10              * Search subprogram lists
[0768] A238 41,C5           BR   ONWRN7            If all ok, check-end and rtn
[0769] A23A 4D,95           BR   ERRSNF            If not found, error
[0770]               ***********************************************************
[0771]               *                     NUD FOR PI
[0772]               ***********************************************************
[0773] A23C 31,00,08 NPI    MOVE 8,G@CONPI,@FAC    Load constant PI
       A23F 4A,A2,44
[0774] A242 0F,75           XML  CONT
[0775] A244 40,03,0E CONPI  BYTE >40,3,14,15,92,65,35,90
       A247 0F,5C,41
       A24A 23,5A
[0776]               * 3.1415992653590E+00
[0777]               ***********************************************************
[0778]               *                     NUD FOR MAX
[0779]               ***********************************************************
[0780] A24C 06,A2,61 NMAX   CALL MAXMIN            Combine MAX and MIN
[0781] A24F 0A              GT
[0782] A250 42,57           BR   GA263
[0783] A252 35,00,08 NMAXZ1 MOVE 8,@ARG,@FAC
       A255 4A,5C
[0784] A257 0F,75    GA263  XML  CONT
[0785]               ***********************************************************
[0786]               *                     NUD FOR MIN
[0787]               ***********************************************************
[0788] A259 06,A2,61 NMIN   CALL MAXMIN            Combine MAX and MIN again
[0789] A25C 0A              GT
[0790] A25D 42,52           BR   NMAXZ1
[0791] A25F 0F,75           XML  CONT
[0792]               ***********************************************************
[0793]               *                COMMON MAX / MIN ROUTINE
[0794]               ***********************************************************
[0795] A261 06,AC,3F MAXMIN CALL LPARR             Skip "(" parse, and insure ,
[0796] A264 C6,4C,63        CH   >63,@FAC2         Must be numeric

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0014 
RXB 2022
[0797] A267 6D,5D           BS   ERRSNM
[0798] A269 0F,77           XML  VPUSH             Push l.h. arg on stack
[0799] A26B 0F,74           XML  PARSE             PARSE up to ")"
[0800] A26D B6              BYTE RPARZ
[0801] A26E C6,4C,63        CH   >63,@FAC2         Must be numeric
[0802] A271 6D,5D           BS   ERRSNM
[0803] A273 0F,7E           XML  SPEED             Must be
[0804] A275 00              BYTE SYNCHK        *    at a
[0805] A276 B6              BYTE RPARZ         *      right parenthesis
[0806] A277 35,00,08        MOVE 8,@FAC,@ARG       Save in ARG for compare
       A27A 5C,4A
[0807] A27C 0F,78           XML  VPOP              Get l.h. arg back
[0808] A27E 0F,0A           XML  FCOMP             Compare operands
[0809] A280 00              RTN
[0810]               ***********************************************************
[0811]               * RXB PATCH CODE FOR INTRND
[0812] A281 BF,80,C0 INTRND DST  >3567,@>83C0      Random number seed
       A284 35,67
[0813] A286 00              RTN
[0814]               ***********************************************************
[0815]               * RXB BASIC RND REPLACEMENT FROM TI BASIC
[0816] A287 BE,4A,3F NRND   ST   >3F,@FAC       * Exponent    
[0817] A28A BE,10,4B        ST   >4B,@VAR5      * Loop counter
[0818] A28D 02,63    NRND1  RAND >63            * 0?
[0819] A28F 8E,78           CZ   @RANDOM        * No, go on
[0820] A291 42,9D           BR   NRND3     
[0821] A293 92,4A           DEC  @FAC           * 0?
[0822] A295 8E,4A           CZ   @FAC           * End with 0
[0823] A297 62,AA           BS   NRND4          * Go on
[0824] A299 42,8D           BR   NRND1
[0825] A29B 02,63    NRND2  RAND >63            * Till 100
[0826] A29D BC,90,10 NRND3  ST   @RANDOM,*VAR5  * All digits
       A2A0 78
[0827] A2A1 D6,10,51        CEQ  >51,@VAR5      * Till >8351
[0828] A2A4 62,AC           BS   NRND5 
[0829] A2A6 90,10           INC  @VAR5          * Increase loop counter
[0830] A2A8 42,9B           BR   NRND2 
[0831] A2AA 86,4B    NRND4  CLR  @FAC1          * Set 0
[0832] A2AC 0F,75    NRND5  XML  CONT
[0833]               ***********************************************************
[0834] A2AE 0F,79    STRFCH XML  PGMCHR    * SKIP whatever
[0835] A2B0 0F,74    STRPAR XML  PARSE     * Parse value/variable
[0836] A2B2 B6              BYTE RPARZ     * )?
[0837] A2B3 00              RTN
[0838]               ***********************
[0839] A2B4 06,A2,AE STRGET CALL STRFCH    * Skip,Parse,)?
[0840] A2B7 D6,4C,65        CEQ  >65,@FAC2 * String?  
[0841] A2BA 4D,5D           BR   ERRSNM    * No, STRING NUM MISMATCH
[0842] A2BC 00              RTN
[0843]               ***********************
[0844] A2BD 06,A2,AE NUMFCH CALL STRFCH    * Skip,Parse,)?
[0845] A2C0 D6,4C,65 NUMSNM CEQ  >65,@FAC2 * String? 
[0846] A2C3 6D,5D           BS   ERRSNM    * Yes, STRING NUM MISMATCH
[0847] A2C5 00              RTN
[0848]               ***********************
[0849] A2C6 0F,12    CFIFCH XML  CFI       * Convert FP to Integer
[0850] A2C8 D6,54,03        CEQ  >03,@FAC+10 * Check for OVERFOW?
[0851] A2CB 6D,8D           BS   ERRBV     * NUMERIC OVERFLOW
[0852] A2CD 00              RTN
[0853]               ***********************
[0854] A2CE 06,A2,D7 GETNUM CALL SUBLP3    * NUMFCH,CFIFCH
[0855] A2D1 D6,42,B3 GNRTN  CEQ  COMMAZ,@CHAT * COMMA?
[0856] A2D4 4D,59           BR   ERRSYN    * No SYNTAX ERROR
[0857] A2D6 00              RTN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0015 
RXB 2022
[0858]               ***********************
[0859] A2D7 06,A2,BD SUBLP3 CALL NUMFCH    * NUMFCH,Number?
[0860] A2DA 06,A2,C6        CALL CFIFCH    * CFI 
[0861] A2DD 00              RTN
[0862]               ***********************
[0863] A2DE 06,A2,B0 SUBLP4 CALL STRPAR    * Parse
[0864] A2E1 06,A2,C6        CALL CFIFCH    * CFI
[0865] A2E4 05,A2,D1        B    GNRTN     * Comma? 
[0866]               ***********************
[0867] A2E7 0F,79    NGOOD  XML  PGMCHR    * Skip whatever 
[0868] A2E9 CA,42,80 NGOOD1 CHE  >80,@CHAT * Token
[0869] A2EC 6D,59           BS   ERRSYN    * Yes, SYNTAX ERROR
[0870] A2EE 06,A3,02        CALL SNDER   
[0871] A2F1 D6,4C,65        CEQ  >65,@FAC2 * String?   
[0872] A2F4 4D,5D           BR   ERRSNM    * No,STRING NUMBER MISMATCH
[0873] A2F6 BF,4A,00        DST  >001C,@FAC * Length
       A2F9 1C
[0874] A2FA BD,4E,1C        DST  @SREF,@FAC4 * String Location
[0875] A2FD BD,50,0C        DST  @BYTES,@FAC6 * Number of bytes
[0876] A300 43,0B           BR   SNDASS    * Send and Assign
[0877] A302 0F,7A    SNDER  XML  SYM       * Find Symbol table entry  
[0878] A304 0F,7B           XML  SMB       * Find Symbol entry
[0879] A306 0F,77           XML  VPUSH     * Push on value stack
[0880] A308 00              RTN
[0881]               ***********************
[0882] A309 0F,80    CIFSND XML  CIF       * Convert Integer to FP
[0883] A30B 0F,7C    SNDASS XML  ASSGNV    * Assign value to Variable
[0884] A30D 00              RTN
[0885]               ***********************
[0886] A30E BC,00,7D GETLP  ST   @CB,@PAD  * CB in PAD(character buffer) 
[0887] A311 BC,01,7D        ST   @CB,@PAD1 * CB in PAD1
[0888] A314 A6,01,60        SUB  OFFSET,@PAD1 * Remove OFFSET VDP value
[0889] A317 BC,E0,00        ST   @PAD1,V@0(@STRPTR) * new value
       A31A 12,01
[0890] A31C 91,12           DINC @STRPTR   * Count increased 
[0891] A31E 00              RTN
[0892]               *********************
[0893] A31F 86,4A    CLRFAC CLR  @FAC    * FAC=0
[0894] A321 35,00,07        MOVE 7,@FAC,@FAC1 * Ripple
       A324 4B,4A
[0895] A326 00              RTN
[0896]               ***********************************************************
[0897]               *                   RANDOMIZE STATEMENT
[0898]               ***********************************************************
[0899]               * RXB PATCH RAMDOMIZE and RANDOMIZE SEED replaced         *
[0900]               ***********************************************************
[0901] A327 06,6A,78 NRNDMZ CALL CHKEND            Seed provider?
[0902] A32A 63,38           BS   RNDM1             No
[0903]               * RANDOMIZE given a see value
[0904]               * (99,000,000,000,001 possible starting positions)
[0905]               * (Place-value is ignored in the input number)
[0906] A32C 0F,74           XML  PARSE             Parse the seed
[0907] A32E 83              BYTE TREMZ           * Up to end of statement
[0908] A32F 06,A3,3E        CALL CKSTNM
[0909]               * TI BASIC RAMDOMIZE SEED ***
[0910] A332 BD,80,C0        DST @>834A,@>83C0 Quotation on random number seed
       A335 4A
[0911] A336 0F,75    NRNDCT XML  CONT
[0912]               ******************************
[0913]               * TI BASIC RANDOMIZE no seed ***
[0914] A338 BC,80,C1 RNDM1  ST   @>8379,@>83C1
       A33B 79
[0915] A33C 0F,75           XML  CONT
[0916] A33E D6,4C,65 CKSTNM CEQ  >65,@FAC2

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0016 
RXB 2022
[0917] A341 6D,5D           BS   ERRSNM
[0918] A343 00              RTN
[0919]               ***********************************************************
[0920] A344 40,01,00 FLT1   BYTE >40,>01,>00,>00,>00,>00,>00,>00
       A347 00,00,00
       A34A 00,00
[0921]               ***********************************************************
[0922]               *                 EXTENDED STRING PACKAGE
[0923]               * THE ROUTINES ARE:
[0924]               *  LITS05 - Move a string literal from the program to the
[0925]               *            string space
[0926]               *  INTARG - Checks that an argument is a numeric and
[0927]               *            converts it from floating point to an integer
[0928]               *  PUSSTR - Checks that an argument is a string and pushes
[0929]               *            it on the stack
[0930]               *  CONCAT - Concatenates 2 strings together
[0931]               *  SEG$   - Segments a string
[0932]               *  LEN    - Puts the length of a string in the FAC
[0933]               *  CHR$   - Converts an integer into its ASCII character
[0934]               *  STR$   - Converts a number into its string equivalent
[0935]               *  VAL    - Converts a string into its numeric equivalent
[0936]               *  POS    - Gives the position of one string within another
[0937]               *  RPT$   - Generates a single string with multiple copies
[0938]               *            of the original string
[0939]               *
[0940]               *      AN ENTRY IN THE FAC LOOKS LIKE:
[0941]               * +------------+-----+----+-------------+-----------------+
[0942]               * |addr of ptr | >65 | xx | addr of str | length of str   |
[0943]               * +------------+-----+----+-------------+-----------------+
[0944]               *     FAC       FAC2  FAC3   FAC4           FAC6
[0945]               ***********************************************************
[0946]               * Support routine for functions to build FAC entry
[0947] A34C 86,50    LITS05 CLR  @FAC6             Need as a double-byte value
[0948] A34E BD,0C,50        DST  @FAC6,@BYTES      LENGTH FOR GETSTR
[0949] A351 BC,52,80        ST   @RAMTOP,@FAC8     Copy ERAM flag for later
       A354 84
[0950] A355 0F,71    LITS07 XML  GETSTR            ALLOCATE STRING SPACE
[0951] A357 BF,4A,00 LITS08 DST  >001C,@FAC        SAVE ADDR OF STRING  (SREF)
       A35A 1C
[0952] A35B BD,4E,1C        DST  @SREF,@FAC4       SAVE ADDR OF STRING
[0953] A35E BF,4C,65        DST  >6500,@FAC2       INDICATES A STRING CONSTANT
       A361 00
[0954]               *********** COPY STRING INTO STRING SPACE *****************
[0955] A362 8F,0C    LITS09 DCZ  @BYTES            If non-null string
[0956] A364 63,7C           BS   GA42B
[0957] A366 8E,52           CZ   @FAC8
[0958] A368 43,71           BR   GA420
[0959] A36A 34,0C,B0        MOVE @BYTES,V*TEMP5,V*SREF
       A36D 1C,B0,66
[0960] A370 00              RTN
[0961]               *                             Else source string in ERAM
[0962] A371 BD,56,0C GA420  DST  @BYTES,@FFF1      FFF1 : BYTE COUNT
[0963] A374 BD,58,1C        DST  @SREF,@EEE1       EEE1 : DESTINATION ADDR ON VD
[0964] A377 BD,54,66        DST  @TEMP5,@DDD1      DDD1 : Source addr in ERAM
[0965] A37A 0F,8B           XML  GVWITE            Move data from ERAM to VDP
[0966] A37C 00       GA42B  RTN
[0967] A37D 86,52    LITS06 CLR  @FAC8             SET FLAG TO VDP
[0968] A37F 43,55           BR   LITS07            JUMP INTO CODE
[0969]               ***********************************************************
[0970]               * PUSSTR - Insures that the entry in the FAC is a string
[0971]               *           and pushes it onto the stack.
[0972]               ***********************************************************
[0973] A381 D6,4C,65 PUSSTR CEQ  >65,@FAC2
[0974] A384 4D,5D           BR   ERRSNM

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0017 
RXB 2022
[0975] A386 0F,77           XML  VPUSH             PUSH THE ARGUMENT
[0976] A388 00              RTN
[0977]               ***********************************************************
[0978]               * CONCAT - CONCATENATES TWO STRINGS TOGETHER
[0979]               *         INPUT  : FLOATING POINT ACCUMULATOR ENTRIES
[0980]               *         OUTPUT : CONCATENATED STRING AND (POSSIBLE)
[0981]               *                  ZEROED BACK-POINTERS FOR THE OLD STRINGS
[0982]               *         USES   : TEMP2, TEMP4 AND TEMP5 AS TEMPORARIES
[0983]               ***********************************************************
[0984] A389 86,23    CONCAT CLR  @ERRCOD+1         CLEAR THE ERROR CODE
[0985] A38B 06,A3,81        CALL PUSSTR            Push the string & get next to
[0986] A38E 0F,74           XML  PARSE             GET THE R.H. ARGUMENT
[0987] A390 B8              BYTE CONCZ
[0988] A391 D6,4C,65        CEQ  >65,@FAC2         If not string - error
[0989] A394 4D,5D           BR   ERRSNM
[0990] A396 BD,0C,50        DST  @FAC6,@BYTES      GET R.H. LENGTH
[0991] A399 A1,0C,E0        DADD V@6(@VSPTR),@BYTES    ADD IN L.H. LENGTH
       A39C 06,6E
[0992] A39E C7,0C,00        DCH  255,@BYTES
       A3A1 FF
[0993] A3A2 43,AC           BR   GA45B
[0994] A3A4 BF,0C,00        DST  255,@BYTES        TRUNCATE IF TOO LONG
       A3A7 FF
[0995] A3A8 06,6A,82 WRNST1 CALL WARNZZ            Display warning
[0996] A3AB 13              BYTE 19                * STRING TRUNCATED message
[0997] A3AC BD,68,0C GA45B  DST  @BYTES,@TEMP6     Keep length for later
[0998] A3AF 0F,77           XML  VPUSH
[0999] A3B1 0F,71           XML  GETSTR            Alloccate the result string
[1000] A3B3 0F,78           XML  VPOP              Retrieve R.H.
[1001] A3B5 35,00,08        MOVE 8,@FAC,@ARG
       A3B8 5C,4A
[1002] A3BA 0F,78           XML  VPOP              Retrieve L.H.
[1003] A3BC BD,66,4E        DST  @FAC4,@TEMP5      Set ptr to L.H. ARG(for FREST
[1004] A3BF BD,0C,50        DST  @FAC6,@BYTES      Length of L.H. ARG
[1005] A3C2 86,52           CLR  @FAC8             Force VDP mode
[1006] A3C4 06,A3,57        CALL LITS08            Set up FAC & copy L.H. ARG in
[1007] A3C7 8F,62           DCZ  @ARG6             If R.H. =0 don't copy
[1008] A3C9 63,DF           BS   CONC06
[1009] A3CB BD,64,1C        DST  @SREF,@TEMP4      Get ptr to new string
[1010] A3CE A1,64,50        DADD @FAC6,@TEMP4      Ptr to where 2nd string begin
[1011] A3D1 A5,68,50        DSUB @FAC6,@TEMP6      Length of 2nd string
[1012]               *                                      (possibly truncated)
[1013] A3D4 63,DF           BS   CONC06
[1014] A3D6 34,68,B0        MOVE @TEMP6,V*ARG4,V*TEMP4     Copy in 2nd string
       A3D9 64,B0,60
[1015]                
[1016] A3DC A1,50,68        DADD @TEMP6,@FAC6      Add in length of 2nd ARG
[1017]               * NOTE: FAC6 already contained length of 1st ARG from the
[1018]               *       parse that was done on it
[1019] A3DF 0F,75    CONC06 XML  CONT              Done.
[1020]               ***********************************************************
[1021]               * SEG$(A$,X,Y) - Extracts the desiginated string from A$.
[1022]               *     X specifies the character position within A$ at
[1023]               *     which the extraction begins. Y specifies the number
[1024]               *     of characters to extract.
[1025]               *     If X or Y is negative an error occurs. If X=0 an
[1026]               *     error occurs. If Y=0 or X > Y then a null string is
[1027]               *     is returned. If the ramaining length in A$ starting
[1028]               *     at the postion specified by X is less than the length
[1029]               *     specified by Y, then the remainder of A$ starting at
[1030]               *     position X is returned.
[1031]               *   INPUT - Control is turned over to SEG$ from PARSE. The
[1032]               *     only requirement is that a SEG$ was encountered.
[1033]               *   OUTPUT - The Floating Point Accumulator is set up with

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0018 
RXB 2022
[1034]               *     the header for the segmented string.
[1035]               *   USES - TEMP2 (Others in calls to GETSTR and LITS08)
[1036]               ***********************************************************
[1037] A3E1 06,AC,3F SEGZ01 CALL LPARR             Insure "(" parse and check ",
[1038] A3E4 06,A3,81        CALL PUSSTR            Push string and get next toke
[1039] A3E7 0F,7E           XML  SPEED             Get the position
[1040] A3E9 01              BYTE PARCOM       *     within the source string
[1041] A3EA 06,A8,DD        CALL INTARG            CHECK & CONVERT ARG TO INTEGE
[1042] A3ED 8F,4A           DCZ  @FAC               CAN'T HAVE VALUE OF 0
[1043] A3EF 6D,8D           BS   ERRBV
[1044] A3F1 0F,77           XML  VPUSH             PUSH THE ARG
[1045] A3F3 0F,74           XML  PARSE             Get extraction length
[1046] A3F5 B6              BYTE RPARZ
[1047] A3F6 0F,7E           XML  SPEED             Must have
[1048] A3F8 00              BYTE SYNCHK       *     ended on
[1049] A3F9 B6              BYTE RPARZ        *      a right parenthesis
[1050] A3FA 06,A8,DD        CALL INTARG            CHECK & CONVERT ARG TO INTEGE
[1051] A3FD BD,5C,4A        DST  @FAC,@ARG         Move extraction length
[1052] A400 0F,78           XML  VPOP              Get position back
[1053] A402 BD,5E,4A        DST  @FAC,@ARG2        Move position
[1054] A405 0F,78           XML  VPOP              Retrieve source string
[1055] A407 BD,56,5E        DST  @ARG2,@TEMP2      Get position within string
[1056] A40A C5,56,50        DCH  @FAC6,@TEMP2      If position > length =>null
[1057] A40D 64,40           BS   SEGZ08
[1058] A40F A1,56,5C        DADD @ARG,@TEMP2       Compute end of substring
[1059] A412 A5,56,50        DSUB @FAC6,@TEMP2      Compute length beyond end
[1060] A415 93,56           DDEC @TEMP2             string
[1061] A417 D3,56,00        DCGE 0,@TEMP2
       A41A 00
[1062] A41B 44,25           BR   SEGZ06            Fine if substring is shorter
[1063] A41D BD,5C,50        DST  @FAC6,@ARG        Else, truncate length of
[1064]               *                              substring
[1065] A420 A5,5C,5E        DSUB @ARG2,@ARG        Subtract position from source
[1066]               *                              length
[1067] A423 91,5C           DINC @ARG              Increment to include last cha
[1068] A425 BD,0C,5C SEGZ06 DST  @ARG,@BYTES       # of bytes needed for substri
[1069] A428 0F,77           XML  VPUSH             Save source string entry
[1070] A42A 0F,71           XML  GETSTR            ALLOCATE RESULT STRING
[1071] A42C 0F,78           XML  VPOP              Restore source string entry
[1072] A42E BD,66,4E        DST  @FAC4,@TEMP5      Pointer to source for FRESTR
[1073]               *                              LITS08
[1074] A431 A1,66,5E        DADD @ARG2,@TEMP5      Pointer to start of substring
[1075] A434 93,66           DDEC @TEMP5            Decrement since zero-based
[1076] A436 BD,50,0C        DST  @BYTES,@FAC6      Set length of string
[1077] A439 86,52           CLR  @FAC8             FORCE VDP MODE
[1078] A43B 06,A3,57        CALL LITS08            Copy in & set up FAC
[1079] A43E 0F,75           XML  CONT
[1080] A440 87,5C    SEGZ08 DCLR @ARG              Extract a null string
[1081] A442 44,25           BR   SEGZ06            >>>JUMP ALWAYS<<<
[1082]               ***********************************************************
[1083]               * LEN(A$) - Calculate the length of a string and leave the
[1084]               *           result in the FAC.
[1085]               * CONTROL - Turned over to NLEN from the parser.
[1086]               * USES    - No temporaries.
[1087]               ***********************************************************
[1088] A444 06,A4,D2 LEN01  CALL PARFF             Insure left parenthesis & par
[1089] A447 4D,5D           BR   ERRSNM             If not string value
[1090] A449 BD,4A,50        DST  @FAC6,@FAC        Length
[1091] A44C 0F,80    LEN02  XML  CIF               Convert integer to floating p
[1092] A44E 0F,75           XML  CONT
[1093]               ***********************************************************
[1094]               * CHR$(X) - Takes integer value X and converts the number
[1095]               *           into the ASCII representation for that number.
[1096]               * CONTROL - Turned over to NCHR by the parser.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0019 
RXB 2022
[1097]               * OUTPUT  - FAC is set up with the string entry
[1098]               * USES    - Uses temproraries when invoking LITS06(LITSTR)
[1099]               ***********************************************************
[1100] A450 06,A4,D2 CHRZ01 CALL PARFF             Insure left parenthesis & par
[1101] A453 06,A8,DD        CALL INTARG            Convert into integer
[1102] A456 BF,0C,00        DST  1,@BYTES          Create a length 1 string
       A459 01
[1103] A45A BC,A3,78        ST   @FAC1,V@ONECHR    Move the value to VDP(for LIT
       A45D 4B
[1104] A45E BF,66,03        DST  ONECHR,@TEMP5     Address of character
       A461 78
[1105] A462 06,A3,7D        CALL LITS06            Create string and set up FAC
[1106] A465 BF,50,00        DST  1,@FAC6           Length of string
       A468 01
[1107] A469 0F,75           XML  CONT
[1108]               ***********************************************************
[1109]               * ASC(A$) - Takes the numeric value of the first character
[1110]               *           in A$.
[1111]               ***********************************************************
[1112] A46B 06,A4,D2 ASC01  CALL PARFF             Insure left parenthesis & par
[1113] A46E 4D,5D           BR   ERRSNM            If not string
[1114] A470 8E,51           CZ   @FAC7             Empty string?
[1115] A472 6D,89           BS   ERRBA             ERROR BAD ARGUMENT
[1116] A474 BC,4B,B0 ASC02  ST   V*FAC4,@FAC1      Get the first character
       A477 4E
[1117] A478 86,4A           CLR  @FAC              Clear first byte
[1118] A47A 44,4C           BR   LEN02             USE COMMON CODE >>>JUMP ALWAY
[1119]               ***********************************************************
[1120]               * STR$(X) - Takes as its imput an integer X and converts it
[1121]               *           to its string representation.
[1122]               * CONTROL - Turned over to STR$ by the parser.
[1123]               * USES    - The usual temporaries used by string function
[1124]               *           when it calls LITS06. Uses the Roll-out area
[1125]               *           for a temporary storage area when allocating
[1126]               *           the result string.
[1127]               * OUTPUT  - FAC is set up in the usual manner for a string
[1128]               ***********************************************************
[1129] A47C 06,A4,D2 STRZ01 CALL PARFF             Insure left parenthesis & par
[1130] A47F 6D,5D           BS   ERRSNM             If not numeric-error
[1131] A481 86,55    STRZ02 CLR  @FAC11            Select XB floating type
[1132] A483 0F,73           XML  XBCNS             Convert the number to string
[1133] A485 D6,90,55        CEQ  SPACE,*FAC11      If leading space
       A488 20
[1134] A489 44,8F           BR   GA53E
[1135] A48B 90,55           INC  @FAC11            Suppress it out
[1136] A48D 92,56           DEC  @FAC12            Shorten the length
[1137] A48F 86,0C    GA53E  CLR  @BYTES            Prepare for 2-byte value
[1138] A491 BC,0D,56        ST   @FAC12,@BYTES+1   Get length of string
[1139] A494 34,0C,A3        MOVE @BYTES,*FAC11,V@VROAZ    Put the string in VDP
       A497 C0,90,55
[1140] A49A BF,66,03        DST  VROAZ,@TEMP5      Copy-from address(for LITSTR)
       A49D C0
[1141] A49E 06,A3,7D        CALL LITS06            Allocate and set up FAC
[1142] A4A1 BD,50,0C        DST  @BYTES,@FAC6      Put in the length
[1143] A4A4 0F,75           XML  CONT
[1144]               ***********************************************************
[1145]               * VAL(A$) - Takes as its input a string, A$, and converts
[1146]               *           the string into a number if the string is a
[1147]               *           valid representation of a number.
[1148]               * VAL(A$) - The > is a flag that says number is Hexidecimal
[1149]               *  CONTROL - From the parser.
[1150]               *  OUTPUT  - FAC contains the floating point number.
[1151]               ***********************************************************
[1152] A4A6 06,A4,D2 VAL01  CALL PARFF         Insure left parenthesis & par

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0020 
RXB 2022
[1153] A4A9 4D,5D           BR   ERRSNM        If not string - error
[1154] A4AB 8F,50           DCZ  @FAC6         Can't have null string
[1155] A4AD 6D,89           BS   ERRBA         ERROR BAD ARGUMENT
[1156] A4AF D6,B0,4E        CEQ  62,V*FAC4     > ?
       A4B2 3E
[1157] A4B3 44,CB           BR   VALNUM        No
[1158] A4B5 06,B7,38        CALL HEXSTR        ASC to HEX
[1159] A4B8 06,A3,1F VAL05  CALL CLRFAC        Clear FAC
[1160] A4BB 86,8F,DD        CLR  @>6004        Set ROM 3 page
       A4BE 04
[1161] A4BF 0F,76           XML  ASCHEX        Convert ASC to HEX 
[1162] A4C1 D7,5C,99        DCEQ >994A,@ARG    ERROR FLAG?
       A4C4 4A
[1163] A4C5 6D,89           BS   ERRBA         ERROR BAD ARGUMENT
[1164] A4C7 0F,80           XML  CIF           Convert integer to floating point
[1165] A4C9 0F,75           XML  CONT          Return to XB
[1166]               ************************
[1167] A4CB 06,A4,DC VALNUM CALL VALCD         So bad argument error
[1168] A4CE 6D,89           BS   ERRBA
[1169] A4D0 0F,75           XML  CONT
[1170]               * Short routine to parse a single argument enclosed in
[1171]               *  parenthesis for a function or a subprogram and set
[1172]               *  condition based upon whether the value parsed was a
[1173]               *  string or a numeric.
[1174] A4D2 06,A9,21 PARFF  CALL COMB
[1175] A4D5 0F,74           XML  PARSE
[1176] A4D7 FF              BYTE >FF               *
[1177] A4D8 D6,4C,65        CEQ  >65,@FAC2
[1178] A4DB 01              RTNC
[1179]               **************************
[1180] A4DC BD,66,4E VALCD  DST  @FAC4,@TEMP5  Pointer to string
[1181] A4DF A1,66,50        DADD @FAC6,@TEMP5  Pointer to trailing length byte
[1182] A4E2 BD,0C,50        DST  @FAC6,@BYTES  For suppressing trailing blank
[1183] A4E5 91,0C           DINC @BYTES        Prepare for undue subtraction
[1184] A4E7 93,66    GA57C  DDEC @TEMP5        Keep track of end of string
[1185] A4E9 93,0C           DDEC @BYTES        Decrease length of string
[1186] A4EB 65,24           BS   RTNSET        End up with empty string,
[1187] A4ED D6,B0,66        CEQ  SPACE,V*TEMP5 Wild trailing blanks
       A4F0 20
[1188] A4F1 64,E7           BS   GA57C
[1189] A4F3 91,0C           DINC @BYTES        Allow for terminator
[1190] A4F5 0F,77           XML  VPUSH         Save the ptr to the string
[1191] A4F7 0F,71           XML  GETSTR        Get a new string
[1192] A4F9 0F,78           XML  VPOP          Retrieve the ptr to the string
[1193] A4FB BD,66,4E        DST  @FAC4,@TEMP5  Get the ptr to the string
[1194] A4FE 86,52           CLR  @FAC8         Force VDP mode
[1195] A500 06,A3,62        CALL LITS09        Copy the string and set up FAC
[1196] A503 A1,0C,1C        DADD @SREF,@BYTES  Point to the trailing length
[1197] A506 93,0C           DDEC @BYTES        Point at the last character
[1198] A508 BE,B0,0C        ST   SPACE,V*BYTES Put in the terminator
       A50B 20
[1199] A50C BD,56,1C        DST  @SREF,@FAC12  Address for the conversion
[1200] A50F D6,B0,56 GA5A4  CEQ  SPACE,V*FAC12 While leading spaces
       A512 20
[1201] A513 45,19           BR   GA5AE
[1202] A515 91,56           DINC @FAC12        Skip leading blank
[1203] A517 45,0F           BR   GA5A4
[1204] A519 86,4C    GA5AE  CLR  @FAC2         Get rid of string (in case=0)
[1205] A51B 86,54           CLR  @FAC10        Assume no error
[1206] A51D 0F,10           XML  CSNUM         Convert it
[1207] A51F D5,56,0C        DCEQ @BYTES,@FAC12 Convert all of it?
[1208] A522 68,5C           BS   WRNNO         Yes, check overflow & return
[1209] A524 D4,00,00 RTNSET CEQ  @PAD,@PAD     No, return with condition set
[1210] A527 01              RTNC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0021 
RXB 2022
[1211]               ***********************************************************
[1212]               * POS(A$,B$,X) - Attempts to match the string, B$, in A$
[1213]               *    beginning at character # X in A$. If X is > LEN(A$), a
[1214]               *    match is not found or A$ is the null string then the
[1215]               *    returned value is 0. If B$ is the null string then the
[1216]               *    returned value is 1. Otherwise, the returned value is
[1217]               *    the column # of the 1st character matched in A$
[1218]               *  CONTROL - Fromn the parser. Returned through common code
[1219]               *            IN LEN.
[1220]               *  USES    - Not temporaries - Utilizes FAC and ARG.
[1221]               ***********************************************************
[1222] A528 06,AC,3F POS01  CALL LPARR             Insure "(", parse , insure ",
[1223] A52B 06,A3,81        CALL PUSSTR            STACK THE STRING AND GET TOKE
[1224] A52E 0F,7E           XML  SPEED             Parse the match string and
[1225] A530 01              BYTE PARCOM      *      insure end on comma
[1226] A531 06,A3,81        CALL PUSSTR            STACK THE STRING AND GET TOKE
[1227] A534 0F,74           XML  PARSE             Get position
[1228] A536 B6              BYTE RPARZ
[1229] A537 0F,7E           XML  SPEED             Must have
[1230] A539 00              BYTE SYNCHK          *  ended on a
[1231] A53A B6              BYTE RPARZ           *   right parenthesis
[1232] A53B 06,A8,DD        CALL INTARG            Check and convert it
[1233] A53E 8F,4A           DCZ  @FAC              Value out of range
[1234] A540 6D,8D           BS   ERRBV
[1235] A542 BD,0C,4A        DST  @FAC,@BYTES       Keep the offset
[1236] A545 93,0C           DDEC @BYTES            Correct for position 0
[1237] A547 0F,78           XML  VPOP              Get match string back
[1238] A549 35,00,08        MOVE 8,@FAC,@ARG       Put match in ARG
       A54C 5C,4A
[1239] A54E 0F,78           XML  VPOP              Get source back
[1240] A550 8E,51           CZ   @FAC7             If source null
[1241] A552 65,8F           BS   POS12
[1242] A554 C4,51,0D        CH   @BYTES+1,@FAC7    OFFSET > LENGTH?
[1243] A557 45,8F           BR   POS12             Yes, no match possible
[1244] A559 8E,63           CZ   @ARG7             If null string
[1245] A55B 65,80           BS   POS06
[1246] A55D A1,4E,0C        DADD @BYTES,@FAC4      Adjust ptr for offset
[1247] A560 A4,51,0D        SUB  @BYTES+1,@FAC7    Adjust length
[1248] A563 C8,51,63 POS02  CHE  @ARG7,@FAC7       Enough space left for a match
[1249] A566 45,8F           BR   POS12             No, no match possible
[1250] A568 BD,4A,4E        DST  @FAC4,@FAC        Get first ARG
[1251] A56B BD,5C,60        DST  @ARG4,@ARG        Get second ARG
[1252] A56E BC,64,63        ST   @ARG7,@ARG8       And length of second
[1253] A571 D4,B0,5C POS04  CEQ  V*FAC,V*ARG       Compare the characters
       A574 B0,4A
[1254] A576 45,87           BR   POS10             Didn't match
[1255] A578 91,4A           DINC @FAC              Next in source
[1256] A57A 91,5C           DINC @ARG              Next in match
[1257] A57C 92,64           DEC  @ARG8             Reached end of match?
[1258] A57E 45,71           BR   POS04             Not yet, so loop
[1259] A580 90,0D    POS06  INC  @BYTES+1          Matched! Correct for 1 index
[1260] A582 BD,4A,0C POS08  DST  @BYTES,@FAC       Character position of match
[1261] A585 44,4C           BR   LEN02             Convert to floating point
[1262]               * NOTE: Utilizes the LEN code to do the conversion and
[1263]               *       finish up.
[1264] A587 90,0D    POS10  INC  @BYTES+1          Step index of match character
[1265] A589 92,51           DEC  @FAC7             Move 1 position down 1st
[1266] A58B 91,4E           DINC @FAC4              Argument
[1267] A58D 45,63           BR   POS02             Try to match again
[1268]               * JUMP ALWAYS
[1269] A58F 86,0D    POS12  CLR  @BYTES+1          NO MATCH POSSIBLE
[1270] A591 45,82           BR   POS08
[1271]               ***********************************************************
[1272]               * RPT$(A$,X) - Creates a string consisting of X copies of

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0022 
RXB 2022
[1273]               *              A$. If X is negative or non-numeric, an
[1274]               *              exception occurs. If A$ is not a string, an
[1275]               *              exception occurs.
[1276]               ***********************************************************
[1277] A593 06,AC,3F RPTZ01 CALL LPARR             Insure "(", parse, insure ","
[1278] A596 06,A3,81        CALL PUSSTR            Insure a string and push it
[1279] A599 0F,74           XML  PARSE             Parse second argument
[1280] A59B B6              BYTE RPARZ
[1281] A59C 0F,7E           XML  SPEED             Must have
[1282] A59E 00              BYTE SYNCHK       *     ended on a
[1283] A59F B6              BYTE RPARZ        *      right parenthesis
[1284] A5A0 06,A8,DD        CALL INTARG            Check numeric and convert
[1285] A5A3 A9,4A,E0        DMUL V@6(@VSPTR),@FAC  Compute result length
       A5A6 06,6E
[1286] A5A8 8F,4B           DCZ  @FAC1
[1287] A5AA 65,B4           BS   GA649
[1288] A5AC 06,6A,82 WRNST2 CALL WARNZZ            Give truncation message
[1289] A5AF 13              BYTE 19                * STRING TRUNCATED message
[1290] A5B0 BF,4C,00        DST  255,@FAC2         Make it a maximum string
       A5B3 FF
[1291] A5B4 BD,0C,4C GA649  DST  @FAC2,@BYTES      Copy requested string length
[1292] A5B7 0F,71           XML  GETSTR            Get the new string
[1293] A5B9 0F,78           XML  VPOP              Retrieve the original string
[1294]               * At this point BYTES should still contain the length
[1295] A5BB BD,5C,50        DST  @FAC6,@ARG        Copy original length in ARG
[1296] A5BE 8F,0C           DCZ  @BYTES            Zero copies requested
[1297] A5C0 45,C4           BR   GA659
[1298] A5C2 87,5C           DCLR @ARG              So we copy zero!!!!!!!
[1299] A5C4 C1,0C,5C GA659  DEX  @ARG,@BYTES       Original length to BYTE
[1300] A5C7 BD,66,4E        DST  @FAC4,@TEMP5      And also original start addr
[1301] A5CA 86,52           CLR  @FAC8             Clear flag for LITS08
[1302] A5CC 06,A3,57        CALL LITS08            Create FAC and copy on copy
[1303]               * ARG contains total length now.
[1304] A5CF BD,50,5C        DST  @ARG,@FAC6        Store new length
[1305] A5D2 A5,5C,0C RPTZ02 DSUB @BYTES,@ARG       Subtract one copy
[1306] A5D5 8F,5C           DCZ  @ARG              <<<<<THE WAY OUT
[1307] A5D7 65,EF           BS   XMLCON
[1308] A5D9 A1,1C,0C        DADD @BYTES,@SREF      Compute new start address
[1309] A5DC C5,0C,5C        DCH  @ARG,@BYTES
[1310] A5DF 45,E4           BR   GA679
[1311] A5E1 BD,0C,5C        DST  @ARG,@BYTES       Truncate string
[1312] A5E4 34,0C,B0 GA679  MOVE @BYTES,V*TEMP5,V*SREF
       A5E7 1C,B0,66
[1313] A5EA 45,D2           BR   RPTZ02
[1314]               ***********************************************************
[1315]               *                   TRACE STATEMENT
[1316]               ***********************************************************
[1317] A5EC B6,45,10 NTRACE OR   >10,@FLAG         Set the trace bit
[1318] A5EF 0F,75    XMLCON XML  CONT              Continue on
[1319]               ***********************************************************
[1320]               *                 UNTRACE STATEMENT
[1321]               ***********************************************************
[1322] A5F1 B2,45,EF NUNTRC AND  >EF,@FLAG         Reset the trace bit
[1323] A5F4 0F,75           XML  CONT              Continue on
[1324]               ***********************************************************
[1325]               *          BREAK AND UNBREAK STATEMENTS
[1326]               ***********************************************************
[1327] A5F6 BE,5C,FF NBREAK ST   >FF,@ARG          BREAK flag
[1328] A5F9 06,6A,78        CALL CHKEND            Check for end of statement
[1329] A5FC 46,0F           BR   LINEGP            If not goto LINEGP
[1330] A5FE 93,2C           DDEC @PGMPTR           Back up so CON will rescan en
[1331] A600 8E,44           CZ   @PRGFLG           Rative without line #
[1332] A602 41,1B           BR   EXEC6C
[1333] A604 06,6A,84 ERROLP CALL ERRZZ             Only legal in a program

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0023 
RXB 2022
[1334] A607 1B              BYTE 27
[1335] A608 86,5C    NUNBRK CLR  @ARG              UNBREAK flag for common
[1336] A60A 06,6A,78        CALL CHKEND            Check for end of statement
[1337] A60D 66,62           BS   UNBK01            If end then goto UNBK01
[1338] A60F 06,A8,3E LINEGP CALL LINE              Get line #
[1339] A612 BD,5E,32        DST  @ENLN,@ARG2
[1340] A615 A7,5E,00        DSUB >03,@ARG2         1st line #
       A618 03
[1341] A619 C9,5E,30 LNGP1  DCHE @STLN,@ARG2       If line not found
[1342] A61C 46,5C           BR   WRNLNF
[1343] A61E 06,80,2E        CALL GRSUB3            Read line # of data from ERAM
[1344] A621 5E              BYTE >5E           *   (use GREAD1) or VDP
[1345]               * @ARG2: Source addr in ERAM/VDP, reset possible breakpoint
[1346] A622 D5,58,4A        DCEQ @FAC,@EEE1        If line found
[1347] A625 66,2D           BS   LNGP2
[1348] A627 A7,5E,00        DSUB 4,@ARG2           Next line in VDP or ERAM
       A62A 04
[1349] A62B 46,19           BR   LNGP1
[1350]               * JUMP ALWAYS
[1351] A62D 8E,80,84 LNGP2  CZ   @RAMTOP           If ERAM exists
[1352] A630 66,45           BS   GA6DA
[1353] A632 B2,58,7F        AND  >7F,@EEE1         Assume UNBREAK flag
[1354] A635 8E,5C           CZ   @ARG              If BREAK flag
[1355] A637 66,3C           BS   GA6D1
[1356] A639 B6,58,80        OR   >80,@EEE1         Set the breakpoint
[1357] A63C 06,60,36 GA6D1  CALL GWSUB             Write a few bytes of data to
[1358]               *                              ERAM (use GWRITE)
[1359] A63F 5E,58,01        BYTE >5E,>58,>01     * ARG2,EEE1,1
[1360]               *                            @ARG2: Destination addr on ERA
[1361]               *                            @EEE1: Data
[1362]               *                            1    : Byte count
[1363] A642 05,A6,51        B    LNGP2B
[1364] A645 B2,B0,5E GA6DA  AND  >7F,V*ARG2        Assume UNBREAK flag first
       A648 7F
[1365] A649 8E,5C           CZ   @ARG              If BREAK flag
[1366] A64B 66,51           BS   LNGP2B
[1367] A64D B6,B0,5E        OR   >80,V*ARG2        Set the breakpoint
       A650 80
[1368] A651 06,6A,78 LNGP2B CALL CHKEND            Check for end of statement
[1369] A654 66,65           BS   LNGP4             If end then continue
[1370] A656 0F,7E           XML  SPEED             Must be
[1371] A658 00              BYTE SYNCHK         *     at a
[1372] A659 B3              BYTE COMMAZ         *       comma now
[1373] A65A 46,0F           BR   LINEGP
[1374]               * JUMP ALWAYS
[1375] A65C 06,6A,82 WRNLNF CALL WARNZZ            Note: warning not error
[1376] A65F 26              BYTE 38             *  'LINE NOT FOUND'
[1377] A660 46,51           BR   LNGP2B            And contiue on
[1378]               * JUMP ALWAYS
[1379] A662 06,A6,67 UNBK01 CALL UBSUB             Clear all bkpt in line # tabl
[1380] A665 0F,75    LNGP4  XML  CONT              Contiue
[1381]               *     CLEAR ALL BREAKPOINTS
[1382] A667 BD,52,30 UBSUB  DST  @STLN,@FAC8       END OF LINE # BUFFER
[1383] A66A 06,A6,77 GA6FF  CALL UBSUB1            Reset one line # at a time
[1384] A66D A3,52,00        DADD 4,@FAC8           Got to the next line
       A670 04
[1385] A671 C5,52,32        DCH  @ENLN,@FAC8       End of table
[1386] A674 46,6A           BR   GA6FF
[1387] A676 00              RTN
[1388] A677 06,80,2E UBSUB1 CALL GRSUB3            Read the line # from ERAM/VDP
[1389]               *                             Reset possible bkpt too
[1390] A67A 52              BYTE >52            *  @FAC8: Source addr on ERAM/VD
[1391] A67B 06,60,36        CALL GWSUB             Write a few bytes of data to
[1392]               *                              ERAM(use GWRITE) or VDP

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0024 
RXB 2022
[1393] A67E 52,58,01        BYTE >52,>58,>01    *  FAC8,EEE1,1
[1394]               *                          @FAC8: Destination adr in ERAM/V
[1395]               *                          @EEE1: Data
[1396]               *                          1    : Byte count
[1397] A681 00              RTN
[1398]               ***********************************************************
[1399]               *                USER DEFINED FUNCTIONS
[1400]               * Subroutine to store away the information of the tokens in
[1401]               * a function reference, go into the 'DEF' statement,
[1402]               * calculate the value of the expression and then resume
[1403]               * execution of the user's program after the reference.
[1404]               * An entry in the FAC and on the stack for a function
[1405]               * reference looks like:
[1406]               * +--------+-----+---------------------+--------+---------+
[1407]               * | PGMPTR | >68 | string/numeric flag | SYMTAB | FREPTR  |
[1408]               * +--------+-----+---------------------+--------+---------+
[1409]               *  FAC      FAC2  FAC3                  FAC4     FAC6
[1410]               *
[1411]               * The 'PGMPTR' is where execution resumes after evaluating
[1412]               * the function. String (80)/numeric(00) flag is function
[1413]               * type. SYMTAB is the old symbol table pointer and FREPTR
[1414]               * is the old free space pointer. These are restored after
[1415]               * the function is evaluated.
[1416]               ***********************************************************
[1417] A682 8E,44    UDF    CZ   @PRGFLG           If imperative
[1418] A684 46,8B           BR   GA720
[1419] A686 8E,80,85        CZ   @RAMTOP+1         And ERAM, error
[1420] A689 46,04           BR   ERROLP
[1421] A68B 86,51    GA720  CLR  @FAC7             Assume no args
[1422] A68D 87,22           DCLR @ERRCOD           Clear the error code for cont
[1423] A68F 86,5E           CLR  @ARG2             Safety for VPUSH
[1424] A691 86,4C           CLR  @FAC2             Sagety for VPUSH
[1425] A693 D6,42,B7        CEQ  LPARZ,@CHAT
[1426] A696 46,A6           BR   GA73B
[1427] A698 0F,77           XML  VPUSH             Save ptr to function definiti
[1428] A69A 0F,74           XML  PARSE             PARSE to get arg value
[1429] A69C FF              BYTE >FF
[1430] A69D 35,00,08        MOVE 8,@FAC,@ARG       Save PARSE result
       A6A0 5C,4A
[1431] A6A2 0F,78           XML  VPOP              Get S.T. ptr to function defi
[1432] A6A4 90,51           INC  @FAC7             Indicate theat we have an arg
[1433] A6A6 BC,66,51 GA73B  ST   @FAC7,@TEMP5      Move the parmeter count
[1434] A6A9 BD,64,4A        DST  @FAC,@TEMP4       S.T. ptr to definition
[1435] A6AC 0F,77           XML  VPUSH             Allow room for UDF result
[1436] A6AE 35,00,08        MOVE 8,@ARG,@FAC       Retrieve parse result
       A6B1 4A,5C
[1437] A6B3 0F,77           XML  VPUSH             Save parse result
[1438] A6B5 BC,4C,B0        ST   V*TEMP4,@FAC2     Get S.T. declarations
       A6B8 64
[1439] A6B9 BC,4D,4C        ST   @FAC2,@FAC3       Do this to save string bit
[1440]               * NOTE: THIS IS TO ALLOW THE CHECKING AFTER THE FUNCTION HA
[1441]               *       BEEN EVALUATED TO MAKE SURE THE FUNCTION
[1442]               *       TYPE (STRING/NUMERIC) MATCHES THE RESULT IT PRODUCE
[1443] A6BC B2,4C,07        AND  >07,@FAC2         Mask all but # of parameters
[1444] A6BF D4,4C,66        CEQ  @TEMP5,@FAC2
[1445] A6C2 4D,91           BR   ERRIAL
[1446]               * Incorrect argument list error above.
[1447] A6C4 BD,4A,2C        DST  @PGMPTR,@FAC      Will resume execution here
[1448] A6C7 BE,4C,70        ST   >70,@FAC2         Entering parameter into symbo
[1449]               *                    table while in UDF statement executing
[1450] A6CA B2,4D,80        AND  >80,@FAC3         Mask all but string bit
[1451] A6CD A7,6E,00        DSUB 16,@VSPTR         Get below parse result
       A6D0 10
[1452]                

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0025 
RXB 2022
[1453] A6D1 BD,4E,3E        DST  @SYMTAB,@FAC4     Save current symbol table ptr
[1454] A6D4 BD,50,40        DST  @FREPTR,@FAC6     Save current free space ptr
[1455] A6D7 0F,77           XML  VPUSH             Save the return info
[1456] A6D9 A3,6E,00        DADD 8,@VSPTR          Get back to parse result
       A6DC 08
[1457]               *********** SHIFT EXECUTION TO FUNCTION DEFINITION ********
[1458] A6DD BD,2C,E0        DST  V@6(@TEMP4),@PGMPTR    Set text ptr to definiti
       A6E0 06,64
[1459] A6E2 0F,79           XML  PGMCHR            Get 1st character in the defi
[1460] A6E4 C6,73,A4        CH   >A4,@SUBSTK       Stack overflow
[1461] A6E7 6D,69           BS   ERRSO
[1462] A6E9 35,00,18        MOVE 24,@PAD,V@VROAZ   Roll out temporaries
       A6EC A3,C0,00
[1463] A6EF B6,45,08        OR   >08,@FLAG         Set function flag for ENTER
[1464] A6F2 BE,16,80        ST   >80,@XFLAG        Make calls look like ENTERX
[1465] A6F5 D6,42,BE        CEQ  EQUALZ,@CHAT
[1466] A6F8 47,07           BR   GA79C
[1467]               * NOTE: This is to keep the global/local variables correct
[1468]               *       the event that a function uses another function in
[1469]               *       its evaluation.
[1470] A6FA 86,59           CLR  @FAC15            Create a dummy entry in table
[1471] A6FC 06,6A,80        CALL ENT09              for no-paremter function
[1472] A6FF 97,2C           DDECT @PGMPTR          Back up to equal sign
[1473] A701 86,E0,02        CLR  V@2(@VSPTR)       This is to keep ASSGNV(called
       A704 6E
[1474]               *                              below) not to screw up in
[1475]               *                              case FAC2 happens to have a
[1476]               *                              value (greater) >65
[1477] A705 47,0A           BR   GA79F
[1478] A707 06,6A,7E GA79C  CALL ENTER             Enter the parameter
[1479] A70A 0F,79    GA79F  XML  PGMCHR            Get the '=' (Checked in PSCAN
[1480] A70C B2,45,F7        AND  >F7,@FLAG         Reset to normal ENTERs
[1481] A70F 35,00,18        MOVE 24,V@VROAZ,@>8300
       A712 00,A3,C0
[1482] A715 BE,EF,FF        ST   >68,V@-6(@VSPTR)  Correct stack entry ID
       A718 FA,6E,68
[1483] A71B BD,E0,02        DST  V@SYMBOL,V@2(@SYMTAB)  Fudge link to
       A71E 3E,A3,76
[1484]               *                                   get global values
[1485] A721 BD,4A,3E        DST  @SYMTAB,@FAC      Set up for SMB
[1486] A724 0F,7B           XML  SMB               Get value space
[1487] A726 35,00,08        MOVE 8,@FAC,@FAC8      Destination
       A729 52,4A
[1488] A72B 0F,78           XML  VPOP              Get arg back
[1489] A72D 35,00,08        MOVE 8,@FAC,@ARG       Argument value
       A730 5C,4A
[1490] A732 35,00,08        MOVE 8,@FAC8,@FAC      Destination
       A735 4A,52
[1491] A737 0F,77           XML  VPUSH             Push to destination
[1492] A739 35,00,08        MOVE 8,@ARG,@FAC       Argument value
       A73C 4A,5C
[1493] A73E D6,4C,65        CEQ  >65,@FAC2         If a string
[1494] A741 47,4D           BR   GA7E2
[1495] A743 D7,4A,00        DCEQ >001C,@FAC        If not temp
       A746 1C
[1496] A747 67,4D           BS   GA7E2
[1497] A749 BD,4E,B0        DST  V*FAC,@FAC4       Get new location of string
       A74C 4A
[1498]               *                             Parameter was allocated in S.
[1499] A74D 0F,79    GA7E2  XML  PGMCHR            Skip the '='
[1500] A74F 0F,7C           XML  ASSGNV            Assign the value to the param
[1501] A751 0F,74           XML  PARSE             PARSE to end of function defi
[1502] A753 83              BYTE TREMZ
[1503]               **** CHECK FOR TYPE MATCH (STRING/STRING OR NUM/NUM)*******

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0026 
RXB 2022
[1504]               **** BETWEEN THE RESULT AND THE FUNCTION TYPE *************
[1505] A754 D6,4C,65        CEQ  >65,@FAC2         If result string
[1506] A757 47,61           BR   GA7F6
[1507] A759 8E,E0,03        CZ   V@3(@VSPTR)       If functional
       A75C 6E
[1508] A75D 6D,5D           BS   ERRSNM
[1509] A75F 47,67           BR   GA7FC              not a string
[1510] A761 8E,E0,03 GA7F6  CZ   V@3(@VSPTR)       If functional
       A764 6E
[1511] A765 4D,5D           BR   ERRSNM
[1512]               ***** NOW RESTORE SYMBOL TABLE AND RESUME *****************
[1513]               ***** EXECUTION AT THE ORIGINAL LINE **********************
[1514] A767 06,A7,75 GA7FC  CALL DELINK            Delink the parameter entry
[1515] A76A BD,2C,E0        DST  V@8(@VSPTR),@PGMPTR Manual pop to get ptr back
       A76D 08,6E
[1516] A76F 93,2C           DDEC @PGMPTR           Back up text pointer
[1517] A771 0F,79           XML  PGMCHR            Get next token
[1518] A773 0F,75           XML  CONT
[1519] A775 BD,66,3E DELINK DST  @SYMTAB,@TEMP5    Save addr of S.T. entry just
[1520]               *                             in case entry is a string
[1521]               *                             (must free the string)
[1522] A778 35,00,04        MOVE 4,V@4(@VSPTR),@SYMTAB  Restore old symbol table
       A77B 3E,E0,04
       A77E 6E
[1523]               *                             pointer and free space pointe
[1524]               *                             This handles the freeing of t
[1525]               *                             string value which was assign
[1526]               *                             to the parameter.
[1527] A77F D2,B0,66        CGE  0,V*TEMP5         If string parmeter
       A782 00
[1528] A783 67,B7           BS   GA84C
[1529] A785 BD,66,E0        DST  V@6(@TEMP5),@TEMP5 Where the string is
       A788 06,66
[1530] A78A 8F,66           DCZ  @TEMP5            If non-null string
[1531] A78C 67,9E           BS   GA833
[1532] A78E BD,56,EF        DST  V@-3(@TEMP5),@TEMP2 Get backpointer
       A791 FF,FD,66
[1533] A794 C9,56,3E        DCHE @SYMTAB,@TEMP2    If not used
[1534] A797 67,9E           BS   GA833
[1535] A799 87,EF,FF        DCLR V@-3(@TEMP5)      Free up the string
       A79C FD,66
[1536]               * This handles the special case of F$(X$)=X$
[1537]               * The result, which was permanent, must be made a temp.
[1538] A79E D6,4C,65 GA833  CEQ  >65,@FAC2         If string result
[1539] A7A1 47,B5           BR   GA84A
[1540] A7A3 C9,4A,3E        DCHE @SYMTAB,@FAC      If came from argument
[1541] A7A6 67,B5           BS   GA84A
[1542] A7A8 8F,4E           DCZ  @FAC4             If non-null
[1543] A7AA 67,B1           BS   GA846
[1544] A7AC 87,EF,FF        DCLR V@-3(@FAC4)       Clear the backpointer
       A7AF FD,4E
[1545] A7B1 BF,4A,00 GA846  DST  >001C,@FAC        Make it a temp
       A7B4 1C
[1546] A7B5 47,C1    GA84A  BR   GA856             If numeric parameter
[1547] A7B7 8E,80,84 GA84C  CZ   @RAMTOP           If ERAM exist
[1548] A7BA 67,C1           BS   GA856
[1549] A7BC A3,80,86        DADD 8,@RAMFRE         Remove 8 bytes of value
       A7BF 00,08
[1550] A7C1 A7,6E,00 GA856  DSUB 8,@VSPTR          Trash the stack entry
       A7C4 08
[1551] A7C5 00              RTN                    And retrun
[1552] A7C6 0F,74    ATTNUT XML  PARSE
[1553] A7C8 B6              BYTE RPARZ
[1554] A7C9 06,A3,3E        CALL CKSTNM            CHECK FOR NUMERIC OR STRING

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0027 
RXB 2022
[1555] A7CC 0F,7E           XML  SPEED             Insure argument is in
[1556] A7CE 02              BYTE RANGE          *   range of 0-30
[1557] A7CF 00              BYTE 0
[1558] A7D0 00,1E           DATA 30
[1559] A7D2 E6,4B,01        SRL  1,@FAC1           0,1 : 0000        ATTENUATION
[1560]               *                             2,3 : 0001
[1561]               *                             4,5 : 0010
[1562]               *                             6,7 : 0011        ETC...
[1563] A7D5 B6,4B,F0        OR   >F0,@FAC1         REGISTER BITS
[1564] A7D8 00              RTN
[1565]               ***********************************************************
[1566]               * SUBROUTINE TO SET POINTER TO EACH DATUM
[1567]               ***********************************************************
[1568] A7D9 93,36    DATAST DDEC @LNBUF            Point to 1st byte of line ptr
[1569] A7DB 06,80,2C        CALL GRSUB2            Read 2 bytes from VDP or ERAM
[1570] A7DE 36              BYTE LNBUF           *  (use GREAD1), @LNBUF: Source
[1571]               *                           *  address in ERAM or VDP
[1572] A7DF BD,34,58        DST  @EEE1,@DATA       Put it in @DATA
[1573] A7E2 06,80,20        CALL SRDATA            Look for 'DATA' on the line
[1574] A7E5 47,F4           BR   DATST1            OK, FOUND ANOTHER 'DATA' STMT
[1575] A7E7 97,36           DDECT @LNBUF           NO
[1576] A7E9 D5,36,30        DCEQ  @STLN,@LNBUF
[1577] A7EC 67,F2           BS   GA887
[1578] A7EE 93,36           DDEC @LNBUF            Point to 1st token address
[1579] A7F0 47,D9           BR   DATAST
[1580] A7F2 86,34    GA887  CLR  @DATA             Indicate no data
[1581] A7F4 00       DATST1 RTN
[1582]               ***********************************************************
[1583]               * Subroutine to get line number and goto routine to display
[1584]               * it on the screen.
[1585]               ***********************************************************
[1586] A7F5 8E,80,89 ASC    CZ   @RAMFLG
[1587] A7F8 48,02           BR   GA897
[1588] A7FA BD,5E,EF        DST  V@-2(@EXTRAM),@ARG2   Get line # in
       A7FD FF,FE,2E
[1589] A800 48,10           BR   GA8A5
[1590] A802 BF,56,00 GA897  DST  2,@FFF1           @FFF1 : Byte count
       A805 02
[1591] A806 BD,54,2E        DST  @EXTRAM,@DDD1     @DDD1 : Source addr in ERAM
[1592] A809 97,54           DDECT @DDD1
[1593] A80B 0F,8C           XML  GREAD1            Read data from ERAM
[1594] A80D BD,5E,58        DST  @EEE1,@ARG2       @EEE1 : Destination addr on C
[1595] A810 B2,5E,7F GA8A5  AND  >7F,@ARG2         Reset the breakpoint if any
[1596] A813 05,6A,7C        B    DISO
[1597]               ***********************************************************
[1598]               * Code to decode error returned from ALC
[1599]               ***********************************************************
[1600] A816 8A,22    ERORZ  CASE @ERRCOD           DECODE ERROR FROM INTERPRETER
[1601] A818 4D,59           BR   ERRSYN            0 SYNTAX ERROR
[1602] A81A 4D,65           BR   ERRMEM            1 MEMORY FULL
[1603] A81C 4D,8D           BR   ERRBV             2 BAD VALUE
[1604] A81E 4D,85           BR   ERRLNF            3 LINE NOT FOUND
[1605] A820 4D,59           BR   ERRSYN            4 SYNTAX
[1606] A822 4D,81           BR   ERRBS             5 BAD SUBSCRIPT
[1607] A824 4D,5D           BR   ERRSNM            6 STRING-NUMBER MISMATCH
[1608] A826 4D,69           BR   ERRSO             7 STACK OVERFLOW
[1609] A828 4D,89           BR   ERRBA             8 BAD ARGUMENT
[1610] A82A 4D,7D           BR   ERRRWG            9 RETURN WITHOUT GOSUB
[1611] A82C 4D,91           BR   ERRIAL            A INCORRECT ARGUMENT LIST
[1612] A82E 4D,71           BR   ERRFNN            B FOR/NEXT NESTING
[1613] A830 4D,6D           BR   ERRNWF            C NEXT WITHOUT FOR
[1614] A832 4D,61           BR   ERRMUV            D IMPROPERLY USED NAME
[1615] A834 4D,91           BR   ERRIAL            E INCORRECT ARGUMENT LIST
[1616] A836 4D,79           BR   ERRRSC            F RECURSIVE SUBPROGRAM CALL

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0028 
RXB 2022
[1617] A838 4D,95           BR   ERRSNF           10 SUBPROGRAM NOT FOUND
[1618] A83A 46,04           BR   ERROLP           11 ONLY LEGAL IN A PROGRAM
[1619] A83C 4D,75           BR   ERRSNS           12 MUST BE IN SUBPROGRAM
[1620]               ***********************************************************
[1621]               * SUBROUTINE TO GET LINE # FOLLOWING 'BREAK', 'UNBREAK',
[1622]               * 'RESTORE'
[1623]               ***********************************************************
[1624] A83E D6,42,C9 LINE   CEQ  LNZ,@CHAT         Should be line # reference
[1625] A841 4D,59           BR   ERRSYN
[1626] A843 0F,79           XML  PGMCHR            Get high order line #
[1627] A845 BC,4A,42        ST   @CHAT,@FAC        Build result in FAC, FAC1
[1628] A848 0F,79           XML  PGMCHR
[1629] A84A BC,4B,42        ST   @CHAT,@FAC1       Low order line #
[1630] A84D 0F,79           XML  PGMCHR            Get token following line #
[1631] A84F 00              RTN
[1632] A850 86,54    CONV1  CLR  @FAC10
[1633] A852 0F,10           XML  CSNUM             Convert String to Number
[1634]               ***********************************************************
[1635] A854 BC,A3,BA        ST   @FAC10,V@CSNTP1
       A857 54
[1636] A858 BD,A3,90        DST  @FAC12,V@CSNTMP Save those in temporary, becaus
       A85B 56
[1637]               *                            in ERROV : WARNING routine hav
[1638]               *                            FAC12 and FAC10 values changed
[1639]               ***********************************************************
[1640] A85C 8E,54    WRNNO  CZ   @FAC10            Numeric overflow
[1641] A85E 68,64           BS   GA8F9
[1642] A860 06,6A,82        CALL WARNZZ
[1643] A863 02              BYTE 2
[1644] A864 00       GA8F9  RTN
[1645]               ***********************************************************
[1646]               *               SUBROUTINE FOR 'COLOR'                    *
[1647]               ***********************************************************
[1648]               * CALL COLOR(ALL,FORGROUND,BACKGROUND,...)                *
[1649]               * CALL COLOR(SET#,FORGROUND,BACKGROUND,... )              *
[1650]               * CALL COLOR(SPRITE#,FORGROUND,...)                       *
[1651]               ***********************************************************
[1652] A865 0F,7E    COLOR  XML  SPEED             Must be
[1653] A867 00              BYTE SYNCHK        *     at a
[1654] A868 B7              BYTE LPARZ         *       left parenthesis
[1655]               * RXB PATCH CODE
[1656] A869 87,00    COL08  DCLR @PAD              Clear ALL pointer
[1657] A86B D6,42,EC        CEQ  ALLZ,@CHAT        ALL?
[1658] A86E 48,7C           BR   COL09             No.
[1659] A870 BE,00,EC        ST   ALLZ,@PAD         Yes, store it in pointer
[1660] A873 87,4A           DCLR @FAC              Set 0
[1661] A875 0F,79           XML  PGMCHR            Skip ALL token.
[1662] A877 06,B1,4D        CALL COMMA2            Skip comma.
[1663] A87A 48,9A           BR   COL21             Start ALL RXB routine
[1664] A87C D6,42,FD COL09  CEQ  NUMBEZ,@CHAT      If sprite number specified
[1665] A87F 48,91           BR   COL20
[1666] A881 06,AD,99        CALL CHAR1             Check sprite number (SPNUM3)
[1667] A884 06,A8,D1 COL10  CALL SPCOL             Put the color in SAL
[1668] A887 D6,42,B3        CEQ  COMMAZ,@CHAT      More color changes
[1669] A88A 4A,BA           BR   LNKRTN
[1670] A88C 06,AD,9B        CALL CHAR2             Skip and get sprite number (S
[1671] A88F 48,84           BR   COL10
[1672]               * This part for regular color change routine
[1673] A891 0F,7E    COL20  XML  SPEED             Parse the character
[1674] A893 01              BYTE PARCOM         *   set and insure a comma
[1675] A894 0F,7E           XML  SPEED             Insure in range of
[1676] A896 02              BYTE RANGE          *   0<= x <= 14
[1677]               * RXB PATCH CODE
[1678]               *      BYTE 0,0,14

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0029 
RXB 2022
[1679] A897 00,00,10        BYTE 0,0,16
[1680] A89A A3,4A,08 COL21  DADD >080F,@FAC        Color table addr(>0810 - >081
       A89D 0F
[1681] A89E 0F,77           XML  VPUSH             Push table set address
[1682] A8A0 0F,7E           XML  SPEED             Parse the foreground color
[1683] A8A2 01              BYTE PARCOM         *   and insure a comma
[1684] A8A3 06,AC,5C        CALL RAN16             Error if >16 or <1
[1685] A8A6 BC,0E,4B        ST   @FAC1,@VAR4       Save it
[1686] A8A9 E2,0E,04        SLL  4,@VAR4           Foreground color in 4 MSBits
[1687] A8AC 0F,74           XML  PARSE             Get background color
[1688] A8AE B6              BYTE RPARZ
[1689] A8AF 06,AC,5C        CALL RAN16             Error if >16 or <1
[1690] A8B2 B4,0E,4B        OR   @FAC1,@VAR4       Background color in 4 LSBits
[1691] A8B5 0F,78           XML  VPOP              Get color table address
[1692] A8B7 BC,B0,4A        ST   @VAR4,V*FAC       Load the colors into the tabl
       A8BA 0E
[1693]               * RXB PATCH CODE
[1694] A8BB D6,00,EC        CEQ  ALLZ,@PAD         ALL in pointer.
[1695] A8BE 48,C8           BR   COL22             No.
[1696] A8C0 35,00,0E        MOVE 14,V*FAC,V@1(@FAC) Fill color table with values
       A8C3 E0,01,4A
       A8C6 B0,4A
[1697] A8C8 D6,42,B3 COL22  CEQ  COMMAZ,@CHAT      End of call. Go back.
[1698] A8CB 4A,BA           BR   LNKRTN
[1699] A8CD 0F,79           XML  PGMCHR            Skip ","
[1700] A8CF 48,69           BR   COL08             Take care of the next set
[1701]               *      CALL SPCOL -- Changes color of sprite.
[1702]               *                    Called also from SPRITE.
[1703] A8D1 0F,74    SPCOL  XML  PARSE
[1704] A8D3 B6              BYTE RPARZ          *  Get the color number
[1705] A8D4 06,AC,5C        CALL RAN16             Check range 1 - 16
[1706] A8D7 BC,E0,03        ST   @FAC1,V@3(@SPSAL) Store in SAL
       A8DA 08,4B
[1707] A8DC 00              RTN
[1708]               ***********************************************************
[1709]               * INTARG - Insures that the value in FAC is a numeric,
[1710]               *          converts it to integer, issues error message if
[1711]               *          necessary or returns.
[1712]               ***********************************************************
[1713] A8DD C6,4C,63 INTARG CH   >63,@FAC2         If string - error
[1714] A8E0 6D,5D           BS   ERRSNM
[1715] A8E2 86,54           CLR  @FAC10            ASSUME NO ERROR OR WARNING
[1716] A8E4 87,6C           DCLR @FPERAD
[1717] A8E6 0F,12           XML  CFI
[1718] A8E8 8E,54           CZ   @FAC10            If error
[1719] A8EA 4D,8D           BR   ERRBV
[1720] A8EC D2,4A,00        CGE  0,@FAC            Can't be < zero
[1721] A8EF 4D,8D           BR   ERRBV
[1722] A8F1 00              RTN
[1723]               *******************************
[1724]               * FAC IS SET UP WITH F.P. 1
[1725] A8F2 BC,4B,00 JOYXY  ST   @PAD,@FAC1
[1726] A8F5 8E,00           CZ   @PAD              If <>0
[1727] A8F7 48,FD           BR   GA995
[1728] A8F9 86,4A           CLR  @FAC              (>0000000000000000)
[1729] A8FB 49,05           BR   GA99D
[1730] A8FD D2,00,00 GA995  CGE  0,@PAD
[1731] A900 69,05           BS   GA99D
[1732] A902 BE,4A,BF        ST   >BF,@FAC
[1733] A905 0F,7C    GA99D  XML  ASSGNV            Assign the value
[1734] A907 00              RTN
[1735]               *******************************
[1736] A908 0F,7A    NUMVAR XML  SYM               Get the symbol name
[1737] A90A DA,B0,4A        CLOG >C0,V*FAC         Can't be string or function

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0030 
RXB 2022
       A90D C0
[1738] A90E 4D,61           BR   ERRMUV            It is, IMPROPERLY USED NAME E
[1739] A910 0F,7B           XML  SMB               Get value pointer
[1740] A912 0F,77           XML  VPUSH             Put on stack for ASSGNV
[1741] A914 00              RTN                    And return
[1742]               *******************************
[1743] A915 80,00,A0 ATTREG DATA >8000,>A000,>C000,
       A918 00,C0,00
[1744] A91B 9F,BF,DF        BYTE >9F,>BF,>DF,>FF,>00,>06
       A91E FF,00,06
[1745]               *******************************
[1746] A921 D6,42,B7 COMB   CEQ  LPARZ,@CHAT       If not '(' - error
[1747] A924 4D,59           BR   ERRSYN
[1748] A926 00              RTN
[1749]               *******************************
[1750] A927 35,00,08 SQUISH MOVE 8,V*FAC8,@FAC     Sneak it out
       A92A 4A,B0,52
[1751] A92D BD,58,6E        DST  @VSPTR,@FAC14     Now move stack to squish it
[1752] A930 A5,58,52        DSUB @FAC8,@FAC14        out - # of bytes to move
[1753] A933 69,3E           BS   SQU05             If none to move
[1754] A935 34,58,EF        MOVE @FAC14,V@8(@FAC8),V@-16(@FAC8)
       A938 FF,F0,52
       A93B E0,08,52
[1755] A93E A7,6E,00 SQU05  DSUB 8,@VSPTR
       A941 08
[1756] A942 00              RTN
[1757]               ***********************************************************
[1758]              
[1759]              
[1760]                      AORG >09AA
[1761]               ***********************************************************
[1762]               * INIALIZATION DATA FOR SOUND
[1763] A9AA 42,0B,12 FLTS   BYTE >42,>0B,>12,>22,>00,>00,>00,>00
       A9AD 22,00,00
       A9B0 00,00
[1764] A9B2 01,FF,01 SNDREG BYTE >01,>FF,>01,>04,>9F,>BF,>DF,>FF,>00
       A9B5 04,9F,BF
       A9B8 DF,FF,00
[1765]               ***********************************************************
[1766]               *                SUBPROGRAM FOR 'SOUND'                   *
[1767]               * CALL SOUND(duration,frequency,volume1,...)              *
[1768]               * Builds 2 blocks in VDP RAM                              *
[1769]               * 1st BLOCK : >01,<ATTENUATION FOR NOISE>,<INTERRUPT COUNT>
[1770]               * 2nd BLOCK : >04,>9F,>BF,>DF,>FF,>00                     *
[1771]               ***********************************************************
[1772] A9BB D7,80,CC XSOUND DCEQ VRMSND,@>83CC     Insure previous sound started
       A9BE 03,79
[1773] A9C0 69,BB           BS   XSOUND
[1774] A9C2 31,00,09        MOVE 9,G@SNDREG,V@VRMSND
       A9C5 A3,79,A9
       A9C8 B2
[1775] A9C9 06,AC,3F        CALL LPARR             Duration in milliseconds
[1776] A9CC D2,4A,00        CGE  0,@FAC            Don't wait for completion
[1777] A9CF 69,D6           BS   GAA39
[1778] A9D1 83,4A           DNEG @FAC                of previous sound
[1779] A9D3 87,80,CE        DCLR @PRTNFN           Make GPL interpeters stop pre
[1780] A9D6 0F,7E    GAA39  XML  SPEED             Insure duration
[1781] A9D8 02              BYTE RANGE           *  is in range
[1782] A9D9 01              BYTE 1               *   of 1 - 4250
[1783] A9DA 10,9A           DATA 4250
[1784]               * Convert duration into 1/60s of a second
[1785] A9DC AB,4A,00        DMUL 6,@FAC            Duration * 6
       A9DF 06
[1786] A9E0 AF,4A,00        DDIV 100,@FAC          (duration * 6) / 100

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0031 
RXB 2022
       A9E3 64
[1787] A9E4 8E,4B           CZ   @FAC1             If duration =0
[1788] A9E6 49,EA           BR   GAA4D
[1789] A9E8 90,4B           INC  @FAC1             Set it to 1/60th of a second
[1790] A9EA BC,A3,7B GAA4D  ST   @FAC1,V@VRMSND+2    3rd byte of the 1st block
       A9ED 4B
[1791]               *                          | INTERUPT COUNT
[1792]               ***********************************************************
[1793]               *      SOUND TABLE OF 10 BYTES IN CPU RAM (>00 - >09)
[1794]               * >00 - >05 : FREQUENCY CONTROL
[1795]               * >06 - >08 : ATTENUATION CONTROL
[1796]               * >09       : NOISE CONTROL(non-zero = noise encountered)
[1797]               * >0A       : POINTER FOR CURRENT FREQENCY CONTROL
[1798]               * >0B       : POINTER FOR CURRENT ATTENUATION CONTROL
[1799]               *                    >00 , >01 FOR REG 0;
[1800]               *                    >02 , >03 FOR REG 1;
[1801]               *                    >04 , >05 FOR REG 2;
[1802]               * REG0 : >8000, REG1 : >A000, REG3 : >C000
[1803]               * INITIALIZE ATTENUATION CONTROL
[1804]               * REG0 : >9F, REG1 : >BF, REG2 : >DF
[1805]               ***********************************************************
[1806] A9EE 31,00,0C        MOVE 12,G@ATTREG,@PAD
       A9F1 00,A9,15
[1807] A9F4 0F,7E    SOUND1 XML  SPEED             Parse the frequency value
[1808] A9F6 01              BYTE PARCOM         *   and insure a comma
[1809] A9F7 06,A3,3E        CALL CKSTNM            Must be a numeric
[1810] A9FA D2,4A,00        CGE  0,@FAC            Noise if negative
[1811] A9FD 4A,3C           BR   SOUND2
[1812] A9FF 31,00,08        MOVE 8,G@FLTS,@ARG     Constant 111834
       AA02 5C,A9,AA
[1813] AA05 0F,09           XML  FDIV              P = 111834/FREQUENCY
[1814] AA07 0F,7E           XML  SPEED             Insure in range
[1815] AA09 02              BYTE RANGE
[1816] AA0A 03              BYTE 3               * Range: 3 - 1023
[1817] AA0B 03,FF           DATA 1023
[1818]               * GET THE 4 L.S.Bits BITS AND 6 M.S.Bits OF 'P'
[1819] AA0D EB,4A,00        DSRC 4,@FAC
       AA10 04
[1820] AA11 E6,4A,04        SRL  4,@FAC
[1821] AA14 B5,90,0A        DOR  @FAC,*STADDR  1st byte of frequency control byt
       AA17 4A
[1822]               *                         BIT   7   6   5   4   3   2   1
[1823]               *                               1  <REG>    0  <L.S.B. 4 OF
[1824]               *                         2nd byte of frequency control byt
[1825]               *                               0   0   <M.S.B. 6 of 'P'
[1826] AA18 94,0A           INCT @STADDR           Advance ponter for next time
[1827] AA1A 06,A7,C6        CALL ATTNUT            Get attenuation
[1828]               *                        BIT    7   6   5   4   3   2   1
[1829]               *                               1   <REG>   1   0   0   0
[1830] AA1D B0,90,0B        AND  @FAC1,*PADB         1   <REG>   1   <ATTN/2 DB>
       AA20 4B
[1831] AA21 90,0B           INC  @PADB             Advance pointer for next time
[1832]               * CHECK FOR END OF SOUND CALL
[1833] AA23 D6,42,B6 SOUND3 CEQ  RPARZ,@CHAT       End of statement?
[1834] AA26 6A,5A           BS   SOUND5
[1835] AA28 0F,7E           XML  SPEED             If not right parenthesis
[1836] AA2A 00              BYTE SYNCHK        *    then must be at
[1837] AA2B B3              BYTE COMMAZ        *      a comma
[1838]              
[1839] AA2C D6,0A,06        CEQ  6,@STADDR         If not 3 regs yet
[1840] AA2F 49,F4           BR   SOUND1
[1841]               * 3 sound regs already - so must be noise control
[1842] AA31 0F,7E           XML  SPEED             Get frequency (should be nois
[1843] AA33 01              BYTE PARCOM        *     and insure a comma

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0032 
RXB 2022
[1844] AA34 06,A3,3E        CALL CKSTNM            Must be a numeric value
[1845] AA37 D2,4A,00        CGE  0,@FAC            If not noise-error
[1846] AA3A 6D,8D           BS   ERRBV
[1847]               * NOISE CONTROL
[1848] AA3C D6,09,FF SOUND2 CEQ  >FF,@>8309        * BAD ARGUMENT ERROR
[1849] AA3F 4D,89           BR   ERRBA
[1850] AA41 83,4A           DNEG @FAC              -(FREQUENCY)
[1851] AA43 0F,7E           XML  SPEED             Insure in range
[1852] AA45 02              BYTE RANGE         *    of 1 - 8
[1853] AA46 01              BYTE 1             *
[1854] AA47 00,08           DATA 8
[1855] AA49 92,4B           DEC  @FAC1             0 - 7 (2nd BIT: 'T')
[1856]               *                                           OTH, 1ST BITS:
[1857] AA4B BC,09,4B        ST   @FAC1,@>8309
[1858] AA4E B6,09,E0        OR   >E0,@>8309        Noise control byte:
[1859]               *                        BIT  7   6   5   4   3   2   1   0
[1860]               *                             1   1   1   0   0  <T>  < S >
[1861]               * PUT ATTENUATION IN THE 2ND BYTE OF 1ST BLOCK
[1862] AA51 06,A7,C6        CALL ATTNUT
[1863] AA54 BC,A3,7A        ST   @FAC1,V@VRMSND+1
       AA57 4B
[1864]               *                             1   1   1   1   < ATTN/2  DB>
[1865] AA58 4A,23           BR   SOUND3            Go check for end of list
[1866] AA5A 86,10    SOUND5 CLR  @VAR5             Pointer to sound table
[1867] AA5C 8E,80,CE SND05  CZ   @PRTNFN           Wait untild previous
[1868] AA5F 6A,6B           BS   SOUND6
[1869] AA61 03              SCAN                   Is finished and
[1870] AA62 4A,5C           BR   SND05              look for a break-key
[1871] AA64 D6,75,02        CEQ  BREAK,@RKEY       If not break-key
[1872] AA67 4A,5C           BR   SND05
[1873] AA69 41,1B           BR   EXEC6C            If BREAK-KEY encountered
[1874]               * LOAD SOUND TABLE
[1875] AA6B BC,81,00 SOUND6 ST   *VAR5,@>8400      SOUND ADDRESS PORT
       AA6E 90,10
[1876] AA70 90,10           INC  @VAR5             Next byte in table
[1877] AA72 D6,10,0A        CEQ  >0A,@VAR5         If not finished
[1878] AA75 4A,6B           BR   SOUND6
[1879] AA77 BF,4A,03        DST  VRMSND,@FAC       Where the 2 blocks are
       AA7A 79
[1880] AA7B F6,4A,01        I/O  1,@FAC            Start sound from VDP list
[1881] AA7E 4A,BA           BR   LNKRTN            Return to caller
[1882]               ***********************************************************
[1883]               *                SUBROUTINE FOR 'GCHAR'                   *
[1884]               ***********************************************************
[1885]               * CALL GCHAR(row,column,variable,...)                     *
[1886]               ***********************************************************
[1887] AA80 06,AA,FA GCHARZ CALL GPHV              Get X,Y values
[1888] AA83 06,A9,08 GCHAR2 CALL NUMVAR            Get pointer to return variabl
[1889] AA86 31,00,08        MOVE 8,G@FLT1,@FAC     Clear FAC
       AA89 4A,A3,44
[1890] AA8C BC,4B,7D        ST   @CB,@FAC1         Get the character
[1891] AA8F A6,4B,60        SUB  OFFSET,@FAC1      Remove screen offset
[1892] AA92 CA,4B,64        CHE  100,@FAC1
[1893] AA95 4A,9F           BR   GA919
[1894] AA97 C0,4C,4B        EX   @FAC1,@FAC2
[1895] AA9A AE,4B,64        DIV  100,@FAC1
[1896] AA9D 90,4A           INC  @FAC
[1897] AA9F 0F,7C    GA919  XML  ASSGNV            Assign the value to the symbo
[1898] AAA1 D6,42,B3        CEQ  COMMAZ,@CHAT      ,?
[1899] AAA4 6A,80           BS   GCHARZ
[1900] AAA6 57,EA           BR   XPTRTN
[1901]               ***********************************************************
[1902]               *                SUBPROGRAM FOR 'HCHAR'                   *
[1903]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0033 
RXB 2022
[1904]               * CALL HCHAR(row,column,character#,repetition[,...])      *
[1905]               ***********************************************************
[1906] AAA8 06,AA,DA HCHARZ CALL HVCHR             Get X, Y values character#
[1907] AAAB 8F,4A           DCZ  @FAC              If 0 characters
[1908] AAAD 6A,B5           BS   HCHAR2
[1909] AAAF 86,8F,DD        CLR  @>6004            Set ROM 3 page
       AAB2 04
[1910] AAB3 0F,74           XML  HCHAR             Disply them
[1911] AAB5 D6,42,B3 HCHAR2 CEQ  COMMAZ,@CHAT
[1912] AAB8 6A,A8           BS   HCHARZ
[1913] AABA 0F,7E    LNKRTN XML  SPEED             Must be at
[1914] AABC 00              BYTE SYNCHK        *     a right
[1915] AABD B6              BYTE RPARZ         *      parenthesis
[1916] AABE 06,6A,78 LNKRT2 CALL CHKEND            Check end of statement
[1917] AAC1 4D,59           BR   ERRSYN            If not end-of-stmt , error
[1918] AAC3 06,00,12        CALL RETURN            Return to caller
[1919]               ***********************************************************
[1920]               *                SUBPROGRAM FOR 'VCHAR'                   *
[1921]               ***********************************************************
[1922]               * CALL VCHAR(row,column,character#,repetition[,...])      *
[1923]               ***********************************************************
[1924] AAC6 06,AA,DA VCHARZ CALL HVCHR             Get X, Y values character#
[1925] AAC9 8F,4A           DCZ  @FAC              If 0 characters
[1926] AACB 6A,D3           BS   VCHAR2
[1927] AACD 86,8F,DD        CLR  @>6004            Set ROM 3 page
       AAD0 04
[1928] AAD1 0F,75           XML  VCHAR             Disply them
[1929] AAD3 D6,42,B3 VCHAR2 CEQ  COMMAZ,@CHAT      COMMA?   
[1930] AAD6 6A,C6           BS   VCHARZ            No run again
[1931] AAD8 4A,BA           BR   LNKRTN            Done
[1932]               ***********************************************************
[1933]               * SUBROUTINE TO GET ROW, COLUMN VALUES
[1934]               ***********************************************************
[1935]               * Get ROW, COLUMN VALUES AND NUMBER OF CHARACTERS
[1936] AADA 06,AA,FA HVCHR  CALL GPHV              Get X, Y VALUES
[1937] AADD 0F,74           XML  PARSE           * Get character number 
[1938] AADF B6              BYTE RPARZ
[1939] AAE0 06,A8,DD        CALL INTARG
[1940] AAE3 87,00           DCLR @PAD              ZERO OUT
[1941] AAE5 BC,00,4B        ST   @FAC1,@PAD        SAVE THE CHARACTER
[1942] AAE8 BF,4A,00        DST  1,@FAC            ASSUME 1 REPETITION
       AAEB 01
[1943] AAEC D6,42,B6        CEQ  RPARZ,@CHAT       If not right parenthesis
[1944] AAEF 6A,F9           BS   HVCHS
[1945] AAF1 D6,42,B3        CEQ  >B3,@CHAT         COMMA?
[1946] AAF4 4D,59           BR   ERRSYN
[1947] AAF6 06,A2,D7        CALL SUBLP3            Skip comma, Get number
[1948] AAF9 00       HVCHS  RTN
[1949]               ***********************************************************
[1950] AAFA 06,AC,3F GPHV   CALL LPARR             Insure '(', parse, insure ','
[1951]               * RXB PATCH CODE
[1952] AAFD 0F,7E    GPHVRC XML  SPEED             Insure in range
[1953] AAFF 02              BYTE RANGE           *  of 1 - 24
[1954] AB00 01              BYTE 1
[1955] AB01 00,18           DATA 24
[1956] AB03 92,4B           DEC  @FAC1           * Adjust for Assembly
[1957] AB05 E3,4A,00        DSLL 5,@FAC          * FAC times 32  
       AB08 05
[1958] AB09 BD,02,4A        DST  @FAC,@PAD2      * VDP ADDRESS
[1959] AB0C 0F,7E           XML  SPEED           * Get column value
[1960] AB0E 01              BYTE PARCOM          *  and insure a comma
[1961] AB0F 0F,7E           XML  SPEED           *  Insure in range
[1962] AB11 02              BYTE RANGE           *  of 1 to 32
[1963] AB12 01              BYTE 1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0034 
RXB 2022
[1964] AB13 00,20           DATA 32
[1965] AB15 92,4B           DEC  @FAC1           * Adjust for Assembly: 0 - 31
[1966] AB17 A1,02,4A        DADD @FAC,@PAD2      * Set column pointer
[1967] AB1A 00              RTN
[1968]               ***********************************************************
[1969]               *               SUBPROGRAM FOR 'CHAR'                     *
[1970]               ***********************************************************
[1971]               * CALL CHAR(char#,pattern,...)                            *
[1972]               ***********************************************************
[1973] AB1B 06,A9,21 CHARLY CALL COMB
[1974] AB1E 0F,79    CHAR5  XML  PGMCHR            Skip "(" or ","
[1975]               * RXB PATCH CODE
[1976] AB20 D6,42,EC        CEQ  ALLZ,@CHAT        ALL token?
[1977] AB23 4B,33           BR   GAB1F             No
[1978] AB25 0F,79           XML  PGMCHR            Skip ALL token
[1979] AB27 06,B1,4D        CALL COMMA2            , COMMA?
[1980] AB2A BE,00,EC        ST   ALLZ,@PAD         Store ALL token at PAD  
[1981] AB2D BF,4A,00        DST  32,@FAC           32 characters for ALL
       AB30 20
[1982] AB31 4B,3C           BR   GAB28
[1983] AB33 0F,7E    GAB1F  XML  SPEED             Get the first value
[1984] AB35 01              BYTE PARCOM         *    and insure a comma
[1985] AB36 0F,7E           XML  SPEED             Insure in range
[1986] AB38 02              BYTE RANGE          *   of 32 - 159
[1987]               * RXB PATCH CODE
[1988] AB39 1E              BYTE 30             
[1989] AB3A 00,9F           DATA 159
[1990] AB3C E3,4A,00 GAB28  DSLL 3,@FAC            Convert chr number to address
       AB3F 03
[1991] AB40 A3,4A,03        DADD >0300,@FAC        CORRECT FOR OFFSET
       AB43 00
[1992] AB44 BD,04,4A        DST  @FAC,@VARY        Save it
[1993] AB47 0F,74           XML  PARSE             Get string
[1994] AB49 B6              BYTE RPARZ          *  )?
[1995] AB4A D6,4C,65        CEQ  >65,@FAC2         MUST BE STRING
[1996] AB4D 4D,5D           BR   ERRSNM            ERROR STRING NUMBER MISMATCH
[1997] AB4F 35,00,04        MOVE 4,@FAC4,@VAR5     VAR5 pointer to string value
       AB52 10,4E
[1998]               * Start defining character description.
[1999]               *    VARY    Address of RAM for character description.
[2000]               *    VAR5    Pointer to string value.
[2001]               *    VAR7    Length of string value.
[2002]               *    VAR9    Temporary counter.
[2003]               *    VAR9+1  Temporary counter.
[2004] AB54 C7,12,00        DCH  240,@VAR7         Max 15 characters at a time
       AB57 F0
[2005] AB58 4B,5E           BR   CHAR40
[2006] AB5A BF,12,00        DST  240,@VAR7         IGNORE THE EXCESSES
       AB5D F0
[2007] AB5E CB,04,07 CHAR40 DCHE SPRVB,@VARY       Don't have space for
       AB61 FF
[2008] AB62 6D,65           BS   ERRMEM            ERROR OUT OF MEMORY
[2009] AB64 BE,4A,30        ST   ZERO,@FAC         Floating Point Accumulator (>
[2010] AB67 35,00,0F        MOVE 15,@FAC,@FAC1
       AB6A 4B,4A
[2011] AB6C 8F,12           DCZ  @VAR7             Fill with zero
[2012] AB6E 6B,8D           BS   CHAR50
[2013] AB70 CB,12,00        DCHE 16,@VAR7
       AB73 10
[2014] AB74 6B,7F           BS   GAB6B
[2015] AB76 34,12,4A        MOVE @VAR7,V*VAR5,@FAC Move whatever
       AB79 B0,10
[2016] AB7B 87,12           DCLR @VAR7
[2017] AB7D 4B,8D           BR   CHAR50

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0035 
RXB 2022
[2018] AB7F 35,00,10 GAB6B  MOVE 16,V*VAR5,@FAC    Move one character
       AB82 4A,B0,10
[2019] AB85 A7,12,00        DSUB 16,@VAR7          Less num of bytes to move
       AB88 10
[2020] AB89 A3,10,00        DADD 16,@VAR5          Move pointer
       AB8C 10
[2021] AB8D BE,14,4A CHAR50 ST   >4A,@VAR9         Move pointer (>4A=FAC)
[2022] AB90 BE,15,01        ST   1,@VAR9+1
[2023] AB93 05,AB,98        B    GAB84
[2024] AB96 90,15    GAB82  INC  @VAR9+1
[2025] AB98 CE,15,08 GAB84  CGT  8,@VAR9+1
[2026] AB9B 6B,D7           BS   GABC3
[2027] AB9D 86,0C           CLR  @BYTES            Clear dot-building byte
[2028] AB9F E2,0C,04 CHARL2 SLL  4,@BYTES          For loop(2 chars per byte)
[2029] ABA2 BC,5C,90        ST   *VAR9,@ARG
       ABA5 14
[2030] ABA6 CA,5C,30        CHE  ZERO,@ARG         If < 0
[2031] ABA9 4D,8D           BR   ERRBV
[2032] ABAB CE,5C,39        CGT  NINE,@ARG         If in 0-9
[2033] ABAE 4B,BA           BR   CHARL3
[2034] ABB0 CA,5C,41        CHE  A,@ARG            If > 9 but < A
[2035] ABB3 4D,8D           BR   ERRBV
[2036] ABB5 C6,5C,46        CH   F,@ARG            If > F
[2037] ABB8 6D,8D           BS   ERRBV
[2038] ABBA A6,5C,30 CHARL3 SUB  ZERO,@ARG         Character - >30
[2039] ABBD C6,5C,0A        CH   10,@ARG           If in A-F
[2040] ABC0 4B,C5           BR   GABB1
[2041] ABC2 A6,5C,07        SUB  7,@ARG            Correct for that too
[2042] ABC5 B4,0C,5C GABB1  OR   @ARG,@BYTES       Dot expression
[2043] ABC8 90,14           INC  @VAR9
[2044] ABCA DA,14,01        CLOG 1,@VAR9           1st half of row finished?
[2045] ABCD 4B,9F           BR   CHARL2            Yes, do 2nd half
[2046]               *                              (each takes half byte)
[2047] ABCF BC,B0,04        ST   @BYTES,V*VARY     Load characters
       ABD2 0C
[2048] ABD3 91,04           DINC @VARY
[2049] ABD5 4B,96           BR   GAB82             Load characters on next row
[2050] ABD7 8F,12    GABC3  DCZ  @VAR7             More char to describe
[2051] ABD9 4B,5E           BR   CHAR40
[2052]               * RXB PATCH CODE
[2053] ABDB D6,00,EC        CEQ  ALLZ,@PAD
[2054] ABDE 4B,F4           BR   CHARL4
[2055] ABE0 87,00           DCLR @PAD
[2056] ABE2 35,00,08 CHRFIL MOVE 8,V@>0400,V@>0408(@PAD)
       ABE5 E4,08,00
       ABE8 A4,00
[2057] ABEA A3,00,00        DADD 8,@PAD
       ABED 08
[2058] ABEE D7,00,02        DCEQ 94*8,@PAD
       ABF1 F0
[2059] ABF2 4B,E2           BR   CHRFIL
[2060] ABF4 D6,42,B3 CHARL4 CEQ  COMMAZ,@CHAT      More specified?
[2061] ABF7 6B,1E           BS   CHAR5
[2062] ABF9 4A,BA           BR   LNKRTN            Return
[2063]               ***********************************************************
[2064]               *              SUBPROGRAM FOR 'KEY'
[2065]               ***********************************************************
[2066]               * CALL KEY(keyunit,key#,stutus-variable,...)              *
[2067]               * CALL KEY(string,keyunit,key#,status-variable,...)       *
[2068]               ***********************************************************
[2069] ABFB 06,BA,78 KEY    CALL SPAR              GET KEY UNIT
[2070]               * RXB PATCH LABEL ************
[2071] ABFE 0F,7E    GABD1  XML  SPEED             Insure in range
[2072] AC00 02              BYTE RANGE          *   of 0 - 5

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0036 
RXB 2022
[2073] AC01 00              BYTE 0
[2074] AC02 00,05           DATA 5
[2075] AC04 06,B9,02        CALL KEYJOY            Get variables for code and st
[2076]               *                              and scan keyboard
[2077]               *                             KEYJOY returns key status
[2078] AC07 6C,12           BS   KEY1B             KEY STATUS = 1
[2079] AC09 83,4A           DNEG @FAC              Assume status = -1
[2080] AC0B D6,75,FF        CEQ  >FF,@RKEY         But correct if = 0
[2081] AC0E 4C,12           BR   KEY1B
[2082] AC10 87,4A           DCLR @FAC              KEY STATUS = 0
[2083] AC12 0F,7C    KEY1B  XML  ASSGNV            Assign value in variable
[2084] AC14 BF,4A,40        DST  >4001,@FAC        Re-store F.P. 1 in FAC
       AC17 01
[2085] AC18 8E,75           CZ   @RKEY             If key-code = 0
[2086] AC1A 6C,3A           BS   KEY2
[2087] AC1C D6,75,FF        CEQ  >FF,@RKEY         No key depressed,
[2088] AC1F 6C,36           BS   KEY1C              key code assigned to -1
[2089]               * FORMAT FOR KEYCODES ABOVE 99 ADDED FOR 99/4A HIGHEST
[2090]               * KEYCODE (OTHER THAN >FF) IS >C6=198
[2091]               * 5/7/81
[2092] AC21 CA,75,64        CHE  100,@RKEY
[2093] AC24 4C,31           BR   GAC04
[2094] AC26 90,4A           INC  @FAC
[2095] AC28 A6,75,64        SUB  100,@RKEY
[2096] AC2B BC,4C,75        ST   @RKEY,@FAC2       FLOATING FORMAT (>4001__00000
[2097] AC2E 05,AC,34        B    GAC07
[2098] AC31 BC,4B,75 GAC04  ST   @RKEY,@FAC1       FLOATING FORMAT (>40__0000000
[2099] AC34 4C,3C    GAC07  BR   KEY2A
[2100] AC36 83,4A    KEY1C  DNEG @FAC              KEY CODE ASSIGNED TO -1
[2101] AC38 4C,3C           BR   KEY2A
[2102] AC3A 87,4A    KEY2   DCLR @FAC              (>000000000000000)
[2103] AC3C 0F,7C    KEY2A  XML  ASSGNV            ASSIGN VALUE TO VARIABLE
[2104]               * RXB PATCH CODE *************
[2105]               *      BR   LNKRTN
[2106] AC3E 00              RTN
[2107]               ***********************************************************
[2108]               * RXB PATCH WAS SUBPROGRAM FOR 'JOYSTICK'
[2109]               ***********************************************************
[2110]               *       CALL SPAR              KEY UNIT
[2111]               *       XML  SPEED             Insure in range
[2112]               *       BYTE RANGE          *   of 1 - 4
[2113]               *       BYTE 1
[2114]               *       DATA 4
[2115]               *       CALL KEYJOY           GET VARIABLES FOR X, Y
[2116]               *                              AND SCAN KEYBOARD
[2117]               *      ST   @JOYY,@PAD        JOYSTICK Y POSITION
[2118]               *      CALL JOYXY             -4 to +4
[2119]               *      DST  >4001,@FAC        Re-store F.P. 1 in FAC
[2120]               *      ST   @JOYX,@PAD        JOYSTICK X POSITION
[2121]               *      CALL JOYXY             -4 to +4
[2122]               *      BR   LNKRTN
[2123]               ***********************************************************
[2124]               * INSURE LEFT PARENTHESIS AND THEN PARSE TO A COMMA
[2125]               ***********************************************************
[2126]               * RXB PATCH CODE
[2127] AC3F D6,42,B3 LPARR  CEQ  COMMAZ,@CHAT
[2128] AC42 6C,4A           BS   CPAR
[2129] AC44 0F,7E           XML  SPEED           *  Must be
[2130] AC46 00              BYTE SYNCHK          *  at a
[2131] AC47 B7              BYTE LPARZ           *    left parenthesis
[2132] AC48 4C,4E           BR   CPAR2
[2133] AC4A 0F,7E    CPAR   XML  SPEED
[2134] AC4C 00               BYTE SYNCHK
[2135] AC4D B3               BYTE COMMAZ

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0037 
RXB 2022
[2136]               * RXB PATCH LABEL ***********
[2137] AC4E 0F,74    CPAR2  XML  PARSE             Do the parse
[2138] AC50 B3              BYTE COMMAZ          * Stop on a comma
[2139] AC51 0F,7E           XML  SPEED           *  Must be
[2140] AC53 00              BYTE SYNCHK          *  at a
[2141] AC54 B3              BYTE COMMAZ          *    left comma
[2142] AC55 00              RTN
[2143]               *****************************
[2144] AC56 0F,7E    CPAR3  XML  SPEED           * Similar to LPARR
[2145] AC58 00,B3           DATA COMMAZ          * Syntax check ,
[2146] AC5A 4C,4E           BR   CPAR2           * Parse value
[2147]               ***********************************************************
[2148]               * SUBROUTINE FOR 'RANGE' USED IN ALL SOUND AND GRAPHICS
[2149]               ***********************************************************
[2150] AC5C 0F,7E    RAN16  XML  SPEED             Insure in range
[2151] AC5E 02              BYTE RANGE          *   of 1 to 16
[2152] AC5F 01              BYTE 1
[2153] AC60 00,10           DATA 16
[2154] AC62 92,4B           DEC  @FAC1             Adjust to internal range
[2155] AC64 00              RTN
[2156]               ***********************************************************
[2157]               * CALL SCREEN(color-code)                                  
[2158]               * CALL SCREEN("OFF")                                       
[2159]               * CALL SCREEN("ON")                                        
[2160]               ***********************************************************
[2161]               *  Subroutine to control border color
[2162]               * Character background is also affected since transparent
[2163]               *  is used.
[2164] AC65 D6,42,B7 BORDER CEQ  LPARZ,@CHAT     * If not '(' - error
[2165] AC68 4D,59           BR   ERRSYN          * ERROR SYNTAX
[2166] AC6A 06,A2,AE BORAGN CALL STRFCH          * Skip ( or , and get it 
[2167] AC6D D7,B0,4E        DCEQ >4F46,V*FAC4    * OF? SCREEN OFF      
       AC70 4F,46
[2168] AC72 4C,7A           BR   SCRON           * No, check for ON
[2169] AC74 B2,80,D4        AND  >BF,@VDPR1      * TURN OFF SCREEN
       AC77 BF
[2170] AC78 4C,85           BR   LDSCRN          * Return to XB program
[2171] AC7A D7,B0,4E SCRON  DCEQ >4F4E,V*FAC4    * ON? SCREEN ON
       AC7D 4F,4E
[2172] AC7F 4C,8D           BR   BORDES          * Must be a number
[2173] AC81 B6,80,D4        OR   >40,@VDPR1      * TURN ON SCREEN
       AC84 40
[2174] AC85 3D,00,01 LDSCRN MOVE 1,@VDPR1,#1     * LOAD REGISTER 1
       AC88 01,80,D4
[2175] AC8B 4C,94           BR   BORCRN          * Return to XB program
[2176] AC8D 92,4B    BORDES DEC  @FAC1           * Adjust to internal range
[2177] AC8F 3D,00,01        MOVE 1,@FAC1,#7      * Load VDP register
       AC92 07,4B
[2178] AC94 D6,42,B3 BORCRN CEQ  COMMAZ,@CHAT    * , COMMA?
[2179] AC97 6C,6A           BS   BORAGN          * MORE SO REPEAT
[2180] AC99 4A,BA           BR   LNKRTN          * Return to XB program
[2181]               ***********************************************************
[2182]               * ERRWXY - Is the subroutine for CALL ERR(W,X,Y,Z)
[2183]               *  The parameters indicate:
[2184]               *   W - The error code # of the error
[2185]               *   X - Indicates whether execution(-1) error or
[2186]               *       I/O (0-255) error on LUNO 0-255
[2187]               *   Y - Indicates the severity code of the error
[2188]               *   Z - Line number of the error
[2189]               *   ERR Can be called with 2 forms:
[2190]               *       CALL ERR(W,X,Y,Z) and CALL ERR(W,X)
[2191]               *   If ERR is called and no error has occured then all
[2192]               *   values returned are zero.
[2193]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0038 
RXB 2022
[2194] AC9B BD,52,6E ERRWXY DST  @VSPTR,@FAC8      Get a temp VSPTR
[2195] AC9E C5,52,24 GAC99  DCH  @STVSPT,@FAC8     While not a bottom of stack
[2196] ACA1 4C,D5           BR   GACD0
[2197] ACA3 BC,5C,E0        ST   V@2(@FAC8),@ARG   Keep ID code in ARG area
       ACA6 02,52
[2198] ACA8 D6,5C,69        CEQ  >69,@ARG          *** ERROR entry
[2199] ACAB 4C,B4           BR   GACAF
[2200] ACAD 06,A9,27        CALL SQUISH            Squish it out of the stack
[2201] ACB0 0F,77           XML  VPUSH             Put permanent copy of error
[2202]               *                              entry on stack
[2203] ACB2 4C,E1           BR   ERR10             Jump out now
[2204]               * Jump always
[2205] ACB4 D6,5C,67 GACAF  CEQ  >67,@ARG          *** FOR entry
[2206] ACB7 4C,BF           BR   GACBA
[2207] ACB9 A7,52,00        DSUB 32,@FAC8          Skip it
       ACBC 20
[2208] ACBD 4C,D3           BR   GACCE
[2209] ACBF D6,5C,66 GACBA  CEQ  >66,@ARG          *** GOSUB entry
[2210] ACC2 4C,CA           BR   GACC5
[2211] ACC4 A7,52,00        DSUB 8,@FAC8           Skip it
       ACC7 08
[2212] ACC8 4C,D3           BR   GACCE
[2213] ACCA D6,5C,6A GACC5  CEQ  >6A,@ARG          * SYNTAX ERROR
[2214] ACCD 4D,59           BR   ERRSYN
[2215] ACCF A7,52,00        DSUB 16,@FAC8          Skip it
       ACD2 10
[2216] ACD3 4C,9E    GACCE  BR   GAC99
[2217] ACD5 BF,4A,00 GACD0  DST  >0080,@FAC        No error entry there so
       ACD8 80
[2218] ACD9 BF,4C,69        DST  >6900,@FAC2        fake one
       ACDC 00
[2219] ACDD 87,4E           DCLR @FAC4
[2220] ACDF 87,50           DCLR @FAC6
[2221] ACE1 0F,77    ERR10  XML  VPUSH             Push the temporary entry on
[2222]               *                              top of stack
[2223]               * Code to get "W" in
[2224] ACE3 06,A9,21        CALL COMB              Check for left parenthesis
[2225] ACE6 06,AD,4E        CALL ERRC05            Pick up user's symbol
[2226] ACE9 BC,4B,EF        ST   V@-8(@VSPTR),@FAC1 Get error code
       ACEC FF,F8,6E
[2227] ACEF 06,A3,09        CALL CIFSND            Convert to floating,Assign it
[2228]               * Code to get "X" in
[2229] ACF2 06,AD,49        CALL ERRCOM            Check syntax & get user's sym
[2230] ACF5 DA,EF,FF        CLOG >80,V@-7(@VSPTR)  If execution
       ACF8 F9,6E,80
[2231] ACFB 4D,07           BR   GAD03
[2232] ACFD 31,00,08        MOVE 8,G@FLT1,@FAC     Make it such
       AD00 4A,A3,44
[2233] AD03 83,4A           DNEG @FAC              Make it a negative
[2234] AD05 4D,0F           BR   GAD0B
[2235] AD07 BC,4B,EF GAD03  ST   V@-5(@VSPTR),@FAC1 Get I/O LUNO number
       AD0A FF,FB,6E
[2236] AD0D 0F,80           XML  CIF               Convert it to floating
[2237] AD0F 0F,7C    GAD0B  XML  ASSGNV            ASSIGN IT
[2238]               * Code to get "Y" in
[2239] AD11 D6,42,B6        CEQ  RPARZ,@CHAT       If long form of CALL ERR
[2240] AD14 6D,44           BS   GAD42
[2241] AD16 06,AD,49        CALL ERRCOM            Check syntax & get user's sym
[2242] AD19 BC,4B,EF        ST   V@-7(@VSPTR),@FAC1 Get severity code
       AD1C FF,F9,6E
[2243] AD1F B2,4B,7F        AND  >7F,@FAC1         Reset execution  /  I/O flag
[2244] AD22 06,A3,09        CALL CIFSND            Convert it, Assign it
[2245]               * Code to get "Z" in
[2246] AD25 06,AD,49        CALL ERRCOM            Check syntax & get symbol

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0039 
RXB 2022
[2247] AD28 BD,4C,EF        DST  V@-2(@VSPTR),@FAC2 Get line pointer
       AD2B FF,FE,6E
[2248] AD2E BD,4A,4C        DST  @FAC2,@FAC
[2249] AD31 8F,4C           DCZ  @FAC2             If line number exists
[2250] AD33 6D,41           BS   GAD3E
[2251] AD35 97,4C           DDECT @FAC2            Point to the line #
[2252] AD37 06,60,34        CALL GRSUB1            Read line # (2 bytes) from VD
[2253]               *                              or ERAM (use GREAD)
[2254] AD3A 4C              BYTE >4C             * @FAC2: Source addr on ERAM/VD
[2255] AD3B BD,4A,50        DST  @EEE,@FAC         Put the line # in FAC
[2256] AD3E B2,4A,7F        AND  >7F,@FAC          Reset the breakpoint if any
[2257] AD41 06,A3,09 GAD3E  CALL CIFSND            Convert it, Assign it
[2258] AD44 0F,78    GAD42  XML  VPOP              Trash the temporary entry
[2259] AD46 05,AA,BA        B    LNKRTN            Return from subprogram
[2260]               * Must be long branch because of AND above
[2261] AD49 D6,42,B3 ERRCOM CEQ  COMMAZ,@CHAT      Check for comma
[2262] AD4C 4D,59           BR   ERRSYN
[2263] AD4E 0F,79    ERRC05 XML  PGMCHR            Get the next character
[2264] AD50 0F,7A           XML  SYM               Collect name & s.t. entry
[2265] AD52 0F,7B           XML  SMB               Get value space
[2266] AD54 0F,77           XML  VPUSH             Push it
[2267] AD56 86,4A           CLR  @FAC              Set up for conversion
[2268] AD58 00              RTN
[2269]               * CHANGE IN ADDRESS OF THE ERROR CALLS WILL AFFECT
[2270]               * THE FILE SUBS.....
[2271]               *     ERROR messages called from this file
[2272] AD59 06,6A,84 ERRSYN CALL ERRZZ             * SYNTAX ERROR
[2273] AD5C 03              BYTE 3             *   (shared by SUBS)
[2274] AD5D 06,6A,84 ERRSNM CALL ERRZZ             * STRING-NUMBER MISMATCH
[2275] AD60 07              BYTE 7             *   (shared by SUBS)
[2276] AD61 06,6A,84 ERRMUV CALL ERRZZ             * IMPROPERLY USED NAME
[2277] AD64 09              BYTE 9
[2278] AD65 06,6A,84 ERRMEM CALL ERRZZ             * MEMORY FULL
[2279] AD68 0B              BYTE 11
[2280] AD69 06,6A,84 ERRSO  CALL ERRZZ             * STACK OVERFLOW
[2281] AD6C 0C              BYTE 12
[2282] AD6D 06,6A,84 ERRNWF CALL ERRZZ             * NEXT WITHOUT FOR
[2283] AD70 0D              BYTE 13
[2284] AD71 06,6A,84 ERRFNN CALL ERRZZ             * FOR/NEXT NESTING
[2285] AD74 0E              BYTE 14
[2286] AD75 06,6A,84 ERRSNS CALL ERRZZ             * MUST BE IN SUBPROGRAM
[2287] AD78 0F              BYTE 15
[2288] AD79 06,6A,84 ERRRSC CALL ERRZZ             * RECURSIVE SUBPROGRAM CALL
[2289] AD7C 10              BYTE 16
[2290] AD7D 06,6A,84 ERRRWG CALL ERRZZ             * RETURN WITHOUT GOSUB
[2291] AD80 12              BYTE 18
[2292] AD81 06,6A,84 ERRBS  CALL ERRZZ             * BAD SUBSCRIPT
[2293] AD84 14              BYTE 20
[2294] AD85 06,6A,84 ERRLNF CALL ERRZZ             * LINE NOT FOUND
[2295] AD88 16              BYTE 22
[2296] AD89 06,6A,84 ERRBA  CALL ERRZZ             * BAD ARGUMENTS
[2297] AD8C 1C              BYTE 28
[2298] AD8D 06,6A,84 ERRBV  CALL ERRZZ             * BAD VALUE
[2299] AD90 1E              BYTE 30            *   (shared by SUBS)
[2300] AD91 06,6A,84 ERRIAL CALL ERRZZ             * INCORRECT ARGUMENT LIST
[2301] AD94 1F              BYTE 31            *   (shared by SUBS)
[2302] AD95 06,6A,84 ERRSNF CALL ERRZZ             * SUBPROGRAM NOT FOUND
[2303] AD98 25              BYTE 37
[2304]               * Other error messages appear in this program
[2305]               * ERRRDY      * READY                        DATA 0
[2306]               * ERRBRK      * BREAK POINT                  DATA 1
[2307]               * ERROLP      * ONLY LEGAL IN A PROGRAM      DATA 27
[2308]               *
[2309]               * WRNN01      * NUMERIC OVERFLOW             DATA 2

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0040 
RXB 2022
[2310]               * WRNS02
[2311]               * WRNST1      * STRING TRUNCATED             DATA 19
[2312]               * WRNST2
[2313]               * WRNLNF      * LINE NOT FOUND               DATA 38
[2314]               *
[2315]               ***********************************************************
[2316]               * SPRITE SUBROUTINES BRANCH TABLE
[2317] AD99 50,B8    CHAR1  BR   SPNUM3            Called in CHARLY.    EXEC
[2318] AD9B 50,B1    CHAR2  BR   SPNUM2            Called in CHARLY.    EXEC
[2319] AD9D 4D,9D           BR   $                 Called in CHARLY.    EXEC
[2320]               * SUBROUTINE LINK LIST
[2321] AD9F AD,AA    LINKS1 DATA LINKS2
[2322] ADA1 06,53,50        STRI 'SPRITE'         SPRITE
       ADA4 52,49,54
       ADA7 45
[2323] ADA8 AE,D2           DATA SPRTE
[2324] ADAA AD,B8    LINKS2 DATA LINKS3
[2325] ADAC 09,44,45        STRI 'DELSPRITE'      DELSPRITE
       ADAF 4C,53,50
       ADB2 52,49,54
       ADB5 45
[2326] ADB6 AF,01           DATA SPRDEL
[2327] ADB8 AD,C5    LINKS3 DATA LINKS4
[2328] ADBA 08,50,4F        STRI 'POSITION'       POSITION
       ADBD 53,49,54
       ADC0 49,4F,4E
[2329] ADC3 AF,40           DATA SPRPOS
[2330] ADC5 AD,CF    LINKS4 DATA LINKS5
[2331] ADC7 05,43,4F        STRI 'COINC'          CONIC
       ADCA 49,4E,43
[2332] ADCD B8,DC           DATA ZSCOI
[2333] ADCF AD,DB    LINKS5 DATA LINKS6
[2334] ADD1 07,4D,41        STRI 'MAGNIFY'        MAGNIFY
       ADD4 47,4E,49
       ADD7 46,59
[2335] ADD9 AF,B6           DATA SPRMAG
[2336] ADDB AD,E6    LINKS6 DATA LINKS7
[2337] ADDD 06,4D,4F        STRI 'MOTION'         MOTION
       ADE0 54,49,4F
       ADE3 4E
[2338] ADE4 AF,D3           DATA SPRMOV
[2339] ADE6 AD,F1    LINKS7 DATA LINKS8
[2340] ADE8 06,4C,4F        STRI 'LOCATE'         LOCATE
       ADEB 43,41,54
       ADEE 45
[2341] ADEF AF,E3           DATA SPRLOC
[2342] ADF1 AD,FD    LINKS8 DATA LINKS9
[2343] ADF3 07,50,41        STRI 'PATTERN'        PATTERN
       ADF6 54,54,45
       ADF9 52,4E
[2344] ADFB AF,F7           DATA SPRPAT
[2345] ADFD AE,0A    LINKS9 DATA LINKSA
[2346] ADFF 08,44,49        STRI 'DISTANCE'       DISTANCE
       AE02 53,54,41
       AE05 4E,43,45
[2347] AE08 B8,EB           DATA ZDIST
[2348] AE0A AE,12    LINKSA DATA LINKSB
[2349] AE0C 03,53,41        STRI 'SAY'            SAY
       AE0F 59
[2350] AE10 B1,71           DATA SAY
[2351] AE12 AE,1C    LINKSB DATA LINKSC
[2352] AE14 05,53,50        STRI 'SPGET'          SPGET   
       AE17 47,45,54
[2353] AE1A B2,C8           DATA SPGET

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0041 
RXB 2022
[2354] AE1C AE,28    LINKSC DATA LINKSD
[2355] AE1E 07,43,48        STRI 'CHARSET'        CHARSET
       AE21 41,52,53
       AE24 45,54
[2356] AE26 B0,6F           DATA CHRSET
[2357] AE28 AE,32    LINKSD DATA LINKSE
[2358] AE2A 05,4F,4E        STRI 'ONKEY'          ONKEY
       AE2D 4B,45,59
[2359] AE30 B9,63           DATA  ZONKEY
[2360] AE32 AE,3C    LINKSE DATA LINKSF
[2361] AE34 05,4D,4F        STRI 'MOVES'          MOVES
       AE37 56,45,53
[2362] AE3A B5,CA           DATA MOVES
[2363] AE3C AE,45    LINKSF DATA LINKSG
[2364] AE3E 04,48,50        STRI 'HPUT'           HPUT
       AE41 55,54
[2365] AE43 B7,84           DATA HPUTZ
[2366] AE45 AE,4E    LINKSG DATA LINKSH
[2367] AE47 04,56,50        STRI 'VPUT'           VPUT
       AE4A 55,54
[2368] AE4C B7,94           DATA VPUTZ
[2369] AE4E AE,57    LINKSH DATA LINKSI
[2370] AE50 04,48,47        STRI 'HGET'           HGET
       AE53 45,54
[2371] AE55 B7,D1           DATA HGETZ 
[2372] AE57 AE,60    LINKSI DATA LINKSJ
[2373] AE59 04,56,47        STRI 'VGET'           VGET
       AE5C 45,54
[2374] AE5E B7,EF           DATA VGETZ
[2375] AE60 AE,6C    LINKSJ DATA LINKSK
[2376] AE62 07,47,4D        STRI 'GMOTION'        GMOTION
       AE65 4F,54,49
       AE68 4F,4E
[2377] AE6A B8,49           DATA GMOT
[2378] AE6C AE,78    LINKSK DATA LINKSL
[2379] AE6E 07,52,4D        STRI 'RMOTION'        RMOTION
       AE71 4F,54,49
       AE74 4F,4E
[2380] AE76 B8,80           DATA RMOT
[2381] AE78 AE,80    LINKSL DATA LINKSM
[2382] AE7A 03,48,45        STRI 'HEX'            HEX
       AE7D 58
[2383] AE7E B6,B7           DATA HEX
[2384] AE80 AE,8E    LINKSM DATA LINKSN
[2385] AE82 09,4A,4F        STRI 'JOYMOTION'      JOYMOTION
       AE85 59,4D,4F
       AE88 54,49,4F
       AE8B 4E
[2386] AE8C BA,9F           DATA ZJOMO
[2387] AE8E AE,9C    LINKSN DATA LINKSO
[2388] AE90 09,4A,4F        STRI 'JOYLOCATE'      JOYLOCATE 
       AE93 59,4C,4F
       AE96 43,41,54
       AE99 45
[2389] AE9A BB,58           DATA ZJOLO
[2390] AE9C AE,A9    LINKSO DATA LINKSP
[2391] AE9E 08,53,57        STRI 'SWAPCHAR'       SWAPCHAR
       AEA1 41,50,43
       AEA4 48,41,52
[2392] AEA7 BB,FA           DATA SWCHR 
[2393] AEA9 AE,B7    LINKSP DATA LINKSQ
[2394] AEAB 09,53,57        STRI 'SWAPCOLOR'      SWAPCOLOR
       AEAE 41,50,43
       AEB1 4F,4C,4F

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0042 
RXB 2022
       AEB4 52
[2395] AEB5 BC,2C           DATA SWCLR
[2396] AEB7 AE,C6    LINKSQ DATA LINKSS          
[2397] AEB9 0A,43,4C        STRI 'CLEARPRINT'     CLEARPRINT       
       AEBC 45,41,52
       AEBF 50,52,49
       AEC2 4E,54
[2398] AEC4 BC,8D           DATA  CLRS
[2399] AEC6 C0,10    LINKSS DATA >C010          * LINK LIST IN >C000 
[2400] AEC8 07,43,4F        STRI 'COLLIDE'        COLLIDE
       AECB 4C,4C,49
       AECE 44,45
[2401] AED0 BD,41           DATA COLL
[2402]               ***********************************************************
[2403]               * CALL SPRITE(#SPRITE,CHAR,COLOR,Y,X,(YSPEED,XSPEED),...) *
[2404]               ***********************************************************
[2405] AED2 06,A9,21 SPRTE  CALL COMB             Check sprite mode and skip "(
[2406] AED5 06,B0,B1        CALL SPNUM2            Get sprite number
[2407] AED8 06,B0,F2 SPRT3  CALL SPCHR             Put character number for spri
[2408]               * RXB PATCH CODE SAVES 3 BYTES (LOL)
[2409]               *       XML  SPEED
[2410]               *       BYTE SYNCHK
[2411]               *       BYTE COMMAZ         *  Check for comma and skip it
[2412] AEDB 06,BA,9A        CALL SPAR2           * RXB COMMA SPEED CHECKER 
[2413] AEDE 06,A0,1E        CALL GA01E             Put sprite color in SAL  (SPC
[2414]               * RXB PATCH CODE SAVES 3 BYTES (LOL)
[2415]               *       XML  SPEED             Insure at a comma
[2416]               *       BYTE SYNCHK
[2417]               *       BYTE COMMAZ
[2418] AEE1 06,BA,9A        CALL SPAR2           * RXB COMMA SPEED CHECKER
[2419] AEE4 06,B0,D5        CALL SPLOC             Put location of sprite in SAL
[2420] AEE7 BD,B0,08        DST  @SP04+1,V*SPSAL   Put in location of sprite
       AEEA 05
[2421]               * Finish defining SAL. Check if velocity is specified
[2422] AEEB D6,42,B3 SPRT4  CEQ  COMMAZ,@CHAT      Finished!!!!!
[2423] AEEE 4A,BA           BR   LNKRTN
[2424] AEF0 0F,79           XML  PGMCHR
[2425] AEF2 D6,42,FD        CEQ  NUMBEZ,@CHAT      Next sprite specified
[2426] AEF5 4E,FC           BR   GAEBB
[2427] AEF7 06,B0,B8        CALL SPNUM3            Get the next sprite number
[2428] AEFA 4E,D8           BR   SPRT3             And go!
[2429] AEFC 06,B1,04 GAEBB  CALL SPMOVE            Get the velocity first
[2430] AEFF 4E,EB           BR   SPRT4
[2431]               ***********************************************************
[2432]               * CALL DELSPRITE(#SPR,.......)  or CALL DESPRITE(ALL)     *
[2433]               ***********************************************************
[2434] AF01 06,A9,21 SPRDEL CALL COMB              Insure at '('
[2435] AF04 0F,79    SPDEL1 XML  PGMCHR            Skip "(" or ","
[2436] AF06 D6,42,FD        CEQ  NUMBEZ,@CHAT      If sprite number
[2437] AF09 4F,37           BR   GAEF6
[2438] AF0B 0F,79           XML  PGMCHR            Skip "#"
[2439] AF0D 0F,74           XML  PARSE             Parse the sprite number
[2440] AF0F B6              BYTE RPARZ
[2441] AF10 06,B0,BD        CALL SPNUM4            Check and convert number
[2442] AF13 87,E4,80        DCLR V@>0480(@SPSAL)   Stop motion if moving
       AF16 08
[2443] AF17 BF,B0,08        DST  >C000,V*SPSAL     Hide the sprite off screen
       AF1A C0,00
[2444]               *----------------------------------------------------------
[2445]               * Add following 7 lines for speeding up XBASIC
[2446] AF1C D4,A3,AA        CEQ  @NOMSPR,V@SPNUM   Check current sprite
       AF1F 7A
[2447] AF20 4F,30           BR   SPDEL2
[2448]               * no. against sprite motion count

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0043 
RXB 2022
[2449]               * yes, change to as low as possible
[2450] AF22 92,7A    GAEE1  DEC  @NOMSPR
[2451] AF24 6F,30           BS   SPDEL2
[2452] AF26 A7,08,00        DSUB 4,@SPSAL
       AF29 04
[2453] AF2A 8F,E4,80        DCZ  V@>0480(@SPSAL)
       AF2D 08
[2454] AF2E 6F,22           BS   GAEE1
[2455]               *----------------------------------------------------------
[2456] AF30 D6,42,B3 SPDEL2 CEQ  COMMAZ,@CHAT      If more sprites
[2457] AF33 6F,04           BS   SPDEL1
[2458] AF35 4F,3E           BR   GAEFD
[2459] AF37 0F,7E    GAEF6  XML  SPEED             Must have 'ALL' else error
[2460] AF39 00              BYTE SYNCHK
[2461] AF3A EC              BYTE ALLZ
[2462] AF3B 06,60,16        CALL SPRINT            Reinitialize all sprites
[2463] AF3E 4A,BA    GAEFD  BR   LNKRTN            Return to caller
[2464]               ***********************************************************
[2465]               * CALL POSITION(#SPR,Y,X,...)                             *
[2466]               ***********************************************************
[2467] AF40 06,A9,21 SPRPOS CALL COMB             Check for sprites and skip "(
[2468] AF43 06,B0,B1 SPRP02 CALL SPNUM2            Check sprite number
[2469] AF46 06,B1,63        CALL PREPN             Prepare Y-position return var
[2470]               * RXB PATCH CODE SAVES 3 BYTES (LOL)
[2471]               *       XML  SPEED             Insure at a comma
[2472]               *       BYTE SYNCHK
[2473]               *       BYTE COMMAZ
[2474] AF49 06,BA,9A        CALL SPAR2          * RXB COMMA SPEED CHECKER
[2475] AF4C BD,00,B0        DST  V*SPSAL,@SP00     Read X, Y position
       AF4F 08
[2476] AF50 BC,4B,00        ST   @SP00,@FAC1       Get Y position
[2477] AF53 D6,4B,FE        CEQ  >FE,@FAC1
[2478] AF56 4F,5C           BR   GAF1C
[2479] AF58 95,4A           DINCT @FAC             Get 256 as an output
[2480] AF5A 4F,5E           BR   GAF1E
[2481] AF5C 94,4B    GAF1C  INCT @FAC1             Regular adjustment for user
[2482] AF5E 06,AF,73 GAF1E  CALL SPRP03            Check, convert & assign value
[2483] AF61 06,B1,63        CALL PREPN             Prepare X-pos return variable
[2484] AF64 BC,4B,01        ST   @SP00+1,@FAC1     Get X position
[2485] AF67 91,4A           DINC @FAC              Adjust for the user
[2486] AF69 06,AF,73        CALL SPRP03            Check, convert & assign value
[2487] AF6C D6,42,B3        CEQ  COMMAZ,@CHAT      If not finished
[2488] AF6F 6F,43           BS   SPRP02
[2489] AF71 4A,BA           BR   LNKRTN 
[2490]               * Check, convert & assign value                      
[2491] AF73 0F,80    SPRP03 XML  CIF               Convert INT to FP
[2492] AF75 D7,00,C0        DCEQ >C000,@SP00       If hidden sprite
       AF78 00
[2493] AF79 4F,7E           BR   SCIFDN
[2494] AF7B 06,A3,1F        CALL CLRFAC            Return value zero
[2495] AF7E 05,A3,0B SCIFDN B    SNDASS            Assign and snd 
[2496]               ***********************************************************
[2497]               * CALL COINC(#SPR,#SPR,TOLERANCE,CODE)                    *
[2498]               * CALL COINC(#SPR,YLOC,XLOC,TOLERANCE,CODE)               *
[2499]               * CALL COINC(ALL)                                         *
[2500]               ***********************************************************
[2501] AF81 06,A9,21 SPRCOI CALL COMB
[2502] AF84 0F,79           XML  PGMCHR            Skip "("
[2503] AF86 D6,42,EC        CEQ  ALLZ,@CHAT        Check coinc of all sprites
[2504] AF89 4F,97           BR   GAF56
[2505] AF8B 0F,79           XML  PGMCHR            Skip "ALL"
[2506] AF8D 06,B1,4D        CALL COMMA2            Check and skip ","
[2507] AF90 DA,7B,20        CLOG >20,@VDPSTT       Check VDP status
[2508] AF93 71,5D           BS   MYNR              MY NULL RETURN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0044 
RXB 2022
[2509] AF95 4F,AD           BR   GAF6C
[2510] AF97 06,B0,2F GAF56  CALL CODIST            Get distance of 2 sprites
[2511] AF9A 06,B1,4A        CALL COMMA1            Get tolerance level
[2512] AF9D 0F,7E           XML  SPEED
[2513] AF9F 02              BYTE RANGE           * Check against range
[2514] AFA0 00              BYTE 0               * FAC has tolerance level
[2515] AFA1 00,FF           DATA 255
[2516] AFA3 C5,00,4A        DCH  @FAC,@SP00        Y-loc out of range
[2517] AFA6 71,5D           BS   MYNR              MY NULL RETURN            
[2518] AFA8 C5,04,4A        DCH  @FAC,@SP04        X-loc out of range
[2519] AFAB 71,5D           BS   MYNR              MY NULL RETURN
[2520]               * If no conincidence just return zero
[2521] AFAD 06,B1,63 GAF6C  CALL PREPN             Prepare for numeric output
[2522] AFB0 BF,4A,BF        DST  >BFFF,@FAC        Store -1 in FAC
       AFB3 FF
[2523] AFB4 43,0B           BR   SNDASS
[2524]               ***********************************************************
[2525]               * CALL MAGNIFY(magnification factor=1 - 4)                *
[2526]               * CALL MAGNIFY(number,number,number)                      *
[2527]               * CALL MAGNIFY(variable,variable,variable)                *
[2528]               ***********************************************************
[2529] AFB6 06,A9,21 SPRMAG CALL COMB             Insure at "("
[2530] AFB9 0F,79    SPRMLP XML  PGMCHR            Skip the "("
[2531] AFBB 0F,74           XML  PARSE             Parse the magnification facto
[2532] AFBD B6              BYTE RPARZ          
[2533] AFBE 0F,7E           XML  SPEED
[2534] AFC0 02              BYTE RANGE            * Magnification 1 to 4
[2535] AFC1 01              BYTE 1              
[2536] AFC2 00,04           DATA 4
[2537]               * Next statement adding >DF to subtract 1 from FAC
[2538] AFC4 A2,4B,DF        ADD  >DF,@FAC1         Turn on screen and interrupt
[2539] AFC7 3D,00,01        MOVE 1,@FAC1,#1        Store it to VDP register 1
       AFCA 01,4B
[2540] AFCC D6,42,B3        CEQ  COMMAZ,@CHAT      COMMA?
[2541] AFCF 6F,B9           BS   SPRMLP            Yes, loop
[2542] AFD1 4A,BA           BR   LNKRTN            Return to XB
[2543]               ***********************************************************
[2544]               * CALL MOTION(#SPR,YSPEED,XSPEED,...)                     *
[2545]               ***********************************************************
[2546] AFD3 06,A9,21 SPRMOV CALL COMB              Insure at "("
[2547]               * RXB PATCH CODE *************
[2548]               * SPRMV2 CALL SPNUM2          Get sprite number
[2549] AFD6 05,BA,26 SPRMV2 B    SPGS              # or ALL or GO or STOP
[2550] AFD9 06,B1,04 SPRMV3 CALL SPMOVE            Store velocity
[2551] AFDC D6,42,B3 SPRMV4 CEQ  COMMAZ,@CHAT      Loop if more
[2552] AFDF 6F,D6           BS   SPRMV2
[2553] AFE1 4A,BA           BR   LNKRTN
[2554]               ***********************************************************
[2555]               * CALL LOCATE(#SPR,YLOC,XLOC,...)                         *
[2556]               ***********************************************************
[2557] AFE3 06,A9,21 SPRLOC CALL COMB             Insure at "("
[2558] AFE6 06,B0,B1 SPRLC2 CALL SPNUM2            Check sprite number
[2559] AFE9 06,B0,D5        CALL SPLOC             Read location
[2560] AFEC BD,B0,08        DST  @SP04+1,V*SPSAL   Put in sprite location
       AFEF 05
[2561] AFF0 D6,42,B3        CEQ  COMMAZ,@CHAT      Loop if more
[2562] AFF3 6F,E6           BS   SPRLC2
[2563] AFF5 4A,BA           BR   LNKRTN
[2564]               ***********************************************************
[2565]               * CALL PATTERN(#SPR,CHAR,...)                             *
[2566]               ***********************************************************
[2567] AFF7 06,A9,21 SPRPAT CALL COMB             Insure at "("
[2568] AFFA 06,B0,B1 SPRPT2 CALL SPNUM2            Get sprite number
[2569] AFFD 06,B0,F2        CALL SPCHR             Set the sprite character

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0045 
RXB 2022
[2570] B000 D6,42,B3        CEQ  COMMAZ,@CHAT      Loop if more
[2571] B003 6F,FA           BS   SPRPT2
[2572] B005 4A,BA           BR   LNKRTN
[2573]               ***********************************************************
[2574]               * CALL DISTANCE(#1,#2,DISTANCE)                           *
[2575]               * CALL DISTANCE(#1,Y,X,DISTANCE)                          *
[2576]               ***********************************************************
[2577] B007 06,A9,21 DIST   CALL COMB             Insure at "("
[2578]               * RXB PATCH LABEL ************
[2579] B00A 0F,79    GAFC4  XML  PGMCHR            Skip "("
[2580] B00C 06,B0,2F        CALL CODIST            Get distance in Y and X
[2581] B00F 06,B1,63        CALL PREPN             Prepare return variable
[2582] B012 A9,00,00        DMUL @SP00,@SP00       X=X*X
[2583] B015 A9,04,04        DMUL @SP04,@SP04       Y=Y*Y
[2584] B018 A1,02,06        DADD @SP06,@SP02       @SP02=X*X+Y*Y
[2585] B01B 0D              OVF                    Checking overflow bit
[2586] B01C 70,27           BS   OVER              If overflow-indicate maximum
[2587] B01E BD,4A,02        DST  @SP02,@FAC        Put distance squared in FAC
[2588] B021 C7,02,7F        DCH  >7FFF,@SP02       If bigger then 128
       B024 FF
[2589] B025 50,2B           BR   GAFE5
[2590] B027 BF,4A,7F OVER   DST  >7FFF,@FAC        Put maximum value
       B02A FF
[2591] B02B 0F,80    GAFE5  XML  CIF               Convert to floating format
[2592] B02D 43,0B           BR   SNDASS
[2593]               ***********************************************************
[2594]               * CODIST routine gets locations of two sprites or one
[2595]               *  sprite and Y and X position specified by a user and
[2596]               *  calculates absolute value of Y and X distance.
[2597]               ***********************************************************
[2598] B02F 86,00    CODIST CLR  @SP00             SP00=>8300
[2599] B031 35,00,07        MOVE 7,@SP00,@SP00+1   Clear up first 8 bytes
       B034 01,00
[2600] B036 D6,42,FD        CEQ  NUMBEZ,@CHAT      Check for #
[2601] B039 4D,59           BR   ERRSYN
[2602] B03B 06,B0,B8        CALL SPNUM3            Get the first sprite
[2603] B03E BD,01,B0        DST  V*SPSAL,@SP00+1   Location of first sprite
       B041 08
[2604] B042 90,01           INC  @SP00+1           Increment to make range 1-256
[2605] B044 BC,03,02        ST   @SP02,@SP02+1     Put X in SP02+1
[2606] B047 86,02           CLR  @SP02             Y in SP00+1
[2607] B049 D6,42,FD        CEQ  NUMBEZ,@CHAT      Get 2nd sprite
[2608] B04C 50,57           BR   GB011
[2609] B04E 06,B0,B8        CALL SPNUM3            Get the next sprite
[2610] B051 BD,05,B0        DST  V*SPSAL,@SP04+1   Location of second sprite
       B054 08
[2611] B055 50,5D           BR   GB017
[2612] B057 06,B0,D5 GB011  CALL SPLOC             Get Y and X location
[2613] B05A 06,B1,4D        CALL COMMA2            Check for comma and skip
[2614] B05D 90,05    GB017  INC  @SP04+1           Increment to make range 1-256
[2615] B05F A5,00,04        DSUB @SP04,@SP00       Difference in Y at SP00
[2616] B062 81,00           DABS @SP00             Get absolute value
[2617] B064 86,05           CLR  @SP04+1           Clear byte before X
[2618] B066 A5,05,02        DSUB @SP02,@SP04+1     Difference in Y at SP04
[2619] B069 81,05           DABS @SP04+1           get the absolute value
[2620] B06B BC,05,06        ST   @SP06,@SP04+1     Put in the right place
[2621] B06E 00              RTN
[2622]               ***********************************************************
[2623]               * CHRSET restores the standard character set and the
[2624]               *  standard colors for the standard character set
[2625]               *  (black on transparent)
[2626]               ***********************************************************
[2627]               * CALL CHARSET                                            *
[2628]               * CALL CHARSET(ALL) * RXB ADDITION *                      *

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0046 
RXB 2022
[2629]               ***********************************************************
[2630]               * RXB PATCH CODE ADDTION OF CALL CHARSET(ALL) *************
[2631]               * CHRSET CALL CHKEND        Must be at EOS now
[2632]               *        BR  ERRSYN        Else its an error
[2633] B06F D6,42,B7 CHRSET CEQ  LPARZ,@CHAT  * (?
[2634] B072 70,8B           BS   CHRALL       * Yes, CHARSET(ALL)
[2635] B074 86,8F,DD        CLR  @>6004       * SET ROM 3 ON
       B077 04
[2636] B078 0F,7F           XML  CHRLDR       * LOAD ROM 3 Definitions 
[2637] B07A BE,A8,0F        ST   >10,V@>080F  * Set 1st black on transparent
       B07D 10
[2638] B07E 35,00,10        MOVE 16,V@>080F,V@>0810 * Ripple for rest
       B081 A8,10,A8
       B084 0F
[2639] B085 06,6A,78        CALL CHKEND        * Must be at EOS now
[2640] B088 06,00,12        CALL RETURN        * Return to the caller
[2641]               *******************************************************   
[2642] B08B 0F,79    CHRALL XML  PGMCHR        * Skip (
[2643] B08D D6,42,EC        CEQ  ALLZ,@CHAT    * ALL?
[2644] B090 4D,59           BR   ERRSYN        * No Syntax error
[2645] B092 0F,79           XML  PGMCHR        * Skip ALL token up to )
[2646] B094 86,8F,DD        CLR  @>6004        * SET ROM 3 ON
       B097 04
[2647] B098 0F,7F           XML   CHRLDR       * LOAD ROM 3 Definitions 
[2648] B09A 86,A7,00        CLR  V@>0700       * Clear byte
[2649] B09D 35,00,FF        MOVE 255,V@>0700,V@>0701 * Ripple the rest
       B0A0 A7,01,A7
       B0A3 00
[2650] B0A4 BE,A8,0F        ST   >10,V@>080F * Set 1st Black on Transparent
       B0A7 10
[2651] B0A8 35,00,10        MOVE 16,V@>080F,V@>0810 * Ripple the rest
       B0AB A8,10,A8
       B0AE 0F
[2652] B0AF 4A,BA           BR   LNKRTN        * RETURN
[2653]               *************************************
[2654]               * OLD SPNUM1 REPLACED WITH COMB NOW *
[2655]               *************************************
[2656]               * SPNUM2 ROUTINE             *
[2657]               ******************************
[2658] B0B1 0F,79    SPNUM2 XML  PGMCHR            Get the next character
[2659] B0B3 D6,42,FD SPNUM6 CEQ  NUMBEZ,@CHAT      Must be "#"
[2660] B0B6 4D,59           BR   ERRSYN
[2661] B0B8 0F,79    SPNUM3 XML  PGMCHR            Get next character
[2662] B0BA 06,B1,4A        CALL COMMA1            Parse up to comma and skip it
[2663] B0BD 0F,7E    SPNUM4 XML  SPEED
[2664] B0BF 02              BYTE RANGE           * Verify the value is in range
[2665] B0C0 01              BYTE 1               * Sprite number 1 - 28
[2666] B0C1 00,1C           DATA 28
[2667]               *----------------------------------------------------------
[2668]               * Insert a line here in sprite handling code for speeeding
[2669]               *  up XB    5/22/81
[2670]               * RXB PATCH LABEL ************
[2671] B0C3 BC,A3,AA SPNUM5 ST   @FAC1,V@SPNUM     Keep sprite number
       B0C6 4B
[2672]               *----------------------------------------------------------
[2673] B0C7 92,4B           DEC  @FAC1             Adjust for internal use
[2674] B0C9 E3,4A,00        DSLL 2,@FAC            Get location of SAL
       B0CC 02
[2675] B0CD A3,4A,03        DADD SPRSAL,@FAC       Sprite # * 4 + >0300
       B0D0 00
[2676] B0D1 BD,08,4A        DST  @FAC,@SPSAL * Save SPRITE ALOCATION location
[2677] B0D4 00              RTN
[2678]               ******************************
[2679]               * SPLOC ROUTINE              *

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0047 
RXB 2022
[2680]               ******************************
[2681] B0D5 06,B1,4A SPLOC  CALL COMMA1            Parse up to comma and skip it
[2682] B0D8 0F,7E    SPLOC2 XML  SPEED
[2683] B0DA 02              BYTE RANGE           * Range of Y: 1 - 256
[2684] B0DB 01              BYTE 1
[2685] B0DC 01,00           DATA 256
[2686] B0DE 96,4B           DECT @FAC1             Adjust for internal use: FF -
[2687] B0E0 BD,04,4A        DST  @FAC,@SP04        Store in SP04 area
[2688] B0E3 0F,74           XML  PARSE
[2689] B0E5 B6              BYTE RPARZ           * Parse to ")" or less
[2690] B0E6 0F,7E           XML  SPEED
[2691] B0E8 02              BYTE RANGE           * Get X value. Range: 1 - 256
[2692] B0E9 01              BYTE 1
[2693] B0EA 01,00           DATA 256
[2694] B0EC 92,4B           DEC  @FAC1             Adjust for internal use: 0 -
[2695] B0EE BC,06,4B        ST   @FAC1,@SP06       SP04+1=Y-loc and SP06=X-loc
[2696] B0F1 00              RTN
[2697]               ******************************
[2698]               * SPCHR ROUTINE              *
[2699]               ******************************
[2700] B0F2 0F,74    SPCHR  XML  PARSE
[2701] B0F4 B6              BYTE RPARZ
[2702] B0F5 0F,7E           XML  SPEED
[2703] B0F7 02              BYTE RANGE           * Check upper range
[2704]               * RXB PATCH CODE
[2705]               *      BYTE 32              * Character value 32 - 144
[2706]               *      DATA 143
[2707] B0F8 1E              BYTE 30
[2708] B0F9 00,9F           DATA 159
[2709] B0FB A2,4B,60        ADD  >60,@FAC1         Add offset to character numbe
[2710] B0FE BC,E0,02        ST   @FAC1,V@2(@SPSAL) Store the character value
       B101 08,4B
[2711] B103 00              RTN
[2712]               ******************************
[2713]               * SPMOVE ROUTINE             *
[2714]               ******************************
[2715] B104 06,B1,4A SPMOVE CALL COMMA1            Parse up to comma and skip
[2716] B107 06,B1,26        CALL RANGEV            Check if numeric and convert
[2717]               *                              to integer
[2718] B10A BC,0A,4B        ST   @FAC1,@SPTMP      Store Y velocity
[2719] B10D 0F,74           XML  PARSE             Get X velocity
[2720] B10F B6              BYTE RPARZ           * Check for ")" or less
[2721] B110 06,B1,26        CALL RANGEV            Numeric check and convert
[2722]               *                              to integer
[2723] B113 BC,4A,0A       ST   @SPTMP,@FAC     * @FAC=Y velocity, @FAC1=X veloc
[2724] B116 BD,E4,80       DST  @FAC,V@>0480(@SPSAL)  Store velocities in SAL
       B119 08,4A
[2725]               *----------------------------------------------------------
[2726]               * Add the following 3 lines for speeding up XB
[2727] B11B C4,A3,AA        CH   @NOMSPR,V@SPNUM   Check current sprite
       B11E 7A
[2728] B11F 51,25           BR   SPMOVF              against sprite motion
[2729]               *                                counter
[2730] B121 BC,7A,A3        ST   V@SPNUM,@NOMSPR       higher? Yes, replace it
       B124 AA
[2731]               *----------------------------------------------------------
[2732] B125 00       SPMOVF RTN
[2733]               * 
[2734] B126 C6,4C,63 RANGEV CH   >63,@FAC2         The same as INTARG
[2735] B129 6D,5D           BS   ERRSNM
[2736] B12B 86,54           CLR  @FAC10            For CFI
[2737] B12D 87,6C           DCLR @FPERAD
[2738] B12F 0F,12           XML  CFI
[2739] B131 8E,54           CZ   @FAC10

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0048 
RXB 2022
[2740] B133 4D,8D           BR   ERRBV
[2741] B135 D3,4A,00        DCGE 0,@FAC            If positive number,
       B138 00
[2742] B139 51,43           BR   GB0DB
[2743] B13B C7,4A,00        DCH  >007F,@FAC         should be 0 - 127
       B13E 7F
[2744] B13F 6D,8D           BS   ERRBV
[2745] B141 51,49           BR   GB0E1             If negative number,
[2746] B143 CB,4A,FF GB0DB  DCHE >FF80,@FAC         Should be -1 to -128
       B146 80
[2747] B147 4D,8D           BR   ERRBV
[2748] B149 00       GB0E1  RTN                    Otherwise its ok.
[2749]               ******************************
[2750]               * COMMA ROUTINE              *
[2751]               ******************************
[2752] B14A 0F,74    COMMA1 XML  PARSE             Fetch value
[2753] B14C B3              BYTE COMMAZ
[2754] B14D D6,42,B3 COMMA2 CEQ  COMMAZ,@CHAT
[2755] B150 4D,59           BR   ERRSYN
[2756] B152 0F,79           XML  PGMCHR            Skip COMMA
[2757] B154 00              RTN
[2758]               ******************************
[2759]               * LINK BACK TO XB            *
[2760]               ******************************
[2761] B155 06,B1,63 NULRTN CALL PREPN
[2762] B158 0F,7C    ASSRTN XML  ASSGNV
[2763] B15A 05,AA,BA        B    LNKRTN
[2764]               *******************************
[2765]               * LINK RETURN TO GPL          *
[2766]               *******************************
[2767] B15D 06,B1,63 MYNR   CALL PREPN
[2768] B160 05,A3,0B        B    SNDASS
[2769]               *******************************
[2770]               * PREPARE FOR PASSING ARGUMENT*
[2771]               *******************************
[2772] B163 0F,7A    PREPN  XML  SYM               Pick up name & search table
[2773] B165 0F,7B           XML  SMB               Evaluate any subscripts
[2774] B167 C6,4C,63        CH   >63,@FAC2         If not numeric, error
[2775] B16A 6D,91           BS   ERRIAL
[2776] B16C 0F,77           XML  VPUSH             Save entry on stack
[2777] B16E 05,A3,1F        B    CLRFAC            Clear FAC for new value
[2778]               ***********************************************************
[2779]               * CALL SAY(....................)                          *
[2780]               *  Decode given parameter(s). Store all data first, then  *
[2781]               *   go speak it all at once.                              *
[2782]               ***********************************************************
[2783] B171 06,A9,21 SAY    CALL COMB              Must start with "("
[2784] B174 BD,4C,6E        DST  @VSPTR,@FAC2      Save current top of stack on
[2785] B177 0F,77           XML  VPUSH              the stack
[2786] B179 BF,0C,00        DST  255,@BYTES        255 bytes = 85 3 byte entires
       B17C FF
[2787] B17D 0F,71           XML  GETSTR            Get temp speech list string
[2788] B17F BF,4A,00        DST  >001C,@FAC        Indicate it is temp string (S
       B182 1C
[2789] B183 BF,4C,65        DST  >6500,@FAC2       Indicate it is string entry
       B186 00
[2790] B187 BD,4E,1C        DST  @SREF,@FAC4       Save pointer to temp string
[2791] B18A BD,50,0C        DST  @BYTES,@FAC6      Length is 255
[2792] B18D 0F,77           XML  VPUSH             Make it semi-permenant
[2793]               * Set up pointers into the speak list
[2794] B18F BD,00,4E        DST  @FAC4,@PTFBSL     Front points to begining
[2795] B192 BD,02,4E        DST  @FAC4,@PTLBSL     Last now points to beginning
[2796] B195 BD,04,00        DST  @PTFBSL,@PTEBSL
[2797] B198 A1,04,50        DADD @FAC6,@PTEBSL     End points to the end+1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0049 
RXB 2022
[2798] B19B 06,B5,B7        CALL SETRW             Set PHROM read/write address
[2799] B19E 06,B5,AC        CALL WAIT              Wait till no one is speaking
[2800] B1A1 06,B3,84 DIRSPK CALL GETPRM            Get next parameter
[2801] B1A4 72,18           BS   NEXT1             If non-null ASCII string
[2802] B1A6 BD,06,4E        DST  @FAC4,@PTFCIS     Set up pointer to first char
[2803] B1A9 BD,0A,50        DST  @FAC6,@PTLCIS     Set ptr-to-last-char-in-strin
[2804] B1AC A1,0A,06        DADD @PTFCIS,@PTLCIS    by adding length-of-string
[2805] B1AF 93,0A           DDEC @PTLCIS            and subtracting 1
[2806]               * Make a speech list
[2807] B1B1 06,B5,B7        CALL SETRW             Set speech read/write addrs
[2808] B1B4 BD,08,06        DST  @PTFCIS,@PTCCIS   Start at beginning of string
[2809] B1B7 86,4C           CLR  @TOTTIM           Clear total time delay
[2810] B1B9 06,B4,01        CALL GETTIM            Get first timing mark
[2811] B1BC 06,B3,F1        CALL TIMING            Get any subsequent marks
[2812]               * The total first time delay is in TOTTIM now
[2813] B1BF C5,08,0A GB158  DCH  @PTLCIS,@PTCCIS   While more string
[2814] B1C2 72,0E           BS   GB1A7
[2815] B1C4 06,B3,9A        CALL PHRASE            Get next phrase
[2816]               * If spell flag is 0, try to look the phrase up. If it
[2817]               * can not be found, then set the spell flag, and it will be
[2818]               * spelled out. If found, save on speak list.
[2819] B1C7 8E,4B           CZ   @SPLFLG           There is a phrase
[2820] B1C9 51,DA           BR   GB173
[2821] B1CB 06,B4,96        CALL LOOKUP            Try to look it up in the PHRO
[2822] B1CE 8F,4D           DCZ  @DATAAD           If not found then
[2823] B1D0 51,D7           BR   GB170
[2824] B1D2 BE,4B,01        ST   1,@SPLFLG         Set the spell flag
[2825] B1D5 51,DA           BR   GB173
[2826] B1D7 06,B5,9C GB170  CALL STDATA            Store data in list
[2827]               * If spell flag is 1, set time delay to >3C, and take the
[2828]               * phrase one character at a time (spell it). Look up each
[2829]               * character: if not found, use 'UHOH' data instead.
[2830]               * Regardless, store data on speak list.
[2831] B1DA D6,4B,01 GB173  CEQ  1,@SPLFLG         Need to spell it out?
[2832] B1DD 52,07           BR   GB1A0
[2833] B1DF BD,4F,10        DST  @PTLCIP,@PTLCIL   Est last char to spell out
[2834] B1E2 BE,4C,3C        ST   >3C,@TOTTIM       >3C used because sounds good
[2835]               *                      Take each single character
[2836]               * Skip over any embedded spaces encountered in a phrase
[2837] B1E5 D6,B0,0C GB17E  CEQ  SPACE,V*PTFCIP
       B1E8 20
[2838] B1E9 51,EF           BR   GB188
[2839] B1EB 91,0C           DINC @PTFCIP
[2840] B1ED 51,E5           BR   GB17E
[2841]               * Set first and last pointers to same one character
[2842] B1EF BD,10,0C GB188  DST  @PTFCIP,@PTLCIP
[2843] B1F2 06,B4,96        CALL LOOKUP            Try to look it up
[2844]               * If not found, use data to 'UHOH'
[2845] B1F5 8F,4D           DCZ  @DATAAD
[2846] B1F7 51,FD           BR   GB196
[2847] B1F9 BF,4D,71        DST  >71F4,@DATAAD     Put addr of 'UHOH' in
       B1FC F4
[2848] B1FD 06,B5,9C GB196  CALL STDATA            Store data on speak list
[2849] B200 91,0C           DINC @PTFCIP           Go on to next character
[2850] B202 C5,0C,4F        DCH  @PTLCIL,@PTFCIP   Until done all
[2851] B205 51,E5           BR   GB17E
[2852]               * At this point, get next timing group. The first timing
[2853]               * character has already been found, and it's value is still
[2854]               * in TIMLEN. Therefore, initiatory call to GETTIM not
[2855]               * needed. Simply clear TOTTIM and call TIMING.
[2856] B207 86,4C    GB1A0  CLR  @TOTTIM
[2857] B209 06,B3,F1        CALL TIMING
[2858] B20C 51,BF           BR   GB158
[2859]               * At this point, finished all the phrases in this string.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0050 
RXB 2022
[2860]               * TOTTIM should equal >FE, it indicate end of sting If it
[2861]               * doesn't equal >FE, it indicates that a timing group was
[2862]               * put on the end of the string. Therefore, save the timing
[2863]               * group with a null data address to show it is only timing.
[2864] B20E D6,4C,FE GB1A7  CEQ  >FE,@TOTTIM
[2865] B211 72,18           BS   NEXT1
[2866] B213 87,4D           DCLR @DATAAD
[2867] B215 06,B5,9C        CALL STDATA
[2868]               * Next item could be direct string.
[2869] B218 D6,42,B3 NEXT1  CEQ  COMMAZ,@CHAT      If direct string present
[2870] B21B 52,32           BR   SPEAK
[2871] B21D 06,B3,84        CALL GETPRM            Get the next parameter
[2872] B220 72,2D           BS   NEXT2             If non-null direct string
[2873] B222 BE,4C,FF        ST   >FF,@TOTTIM       Mark TOTTIM as direct string
[2874] B225 0F,77           XML  VPUSH             Save direct string on stack
[2875] B227 BD,4D,6E        DST  @VSPTR,@DATAAD    Store stack addr on string
[2876] B22A 06,B5,9C        CALL STDATA            And add to the speak list
[2877]               * If the next character is a comma, loop thru it again
[2878] B22D D6,42,B3 NEXT2  CEQ  COMMAZ,@CHAT
[2879] B230 71,A1           BS   DIRSPK
[2880]               * If end fall into SPEAK
[2881]               ***********************************************************
[2882]               * SPEAK will actually speak the speech list. It tests the
[2883]               * timing byte to see if it is an >FF. If it is, then the
[2884]               * data following it points to a direct speech data string
[2885]               * in VDP. If it is not, then the data following it points
[2886]               * to a PHROM speech data list. In the first case, this
[2887]               * routine will issue a speak external command to the PHROM
[2888]               * and then feed bytes out to the PHROM as it requests them.
[2889]               * In the second case, the address will be loaded out to the
[2890]               * PHROM, and then a speak command will be issued.
[2891]               ***********************************************************
[2892] B232 06,B5,B7 SPEAK  CALL SETRW             Set read/write address
[2893] B235 C9,00,02 GB1CE  DCHE @PTLBSL,@PTFBSL   More speech list to go
[2894] B238 72,BF           BS   GB258
[2895] B23A 06,B5,AC        CALL WAIT              Yes, wait until previous
[2896]               *                              speech is though
[2897] B23D D6,B0,00        CEQ  >FF,V*PTFBSL      External speech data
       B240 FF
[2898] B241 72,65           BS   GB1FE
[2899] B243 BC,79,B0        ST   V*PTFBSL,@TIMER   No, load timer
       B246 00
[2900] B247 82,79           NEG  @TIMER             and neg it to correct
[2901] B249 BD,12,E0        DST  V@1(@PTFBSL),@PTFBPH   Put addr into PTFBPH
       B24C 01,00
[2902] B24E A3,00,00        DADD 3,@PTFBSL               and skip to next node
       B251 03
[2903] B252 D2,79,00 LOOP1  CGE  0,@TIMER          Wait for time delay
[2904] B255 52,52           BR   LOOP1
[2905] B257 8E,12           CZ   @PTFBPH           If there is data
[2906] B259 72,63           BS   GB1FC
[2907] B25B 06,B5,52        CALL LOADAD            Load the addr to PHROM
[2908] B25E BE,C0,00        ST   >50,@PAD(@WRITE)   and issue speak command
       B261 5A,50
[2909] B263 52,BC    GB1FC  BR   CONTIN
[2910] B265 91,00    GB1FE  DINC @PTFBSL           Speak external, skip over >FF
[2911] B267 BD,5E,B0        DST  V*PTFBSL,@PTCBED  Set up pointer to 1st byte
       B26A 00
[2912] B26B BD,5E,E0        DST  V@4(@PTCBED),@PTCBED    in external speech data
       B26E 04,5E
[2913] B270 95,00           DINCT @PTFBSL          Skip addr bytes
[2914] B272 BC,62,EF        ST   V@-1(@PTCBED),@LENWST  Get Len of whole string
       B275 FF,FF,5E
[2915] B278 A6,62,03 DIRSPH SUB  3,@LENWST         Minus 3 bytes overhead

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0051 
RXB 2022
[2916]               * All external speech strings start with a >60
[2917] B27B D6,B0,5E        CEQ  >60,V*PTCBED      Bad speech string
       B27E 60
[2918] B27F 4D,8D           BR   ERRBV
[2919] B281 06,B5,AC        CALL WAIT              Wait for go ahead
[2920] B284 95,5E           DINCT @PTCBED          Skip spk ext & 1st byte len
[2921] B286 BC,60,B0        ST   V*PTCBED,@LENCST  Get len of current string
       B289 5E
[2922] B28A 91,5E           DINC @PTCBED           Skip len byte to 1st real byt
[2923] B28C BE,56,10        ST   16,@TEMP2         Do 1st 16 bytes (fill buff)
[2924] B28F BE,C0,00        ST   >60,@PAD(@WRITE)  Start Speak External
       B292 5A,60
[2925] B294 BC,C0,00 LOOPR  ST   V*PTCBED,@PAD(@WRITE) Write byte to PHROM
       B297 5A,B0,5E
[2926] B29A 91,5E           DINC @PTCBED           Go to next byte
[2927] B29C 92,62           DEC  @LENWST           1 less char in whole string
[2928] B29E 72,BC           BS   CONTIN            Finished whole string?
[2929] B2A0 92,60           DEC  @LENCST           1 less char in curr string
[2930] B2A2 72,78           BS   DIRSPH            Finished current string?
[2931] B2A4 92,56           DEC  @TEMP2            1 less char in this loop
[2932] B2A6 52,94           BR   LOOPR             Not finished curr loop yet?
[2933] B2A8 BC,69,C0 GB241  ST   @PAD(@READ),@SPKSTS Read status from PHROM
       B2AB 00,58
[2934]                
[2935]               * If the next statement is true, it means that speak was
[2936]               * probably interupted and that it is shot at this point.
[2937]               * Therefore, we are going to quit now.
[2938] B2AD DA,69,80        CLOG >80,@SPKSTS
[2939] B2B0 72,BC           BS   CONTIN
[2940] B2B2 DA,69,40        CLOG >40,@SPKSTS       Loop till buff below half
[2941] B2B5 72,A8           BS   GB241
[2942] B2B7 BE,56,08        ST   8,@TEMP2          Put 8 more bytes to PHROM
[2943] B2BA 52,94           BR   LOOPR              and go do these
[2944] B2BC 05,B2,35 CONTIN B    GB1CE             We've said it all!!
[2945]               * Now pop all entries off stack that we put on!
[2946] B2BF 0F,78    GB258  XML  VPOP              Free up a temporary string
[2947] B2C1 D5,6E,4C        DCEQ @FAC2,@VSPTR
[2948] B2C4 52,BF           BR   GB258
[2949] B2C6 4A,BA           BR   LNKRTN       
[2950]               ***********************************************************
[2951]               * SPGET subprogram. Load speech data from external device.
[2952]               *       Use standard file I/O
[2953]               ***********************************************************
[2954]               * CALL SAY(word-string,return-string)                     *
[2955]               ***********************************************************
[2956] B2C8 06,A9,21 SPGET  CALL COMB             Must have left parenthesis
[2957] B2CB 06,B5,B7        CALL SETRW             Set PHROM read/write address
[2958] B2CE 06,B5,AC        CALL WAIT              Wait till no one is speaking
[2959] B2D1 06,B3,84 NXTPAR CALL GETPRM            Get the next parameter
[2960] B2D4 8F,50           DCZ  @FAC6             If non-null ASCII string
[2961] B2D6 73,7D           BS   GB318
[2962] B2D8 BD,06,4E        DST  @FAC4,@PTFCIS     Pointer to 1st char in string
[2963] B2DB BD,0A,50        DST  @FAC6,@PTLCIS     Pointer to last-char-in-strin
[2964] B2DE A1,0A,06        DADD @PTFCIS,@PTLCIS    by adding length-of-string
[2965] B2E1 93,0A           DDEC @PTLCIS             and subtracting 1
[2966] B2E3 06,B5,B7        CALL SETRW             Set the speech read/write add
[2967] B2E6 BD,08,06        DST  @PTFCIS,@PTCCIS   Set curr char to first char
[2968] B2E9 86,4C           CLR  @TOTTIM           Clear total time delay
[2969] B2EB 06,B4,01        CALL GETTIM            Get first timing mark
[2970] B2EE 06,B3,F1        CALL TIMING            Get any subsquent marks
[2971]               * Get one phrase, and look it up. If the phrase is not foun
[2972]               * substitute in 'UHOH'.
[2973] B2F1 C5,08,0A        DCH  @PTLCIS,@PTCCIS   Possible phrase
[2974] B2F4 73,7D           BS   GB318

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0052 
RXB 2022
[2975] B2F6 06,B3,9A        CALL PHRASE            Yes, go get it
[2976] B2F9 D6,4B,01        CEQ  1,@SPLFLG         Spell flag set then set
[2977] B2FC 53,01           BR   GB29C
[2978] B2FE BD,10,0C        DST  @PTFCIP,@PTLCIP    last ptr to first (1 char)
[2979] B301 06,B4,96 GB29C  CALL LOOKUP            Look up the phrase
[2980] B304 8F,4D           DCZ  @DATAAD           If not there,
[2981] B306 53,0F           BR   GB2AA
[2982] B308 BF,4D,71        DST  >71F4,@DATAAD      use 'UHOH' data addr
       B30B F4
[2983] B30C BE,64,51        ST   >51,@STRLEN        'UHOH' data length
[2984]               * Data must be in PHRADD and PHLEN, so move it
[2985] B30F BD,01,4D GB2AA  DST  @DATAAD,@PHRADD
[2986] B312 BC,00,64        ST   @STRLEN,@PHLEN
[2987] B315 A2,00,03        ADD  3,@PHLEN          For overhead info
[2988]               * There must be a variable to put this data in. If not, err
[2989] B318 0F,7E           XML  SPEED
[2990] B31A 00              BYTE SYNCHK
[2991] B31B B3              BYTE COMMAZ
[2992] B31C 0F,7A           XML  SYM               Find symbol in table
[2993] B31E 0F,7B           XML  SMB               Evaluate andy subscripts
[2994] B320 0F,77           XML  VPUSH             Save for assignment
[2995] B322 86,0C           CLR  @BYTES            Two byte value
[2996] B324 BC,0D,00        ST   @PHLEN,@BYTES+1   Length of string needed
[2997] B327 0F,71           XML  GETSTR            Get a string for the data
[2998] B329 06,B5,B7        CALL SETRW             Set up speech read/write addr
[2999] B32C BF,4A,00        DST  >001C,@FAC        Now build string FAC entry
       B32F 1C
[3000] B330 BF,4C,65        DST  >6500,@FAC2       String ID
       B333 00
[3001] B334 BD,4E,1C        DST  @SREF,@FAC4       Pointer to string
[3002] B337 BD,50,0C        DST  @BYTES,@FAC6      Length of string
[3003] B33A BF,B0,1C        DST  >6000,V*SREF      Mark string as speech data
       B33D 60,00
[3004] B33F BC,E0,02        ST   @PHLEN,V@2(@SREF) Put in string length
       B342 1C,00
[3005] B344 A7,E0,01        DSUB 3,V@1(@SREF)       minus thei info
       B347 1C,00,03
[3006]               * LOADAD expects addr to be in PTFBPH, so move it.
[3007] B34A BD,12,01        DST  @PHRADD,@PTFBPH
[3008] B34D 06,B5,52        CALL LOADAD
[3009]               * Going to copy string from PHROM to VDP. The actual data
[3010]               * from PHROM is in bit-reversed order, so must reverse the
[3011]               * order after reading in the order. Remember that 3 bytes
[3012]               * PHLEN are our own overhead, so don't copy all
[3013] B350 C6,00,03 GB2EB  CH   3,@PHLEN
[3014] B353 53,7B           BR   GB316
[3015] B355 BE,C0,00        ST   >10,@PAD(@WRITE)   Issue read byte command
       B358 5A,10
[3016] B35A BC,68,C0        ST   @PAD(@READ),@BYTE3 Read the byte
       B35D 00,58
[3017]               * the following code is somewhat tricky. It will bit
[3018]               * reverse the contents of BYTE3 into BYTE1 through
[3019]               * BYTE2 by means of word shifts. Note the definition of
[3020]               * BYTE1 , BYTE2, and BYTE3 in EQU's. You might try an
[3021]               * example if it isn't clear what is going on.
[3022] B35F 86,67           CLR  @BYTE2
[3023] B361 BE,54,08        ST   >08,@TEMP1
[3024] B364 EB,67,00 RNDAG  DSRC 1,@BYTE2
       B367 01
[3025] B368 E3,66,00        DSLL 1,@BYTE1
       B36B 01
[3026] B36C 92,54           DEC  @TEMP1
[3027] B36E 53,64           BR   RNDAG
[3028]               * Store the bit-corrected byte into the string & inc str pt

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0053 
RXB 2022
[3029] B370 BC,E0,03        ST   @BYTE1,V@3(@SREF)
       B373 1C,66
[3030] B375 91,1C           DINC @SREF
[3031] B377 92,00           DEC  @PHLEN            Dec the string length
[3032] B379 53,50           BR   GB2EB             Go do next char if there is o
[3033] B37B 0F,7C    GB316  XML  ASSGNV            Assign the string to variable
[3034] B37D D6,42,B3 GB318  CEQ  COMMAZ,@CHAT      If more go do
[3035] B380 72,D1           BS   NXTPAR
[3036] B382 4A,BA           BR   LNKRTN
[3037]               ***********************************************************
[3038]               * GETPAM gets the next string paameter passed to the
[3039]               * routine. If that parameter is non-exist or null, then
[3040]               * condition bit is set. If the parameter is there then
[3041]               * condition bit is reset and the FAC entry describes the
[3042]               * string. In either case, return with condition is done.
[3043]               ***********************************************************
[3044] B384 0F,79    GETPRM XML  PGMCHR            Get next token
[3045] B386 D6,42,B3        CEQ  COMMAZ,@CHAT      Go set condition no parm
[3046] B389 73,96           BS   SETCB
[3047] B38B 0F,74           XML  PARSE
[3048] B38D B6              BYTE RPARZ
[3049] B38E D6,4C,65        CEQ  >65,@FAC2         If not string, error
[3050] B391 4D,5D           BR   ERRSNM
[3051] B393 8F,50           DCZ  @FAC6             Set cond if null string
[3052] B395 01              RTNC                   Else return
[3053] B396 D4,00,00 SETCB  CEQ  @PAD,@PAD         Set condition bit
[3054] B399 01              RTNC
[3055]               ***********************************************************
[3056]               * Get the next phrase out of the current string. The phrase
[3057]               * may begin with a #, which means it will continue to the
[3058]               * next #, or it many begin with an ordinary character, in
[3059]               * which case it will end with the character just before the
[3060]               * first timing character encountered. In either case, the
[3061]               * end of the string will indicate a legal end of phrase if
[3062]               * it occurs before the usual indicator!
[3063]               ***********************************************************
[3064] B39A D6,4A,23 PHRASE CEQ  NUMBER,@CCHAR     Phrase start with #?
[3065] B39D 53,D5           BR   GB370
[3066] B39F 91,08           DINC @PTCCIS           Yes, inc CC ptr past #
[3067] B3A1 D6,B0,08 GB33C  CEQ  SPACE,V*PTCCIS    Skip spaces
       B3A4 20
[3068] B3A5 53,AB           BR   GB346
[3069] B3A7 91,08           DINC @PTCCIS
[3070] B3A9 53,A1           BR   GB33C
[3071] B3AB D6,B0,08 GB346  CEQ  NUMBER,V*PTCCIS   All spaces?
       B3AE 23
[3072] B3AF 53,B4           BR   GB34F
[3073] B3B1 91,08           DINC @PTCCIS           Yes, skip this # too
[3074] B3B3 00              RTN                    And ignore this phrase
[3075] B3B4 BD,0C,08 GB34F  DST  @PTCCIS,@PTFCIP   Save 1st char in phrase
[3076] B3B7 91,08    GB352  DINC @PTCCIS           Go on to next char
[3077]               * Got to watch for end of string. If encountered before a
[3078]               * #, act like char after string is #. Then last char will
[3079]               * be char before, or the last char in the string!!
[3080] B3B9 C5,08,0A        DCH  @PTLCIS,@PTCCIS
[3081] B3BC 73,C7           BS   FNDNUM
[3082] B3BE BC,4A,B0        ST   V*PTCCIS,@CCHAR   No, get char in CCHAR
       B3C1 08
[3083] B3C2 D6,4A,23        CEQ  NUMBER,@CCHAR     If not # continue looking
[3084] B3C5 53,B7           BR   GB352
[3085] B3C7 BD,10,08 FNDNUM DST  @PTCCIS,@PTLCIP   Last char in phrase is one
[3086] B3CA 93,10           DDEC @PTLCIP            before the #
[3087] B3CC 91,08           DINC @PTCCIS           Point to char after #
[3088] B3CE 06,B4,01        CALL GETTIM            Get 1st timing char after phr

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0054 
RXB 2022
[3089] B3D1 86,4B           CLR  @SPLFLG           Indicate don't spell
[3090] B3D3 53,F0           BR   GB38B             No # as 1st char in phrase
[3091] B3D5 BD,0C,08 GB370  DST  @PTCCIS,@PTFCIP   Curr char is 1st char phrase
[3092] B3D8 86,4B           CLR  @SPLFLG           Assume don't spell
[3093] B3DA CA,4A,41        CHE  >41,@CCHAR        If not alphabetic   (>41="A")
[3094] B3DD 73,E1           BS   GB37C
[3095] B3DF 90,4B           INC  @SPLFLG            set spell flag
[3096]               * Need to find end of phrase, which is char before next
[3097]               * timing char we find. Therefore, look for a timing char!
[3098] B3E1 91,08    GB37C  DINC @PTCCIS
[3099] B3E3 06,B4,01        CALL GETTIM
[3100] B3E6 D6,51,FF        CEQ  >FF,@TIMLEN       If not timing, loop
[3101] B3E9 73,E1           BS   GB37C
[3102] B3EB BD,10,08        DST  @PTCCIS,@PTLCIP   Char before curr char is
[3103] B3EE 93,10           DDEC @PTLCIP            the last char in phrase
[3104] B3F0 00       GB38B  RTN
[3105]               ***********************************************************
[3106]               * TIMING will loop through chars in string until it finds
[3107]               * non-timing char. Non-timing chars have TIMLEN values of
[3108]               * >FE or >FF. GETTIM must be called before this routine to
[3109]               * establish a correct value of TIMLEN. Also, most likely
[3110]               * TOTTIM should have been cleared.
[3111]               ***********************************************************
[3112] B3F1 CA,51,FE TIMING CHE  >FE,@TIMLEN
[3113] B3F4 74,00           BS   GB39B
[3114] B3F6 A1,4C,51        DADD @TIMLEN,@TOTTIM
[3115] B3F9 91,08           DINC @PTCCIS
[3116] B3FB 06,B4,01        CALL GETTIM
[3117] B3FE 53,F1           BR   TIMING
[3118] B400 00       GB39B  RTN
[3119]               ***********************************************************
[3120]               * GETTIM will examine the current char in the string and
[3121]               * set TIMLEN to the appropriate time delay value. TIMLEN
[3122]               * can take on the following values:
[3123]               *           >00 if char is timing '+'
[3124]               *           >06 if char is timing ' '
[3125]               *           >0C if char is timing '-'
[3126]               *           >12 if char is timing ','
[3127]               *           >1E if char is timing ';'
[3128]               *           >30 if char is timing ':'
[3129]               *           >3C if char is timing '.'
[3130]               *           >FE if char is out of stirng bounds
[3131]               *           >FF if char is not timing
[3132]               * Note that to test timing, some manipulation of PTCCIS
[3133]               * would be neccesary, so it is stored and used in TEMP1
[3134]               ***********************************************************
[3135] B401 BC,4A,B0 GETTIM ST   V*PTCCIS,@CCHAR   Get the char
       B404 08
[3136] B405 BD,54,08        DST  @PTCCIS,@TEMP1     store curr ptr in TEMP1
[3137] B408 C5,54,0A        DCH  @PTLCIS,@TEMP1     out of string bounds?
[3138] B40B 54,11           BR   GB3AC
[3139] B40D BE,51,FE        ST   >FE,@TIMLEN       Yes, load value and return
[3140] B410 00              RTN
[3141] B411 C6,4A,3B GB3AC  CH   SEMICO,@CCHAR     Can not be timing
[3142] B414 74,7B           BS   NOTIME
[3143] B416 D6,4A,20        CEQ  SPACE,@CCHAR
[3144] B419 54,2A           BR   GB3C5
[3145] B41B BE,51,06        ST   6,@TIMLEN
[3146] B41E D6,E0,01 GB3B9  CEQ  SPACE,V@1(@PTCCIS) While spaces
       B421 08,20
[3147] B423 54,29           BR   GB3C4
[3148] B425 91,08           DINC @PTCCIS           Skip them
[3149] B427 54,1E           BR   GB3B9
[3150] B429 00       GB3C4  RTN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0055 
RXB 2022
[3151] B42A D6,4A,2B GB3C5  CEQ  PLUS,@CCHAR
[3152] B42D 54,39           BR   GB3D4
[3153] B42F 91,54           DINC @TEMP1            Need to test the next char
[3154] B431 06,B4,7F        CALL NUMERC            Is it numeric
[3155] B434 74,7B           BS   NOTIME            Was numeric => not timing cha
[3156] B436 86,51           CLR  @TIMLEN           Not numeric => set as no timi
[3157] B438 00              RTN
[3158] B439 D6,4A,2C GB3D4  CEQ  COMMAT,@CCHAR
[3159] B43C 54,42           BR   GB3DD
[3160] B43E BE,51,12        ST   >12,@TIMLEN
[3161] B441 00              RTN
[3162] B442 D6,4A,2E GB3DD  CEQ  PERIOD,@CCHAR
[3163] B445 54,59           BR   GB3F4
[3164] B447 93,54           DDEC @TEMP1            Go back to preceding char
[3165] B449 06,B4,7F        CALL NUMERC            Is it numeric?
[3166] B44C 54,55           BR   PTIME             No, so it is timing
[3167] B44E 95,54           DINCT @TEMP1           Yes, on to following char
[3168] B450 06,B4,7F        CALL NUMERC            Is it numeric too?
[3169] B453 74,7B           BS   NOTIME            Yes, both numeric => not timi
[3170] B455 BE,51,3C PTIME  ST   >3C,@TIMLEN       Both not numeric  => timing
[3171] B458 00              RTN
[3172] B459 D6,4A,2D GB3F4  CEQ  HYPEN,@CCHAR
[3173] B45C 54,69           BR   GB404
[3174] B45E 91,54           DINC @TEMP1            Check next char
[3175] B460 06,B4,7F        CALL NUMERC            Is it numeric?
[3176] B463 74,7B           BS   NOTIME            Was numeric => not a timing c
[3177] B465 BE,51,0C        ST   >0C,@TIMLEN       Was not numeric => set as tim
[3178] B468 00              RTN
[3179] B469 D6,4A,3A GB404  CEQ  COLON,@CCHAR
[3180] B46C 54,72           BR   GB40D
[3181] B46E BE,51,30        ST   >30,@TIMLEN
[3182] B471 00              RTN
[3183] B472 D6,4A,3B GB40D  CEQ  SEMICO,@CCHAR
[3184] B475 54,7B           BR   NOTIME
[3185] B477 BE,51,1E        ST   >1E,@TIMLEN
[3186] B47A 00              RTN
[3187] B47B BE,51,FF NOTIME ST   >FF,@TIMLEN       Set as no timing char present
[3188] B47E 00              RTN
[3189]               ***********************************************************
[3190]               * NUMERC tests the char pointed to by PTCCIS and verifies
[3191]               * the following:
[3192]               *  1 - it is within the current string boundaries
[3193]               *  2 - it is numeric (i.e. between '0' and '9')
[3194]               * If both of the above conditions are true, COND is set
[3195]               * upon return, otherwise COND is reset
[3196]               ***********************************************************
[3197] B47F C5,54,0A NUMERC DCH  @PTLCIS,@TEMP1
[3198] B482 74,95           BS   GB430
[3199] B484 C5,06,54        DCH  @TEMP1,@PTFCIS
[3200] B487 74,95           BS   GB430
[3201] B489 CA,B0,54        CHE  >30,V*TEMP1
       B48C 30
[3202] B48D 54,95           BR   GB430
[3203] B48F C6,B0,54        CH   >39,V*TEMP1
       B492 39
[3204] B493 53,96           BR   SETCB
[3205] B495 01       GB430  RTNC
[3206]               ***********************************************************
[3207]               * LOOKUP is a prolong routine to SEARCH. In each PHROM,
[3208]               * there may be 2 trees, one starting at >0000 and the other
[3209]               * at >8000. Either may or may not be present. Presences is
[3210]               * determined if a >AA byte is at the starting location.
[3211]               * LOOKUP determines if the tree at >0000 is in, and if so,
[3212]               * calls SEARCH with that addr. If that tree is not present

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0056 
RXB 2022
[3213]               * or the phrase couldn't be found in it, LOOKUP then checks
[3214]               * if the tree at >8000 is present, and again, if so, calls
[3215]               * SEARCH with that tree address. If the word was found in
[3216]               * the first tree, or after searching the second tree, the
[3217]               * routine will return.
[3218]               ***********************************************************
[3219] B496 87,66    LOOKUP DCLR @BYTE1            BYTE1 contains addr of curr t
[3220] B498 BD,12,66 TRYAGN DST  @BYTE1,@PTFBPH    Look for >AA tree header
[3221] B49B 06,B5,52        CALL LOADAD            LOADAD expects addr in PTFBPH
[3222] B49E BE,C0,00        ST   >10,@PAD(@WRITE)  Put out read byte command
       B4A1 5A,10
[3223] B4A3 D6,C0,00        CEQ  >AA,@PAD(@READ)   Tree out there?
       B4A6 58,AA
[3224] B4A8 54,B3           BR   GB44E
[3225] B4AA 91,12           DINC @PTFBPH           Skip the tree header
[3226] B4AC 06,B4,BE        CALL SEARCH            Go search this PHROM tree
[3227] B4AF 8F,4D           DCZ  @DATAAD           Phrase found => exit
[3228] B4B1 54,BD           BR   FOUND
[3229] B4B3 A3,66,80 GB44E  DADD >8000,@BYTE1      Go to start of next PHROM tre
       B4B6 00
[3230]               * Note >8000 + >8000 = >0000 => tried both trees
[3231] B4B7 8F,66           DCZ  @BYTE1
[3232] B4B9 54,98           BR   TRYAGN
[3233] B4BB 87,4D           DCLR @DATAAD           Didnt find phrase in either t
[3234] B4BD 00       FOUND  RTN
[3235]               ***********************************************************
[3236]               * SEARCH actually searches the PHROM tree for the phrase.
[3237]               * The PHROM tree organization is as follows:
[3238]               *        (i.e. this is one phrase node)
[3239]               *              phrase ASCII length      1 byte
[3240]               *              actual ASCII characters  n bytes
[3241]               *              less then pointer        2 bytes
[3242]               *              greater then pointer     2 bytes
[3243]               *              speech data pointer      3 bytes
[3244]               *              speech data length       1 byte
[3245]               * The comparison of two words proceeds on a char by char
[3246]               * basis, where length is secondary to char values, i.e.
[3247]               * move > answer; number < we; eight < eighty; etc...
[3248]               ***********************************************************
[3249] B4BE 06,B5,52 SEARCH CALL LOADAD            Set PHROM to start phrase nod
[3250] B4C1 BE,C0,00        ST   >10,@PAD(@WRITE)  Issue read byte command
       B4C4 5A,10
[3251] B4C6 86,16           CLR  @PTLCPH           Length of phrase => PTLCPH
[3252] B4C8 BC,17,C0        ST   @PAD(@READ),@PTLCPH+1 (stored as 2 byte value
       B4CB 00,58
[3253] B4CD A1,16,12        DADD @PTFBPH,@PTLCPH   Add front ptr giving end ptr
[3254] B4D0 BD,14,12        DST  @PTFBPH,@PTCCPH   Set up curr char as 1 beyond
[3255] B4D3 91,14           DINC @PTCCPH            length byte
[3256] B4D5 BD,0E,0C        DST  @PTFCIP,@PTCCIP   Reset current ptr into phrase
[3257]               * Compare two characters
[3258] B4D8 BE,C0,00 NEXT   ST   >10,@PAD(@WRITE)  Issue read byte command
       B4DB 5A,10
[3259] B4DD BC,5D,C0        ST   @PAD(@READ),@PHDATA Get char in from PHROM
       B4E0 00,58
[3260] B4E2 D4,5D,B0        CEQ  V*PTCCIP,@PHDATA  Compare the char
       B4E5 0E
[3261] B4E6 55,36           BR   GB4D1
[3262] B4E8 91,14           DINC @PTCCPH           Equal, advance both pointers
[3263] B4EA 91,0E           DINC @PTCCIP
[3264] B4EC D6,B0,0E        CEQ  SPACE,V*PTCCIP    Skip extra spaces
       B4EF 20
[3265] B4F0 55,06           BR   GB4A1
[3266] B4F2 D6,E0,01 GB48D  CEQ  SPACE,V@1(@PTCCIP) While spaces
       B4F5 0E,20

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0057 
RXB 2022
[3267] B4F7 54,FD           BR   GB498
[3268] B4F9 91,0E           DINC @PTCCIP           Skip them
[3269] B4FB 54,F2           BR   GB48D
[3270]               * By skipping extra spaces, might have reached end of phras
[3271]               * If this is true, next char in phrase = #. If so, advance
[3272]               * the pointer to be beyond end of phrase.
[3273] B4FD D6,E0,01 GB498  CEQ  NUMBER,V@1(@PTCCIP)
       B500 0E,23
[3274] B502 55,06           BR   GB4A1
[3275] B504 91,0E           DINC @PTCCIP
[3276] B506 C5,14,16 GB4A1  DCH  @PTLCPH,@PTCCPH   End of PHROM word?
[3277] B509 55,2B           BR   GB4C6
[3278] B50B C5,0E,10        DCH  @PTLCIP,@PTCCIP   Yes, end of phrase
[3279] B50E 55,25           BR   GB4C0
[3280] B510 BD,12,16        DST  @PTLCPH,@PTFBPH   Yes, word found
[3281]               * Skip 5 bytes down from last char to data pointer
[3282] B513 A3,12,00        DADD 6,@PTFBPH
       B516 06
[3283] B517 06,B5,84        CALL READAD            Set data addr => DATAAD
[3284] B51A BE,C0,00        ST   >10,@PAD(@WRITE)  Issue read byte command
       B51D 5A,10
[3285] B51F BC,64,C0        ST   @PAD(@READ),@STRLEN Get length of speech data
       B522 00,58
[3286] B524 00              RTN
[3287] B525 BF,12,00 GB4C0  DST  3,@PTFBPH         Move 3 bytes past PTLCPH
       B528 03
[3288] B529 55,42           BR   NXTPHR
[3289] B52B C5,0E,10 GB4C6  DCH  @PTLCIP,@PTCCIP   2 characters
[3290] B52E 54,D8           BR   NEXT
[3291] B530 BF,12,00        DST  1,@PTFBPH         Phrase linger: use LT ptr
       B533 01
[3292] B534 55,42           BR   NXTPHR
[3293]               * Two characters compared were not equal
[3294] B536 BF,12,00 GB4D1  DST  3,@PTFBPH         3 bytes past last to GT
       B539 03
[3295] B53A C4,5D,B0        CH   V*PTCCIP,@PHDATA  After phrase
       B53D 0E
[3296] B53E 55,42           BR   NXTPHR
[3297] B540 97,12           DDECT @PTFBPH          Back up 2 bytes to LT link
[3298]               * Go get next phrase out of the PHROM to compare
[3299] B542 A1,12,16 NXTPHR DADD @PTLCPH,@PTFBPH   Add displacement to last char
[3300] B545 06,B5,84        CALL READAD             and get the new address
[3301] B548 8F,4D           DCZ  @DATAAD           More leaves on this tree
[3302] B54A 55,4D           BR   GB4E8
[3303] B54C 00              RTN                    No, return empty handed
[3304] B54D BD,12,4D GB4E8  DST  @DATAAD,@PTFBPH   Store new addr in PTFBPH
[3305] B550 54,BE           BR   SEARCH            Go compare this new word!
[3306]               * The program should never reach this point!! It should
[3307]               * return somewhere up above.
[3308]               ***********************************************************
[3309]               * LOADAD will set the addr out in the PHROM to the addr
[3310]               * found in PTFBPH. Note that the PHROM is expecting five
[3311]               * nybbles to be written out as the address.
[3312]               ***********************************************************
[3313] B552 BD,54,12 LOADAD DST  @PTFBPH,@TEMP1    This is destructive, so copy
[3314] B555 BD,56,12        DST  @PTFBPH,@TEMP2     address into temporary areas
[3315] B558 E6,54,04        SRL  4,@TEMP1          Isolate the MSN of the MSB
[3316] B55B E6,55,04        SRL  4,@TEMP1+1        Isolate the MSN of the LSB
[3317] B55E B3,56,0F        DAND >0F0F,@TEMP2      Isolate the LSN of the MSB, L
       B561 0F
[3318] B562 B7,54,40        DOR  >4040,@TEMP1      Include a 4 as MSN of all 4 n
       B565 40
[3319] B566 B7,56,40        DOR  >4040,@TEMP2       to indicate a Load Address C
       B569 40

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0058 
RXB 2022
[3320] B56A BC,C0,00        ST   @TEMP2+1,@PAD(@WRITE) Write out the LSN of th
       B56D 5A,57
[3321] B56F BC,C0,00        ST   @TEMP1+1,@PAD(@WRITE) Write out the LSN of th
       B572 5A,55
[3322] B574 BC,C0,00        ST   @TEMP2,@PAD(@WRITE)   Write out the MSN of th
       B577 5A,56
[3323] B579 BC,C0,00        ST   @TEMP1,@PAD(@WRITE)   Write out the MSN of th
       B57C 5A,54
[3324] B57E BE,C0,00        ST   >40,@PAD(@WRITE)      Write out 0 as fifth ny
       B581 5A,40
[3325] B583 00              RTN
[3326]               ***********************************************************
[3327]               * READAD will read an address from the PHROM and store it
[3328]               * in DATAAD. Note that PTFBPH should contain the addr of
[3329]               * the PHROM location to be read so LOADAD will work.
[3330]               ***********************************************************
[3331] B584 06,B5,52 READAD CALL LOADAD            Set the addr of the PHROM
[3332] B587 BE,C0,00        ST   >10,@PAD(@WRITE)  Get high byte of addr
       B58A 5A,10
[3333] B58C BC,4D,C0        ST   @PAD(@READ),@DATAAD Store it in DATAAD
       B58F 00,58
[3334] B591 BE,C0,00        ST   >10,@PAD(@WRITE)  Get low byte of addr
       B594 5A,10
[3335] B596 BC,4E,C0        ST   @PAD(@READ),@DATAAD+1 Store it in DATAAD+1
       B599 00,58
[3336] B59B 00              RTN
[3337]               ***********************************************************
[3338]               * STDATA will store the data in DATAAD and TOTTIM onto the
[3339]               * speech list. It will also check that there is room on the
[3340]               * speech list for this entry, and abort with error if not.
[3341]               ***********************************************************
[3342] B59C D5,02,04 STDATA DCEQ @PTEBSL,@PTLBSL   Is there room?
[3343] B59F 75,BE           BS   ERRSSL
[3344] B5A1 35,00,03        MOVE 3,@TOTTIM,V*PTLBSL   Put data in list
       B5A4 B0,02,4C
[3345] B5A7 A3,02,00        DADD 3,@PTLBSL              and inc top of list
       B5AA 03
[3346] B5AB 00              RTN
[3347]               ***********************************************************
[3348]               * WAIT loops until the speech peripheral goes idle.
[3349]               ***********************************************************
[3350]               *    ( Loop until nobody is talking)
[3351] B5AC BC,69,C0 WAIT   ST   @PAD(@READ),@SPKSTS  Read status from PHROM
       B5AF 00,58
[3352] B5B1 DA,69,80        CLOG >80,@SPKSTS
[3353] B5B4 55,AC           BR   WAIT
[3354] B5B6 00              RTN
[3355]               ***********************************************************
[3356]               * SETRW moves addrs of speech read/write from GROM to VDP
[3357]               ***********************************************************
[3358] B5B7 31,00,04 SETRW  MOVE 4,G@>0046,@READ
       B5BA 58,00,46
[3359] B5BD 00              RTN
[3360]               ***********************************************************
[3361]               *                    ERROR MESSAGES
[3362]               ***********************************************************
[3363]               *      The following calls are in EXECS file.
[3364]               * ERRSYN CALL ERRZZ           * SYNTAX ERROR
[3365]               *        BYTE 3
[3366]               * ERRSNM CALL ERRZZ           * STRING-NUMBER MISMATCH
[3367]               *        BYTE 7
[3368]               * ERRBV  CALL ERRZZ           * BAD VALUE
[3369]               *        BYTE 30
[3370]               * ERRIAL CALL ERRZZ           * INCORRECT ARGUMENT LIST

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0059 
RXB 2022
[3371]               *        BYTE 31
[3372]               ***********************************************************
[3373] B5BE 06,6A,84 ERRSSL  CALL ERRZZ          * SPEECH STRING TOO LONG
[3374] B5C1 15               BYTE 21
[3375]               ***********************************************************
[3376]               *                 SUBPROGRAM FOR CLEAR                    *
[3377]               * CALL CLEAR                                              *
[3378]               ***********************************************************
[3379] B5C2 87,02    CLEAR  DCLR @MNUM          Row 0:Column 0
[3380] B5C4 BF,4A,00        DST  32,@FAC        32 length      
       B5C7 20
[3381] B5C8 5C,95           BR   CLRSC          JUMP TO CLRS ROUTINE
[3382]               ***********************************************************
[3383]               * CALL MOVES("$$",bytes,$variable,$variable,...)          *
[3384]               * CALL MOVES(type$,bytes,from-address,to-address,...)     *
[3385]               * CALL MOVES(type$,bytes,from-address,$variable,...)      *
[3386]               * CALL MOVES(type$,bytes,$variable,to-address,...)        *
[3387]               * type$:R=RAM, V=VDP, G=GRAM/GROM, $=string variable      *
[3388]               ***********************************************************
[3389] B5CA 06,A9,21 MOVES   CALL COMB           MOVES(TYPE$,BYTES,$,TO)
[3390]               *                            or MOVES(TYPE$,BYTES,FROM,$)
[3391] B5CD 06,A2,B4 MOVESA CALL STRGET          * ( or ,
[3392] B5D0 BD,10,B0        DST  V*FAC4,@VAR5    * TYPE "VRG$"
       B5D3 4E
[3393] B5D4 06,A2,CE        CALL GETNUM          * ,BYTES
[3394] B5D7 8F,4A           DCZ  @FAC            0?
[3395] B5D9 6D,8D           BS   ERRBV           BAD VALUE
[3396] B5DB BD,0C,4A        DST  @FAC,@BYTES     SAVE NUMBER OF BYTES
[3397] B5DE 06,A2,AE        CALL STRFCH          * ,FROM
[3398] B5E1 D6,10,24        CEQ  36,@VAR5        * $? VDP STRING VARIABLE?      
[3399] B5E4 55,F2           BR   MOVESX
[3400] B5E6 C8,0D,50        CHE  @FAC6,@BYTES+1
[3401] B5E9 75,F8           BS   MOVESB
[3402] B5EB 86,0C           CLR  @BYTES
[3403] B5ED BC,0D,50        ST   @FAC6,@BYTES+1
[3404] B5F0 55,F8           BR   MOVESB
[3405] B5F2 06,A2,C6 MOVESX CALL CFIFCH
[3406] B5F5 BD,4E,4A        DST  @FAC,@FAC4
[3407] B5F8 BD,04,4E MOVESB DST  @FAC4,@VARY
[3408] B5FB D6,11,24        CEQ  36,@VAR6        * $? VDP STRING VARIABLE?   
[3409] B5FE 56,10           BR   MOVESN
[3410] B600 CB,0C,01        DCHE 256,@BYTES
       B603 00
[3411] B604 6D,8D           BS   ERRBV
[3412] B606 0F,71           XML  GETSTR
[3413] B608 06,A2,E7        CALL NGOOD
[3414] B60B BD,4A,1C        DST  @SREF,@FAC
[3415] B60E 56,13           BR   MOVESC
[3416] B610 06,A2,D7 MOVESN CALL SUBLP3          * ,TO
[3417] B613 BD,06,4A MOVESC DST  @FAC,@VARY2
[3418] B616 D6,10,24        CEQ  36,@VAR5        * $? VDP STRING VARIABLE? 
[3419] B619 56,1E           BR   MTYPES
[3420] B61B BE,10,56        ST   86,@VAR5        * V? VDP ADDRESS?
[3421] B61E D6,11,24 MTYPES CEQ  36,@VAR6        * $? VDP STRING VARIABLE? 
[3422] B621 56,26           BR   MTYPE
[3423] B623 BE,11,56        ST   86,@VAR6        * VDP 
[3424] B626 D6,10,56 MTYPE  CEQ  86,@VAR5        * V? VDP FROM
[3425] B629 56,53           BR   MTYPE3
[3426] B62B D6,11,56        CEQ  86,@VAR6        * V? VDP TO
[3427] B62E 56,38           BR   MTYPE1
[3428] B630 34,0C,E0 MTYPE0 MOVE @BYTES,V@0(@VARY),V@0(@VARY2)
       B633 00,06,E0
       B636 00,04
[3429] B638 D6,11,52 MTYPE1 CEQ  82,@VAR6        * R? RAM TO

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0060 
RXB 2022
[3430] B63B 56,46           BR   MTYPE2
[3431] B63D 34,0C,CF        MOVE @BYTES,V@0(@VARY),@0(@VARY2)
       B640 7D,00,06
       B643 E0,00,04
[3432] B646 D6,11,47 MTYPE2 CEQ  71,@VAR6        * G? GRAM TO
[3433] B649 56,53           BR   MTYPE3
[3434] B64B 2C,0C,00        MOVE @BYTES,V@0(@VARY),G@0(@VARY2)
       B64E 00,06,E0
       B651 00,04
[3435] B653 D6,10,52 MTYPE3 CEQ  82,@VAR5        * R? RAM FROM
[3436] B656 56,83           BR   MTYPE7
[3437] B658 D6,11,56        CEQ  86,@VAR6        * V? VDP TO
[3438] B65B 56,66           BR   MTYPE5
[3439] B65D 34,0C,E0 MTYPE4 MOVE @BYTES,@0(@VARY),V@0(@VARY2)
       B660 00,06,CF
       B663 7D,00,04
[3440] B666 D6,11,52 MTYPE5 CEQ  82,@VAR6        * R? RAM TO
[3441] B669 56,75           BR   MTYPE6
[3442] B66B 34,0C,CF        MOVE @BYTES,@0(@VARY),@0(@VARY2)
       B66E 7D,00,06
       B671 CF,7D,00
       B674 04
[3443] B675 D6,11,47 MTYPE6 CEQ  71,@VAR6        * G? GRAM TO
[3444] B678 56,83           BR   MTYPE7
[3445] B67A 2C,0C,00        MOVE @BYTES,@0(@VARY),G@0(@VARY2)
       B67D 00,06,CF
       B680 7D,00,04
[3446] B683 D6,10,47 MTYPE7 CEQ  71,@VAR5        * G? GRAM FROM
[3447] B686 56,B0           BR   MOVESD
[3448] B688 D6,11,56        CEQ  86,@VAR6        * V? VDP TO
[3449] B68B 56,95           BR   MTYPE9
[3450] B68D 32,0C,E0 MTYPE8 MOVE @BYTES,G@0(@VARY),V@0(@VARY2)
       B690 00,06,00
       B693 00,04
[3451] B695 D6,11,52 MTYPE9 CEQ  82,@VAR6        * R? RAM TO
[3452] B698 56,A3           BR   MTYPEA
[3453] B69A 32,0C,CF        MOVE @BYTES,G@0(@VARY),@0(@VARY2)
       B69D 7D,00,06
       B6A0 00,00,04
[3454] B6A3 D6,11,47 MTYPEA CEQ  71,@VAR6        * G? GRAM TO
[3455] B6A6 56,B0           BR   MOVESD
[3456] B6A8 2A,0C,00        MOVE @BYTES,G@0(@VARY),G@0(@VARY2)
       B6AB 00,06,00
       B6AE 00,04
[3457] B6B0 D6,42,B3 MOVESD CEQ  >B3,@CHAT       * COMMA?  
[3458] B6B3 75,CD           BS   MOVESA
[3459] B6B5 4A,BA           BR   LNKRTN
[3460]               **********************************************************
[3461]               * CALL HEX($variable,variable,...)                       *
[3462]               * CALL HEX(variable,$variable,...)                       *
[3463]               * CALL HEX(">####",variable,...)                         *
[3464]               **********************************************************
[3465] B6B7 06,A9,21 HEX    CALL COMB             * HEX(variable,variable)
[3466] B6BA 06,A2,AE HEXAGN CALL STRFCH            Get STRING or NUMBER
[3467] B6BD D6,4C,65        CEQ  >65,@FAC2         STRING?
[3468] B6C0 77,17           BS   HEX00             Yes
[3469]               ****************************** Number to HEX String
[3470] B6C2 06,A2,C6        CALL CFIFCH            Turn from DEC to HEX
[3471] B6C5 BD,56,4A        DST  @FAC,@TEMP2       Save it
[3472] B6C8 BF,0C,00        DST  >0004,@BYTES      Number of byte for string
       B6CB 04
[3473] B6CC 0F,71           XML  GETSTR            Get String 
[3474] B6CE BD,12,1C        DST  @SREF,@STRPTR     Save string location 
[3475] B6D1 BC,00,56        ST   @TEMP2,@PAD       Get one byte in PAD

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0061 
RXB 2022
[3476] B6D4 E6,00,04        SRL  4,@PAD            Strip off low bits
[3477] B6D7 06,B7,05        CALL HEXNS             Convert to ASCII
[3478] B6DA BC,00,56        ST   @TEMP2,@PAD       Get one byte in PAD
[3479] B6DD E2,00,04        SLL  4,@PAD            Strip off high bits
[3480] B6E0 E6,00,04        SRL  4,@PAD            Put back now high bits gone
[3481] B6E3 06,B7,05        CALL HEXNS             Convert to ASCII
[3482] B6E6 BC,00,57        ST   @TEMP2+1,@PAD     Get one byte in PAD 
[3483] B6E9 E6,00,04        SRL  4,@PAD            Strip off low bits
[3484] B6EC 06,B7,05        CALL HEXNS             Convert to ASCII
[3485] B6EF BC,00,57        ST   @TEMP2+1,@PAD     Get one byte in PAD 
[3486] B6F2 E2,00,04        SLL  4,@PAD            Strip off high bits
[3487] B6F5 E6,00,04        SRL  4,@PAD            Put back now high bits gone
[3488] B6F8 06,B7,05        CALL HEXNS             Convert to ASCII
[3489] B6FB D6,42,B3        CEQ  COMMAZ,@CHAT      , COMMA?
[3490] B6FE 4D,59           BR   ERRSYN            ERROR SYNTAX
[3491] B700 06,A2,E7        CALL NGOOD             Assign to Variable
[3492] B703 57,31           BR   HEXDON            Go check for COMMA
[3493] B705 CA,00,0A HEXNS  CHE  >0A,@PAD          10 or higher?
[3494] B708 57,0D           BR   HEXNS2            No
[3495] B70A A2,00,07        ADD  >07,@PAD          Add 7
[3496] B70D A2,00,30 HEXNS2 ADD  >30,@PAD          Add 48
[3497] B710 BC,B0,12        ST   @PAD,V*STRPTR     Save new byte
       B713 00
[3498] B714 91,12           DINC @STRPTR           Next Character
[3499] B716 00              RTN
[3500]               ***************************** HEX String to NUMBER
[3501] B717 06,B7,38 HEX00  CALL HEXSTR            ASC to HEX
[3502] B71A 0F,79           XML  PGMCHR            Next value?
[3503] B71C 06,A3,02        CALL SNDER             Send value
[3504] B71F 06,A3,1F        CALL CLRFAC            Clear FAC
[3505] B722 86,8F,DD        CLR  @>6004            Set ROM 3 page
       B725 04
[3506] B726 0F,76           XML  ASCHEX            Convert ASC to HEX
[3507] B728 D7,5C,99        DCEQ >994A,@ARG        ERROR FLAG?
       B72B 4A
[3508] B72C 6D,89           BS   ERRBA             ERROR BAD ARGUMENT
[3509] B72E 06,A3,09        CALL CIFSND            Convert Integer to FP send
[3510] B731 D6,42,B3 HEXDON CEQ  COMMAZ,@CHAT      , COMMA?  
[3511] B734 76,BA           BS   HEXAGN            Next set to run
[3512] B736 4A,BA           BR   LNKRTN            Return to XB
[3513]               ******************************
[3514] B738 8F,50    HEXSTR DCZ  @FAC6         Zero length string?
[3515] B73A 6D,89           BS   ERRBA         ERROR BAD ARGUMENT
[3516] B73C D6,B0,4E        CEQ  62,V*FAC4     > ?
       B73F 3E
[3517] B740 57,4A           BR   HEX01         No
[3518] B742 91,4E           DINC @FAC4         Add 1 to ignore >
[3519] B744 92,51           DEC  @FAC7         Length -1 ignore >
[3520] B746 8E,51           CZ   @FAC7
[3521] B748 6D,89           BS   ERRBA         ERROR BAD ARGUMENT
[3522] B74A BF,00,30 HEX01  DST  >3030,@PAD    ZERO BUFFER
       B74D 30
[3523] B74E BF,02,30        DST  >3030,@PAD2   ZERO BUFFER
       B751 30
[3524] B752 D6,51,01        CEQ 1,@FAC7        1 to move
[3525] B755 57,60           BR   HEX02         No
[3526] B757 35,00,01        MOVE 1,V@0(@FAC4),@PAD3 Get 1 chr
       B75A 03,E0,00
       B75D 4E
[3527] B75E 57,83           BR   HEX05         Check valid
[3528] B760 D6,51,02 HEX02  CEQ  2,@FAC7       2 to move 
[3529] B763 57,6E           BR   HEX03         No
[3530] B765 35,00,02        MOVE 2,V@0(@FAC4),@PAD2 Get 2 chr
       B768 02,E0,00

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0062 
RXB 2022
       B76B 4E
[3531] B76C 57,83           BR   HEX05         Check valid
[3532] B76E D6,51,03 HEX03  CEQ  3,@FAC7       3 to move
[3533] B771 57,7C           BR   HEX04         No
[3534] B773 35,00,03        MOVE 3,V@0(@FAC4),@PAD1 Get 3 chr
       B776 01,E0,00
       B779 4E
[3535] B77A 57,83           BR   HEX05         Check valid
[3536] B77C 35,00,04 HEX04  MOVE 4,V@0(@FAC4),@PAD Get 4 chr
       B77F 00,E0,00
       B782 4E
[3537] B783 00       HEX05  RTN                Return to caller
[3538]               **********************************************************
[3539]               * CALL HPUT(row,column,$variable,...)                    *
[3540]               * CALL HPUT(row,column,number-variable,...)              *
[3541]               **********************************************************
[3542] B784 06,B7,A4 HPUTZ  CALL PUTZ    
[3543] B787 86,8F,DD HPUTS  CLR  @>6004        Set ROM 3 page
       B78A 04
[3544] B78B 0F,77           XML  HPUT
[3545] B78D D6,42,B3 HPOUT  CEQ  >B3,@CHAT
[3546] B790 77,84           BS   HPUTZ
[3547] B792 4A,BA           BR   LNKRTN
[3548]               **********************************************************
[3549]               * CALL VPUT(row,column,$variable,...)                    *
[3550]               * CALL VPUT(row,column,number-variable,...)              *
[3551]               **********************************************************
[3552] B794 06,B7,A4 VPUTZ  CALL PUTZ              Get ( and ROW         No, CNS
[3553] B797 86,8F,DD VPUTS  CLR  @>6004        Set ROM 3 page
       B79A 04
[3554] B79B 0F,78           XML  VPUT
[3555] B79D D6,42,B3 VPOUT  CEQ  >B3,@CHAT
[3556] B7A0 77,94           BS   VPUTZ
[3557] B7A2 4A,BA           BR   LNKRTN
[3558]               *******************************
[3559] B7A4 06,AA,FA PUTZ   CALL GPHV
[3560] B7A7 06,A2,B0        CALL STRPAR
[3561] B7AA D6,4C,65        CEQ  >65,@FAC2
[3562] B7AD 77,D0           BS   PUTZ1
[3563] B7AF 86,55           CLR  @FAC11            Select XB FLP
[3564] B7B1 0F,73           XML  XBCNS             Convert Number to String
[3565] B7B3 D6,90,55        CEQ  SPACE,*FAC11      Leading space?
       B7B6 20
[3566] B7B7 57,BD           BR   HVPUTN
[3567] B7B9 90,55           INC  @FAC11            Supress space out
[3568] B7BB 92,56           DEC  @FAC12            Shorten length
[3569] B7BD 86,0C    HVPUTN CLR  @BYTES
[3570] B7BF BC,0D,56        ST   @FAC12,@BYTES+1        Length
[3571] B7C2 0F,71           XML  GETSTR                 Get string
[3572] B7C4 34,0C,B0        MOVE @BYTES,*FAC11,V*SREF   Store in VDP rollout
       B7C7 1C,90,55
[3573] B7CA BD,4E,1C        DST  @SREF,@FAC4            VDP rollout address
[3574] B7CD BD,50,0C        DST  @BYTES,@FAC6           Store length
[3575] B7D0 00       PUTZ1  RTN
[3576]               **********************************************************
[3577]               * CALL HGET(row,column,length,$variable,...)             *
[3578]               **********************************************************
[3579] B7D1 06,A9,21 HGETZ  CALL COMB              * 
[3580] B7D4 06,B8,14 HAGAIN CALL HVGETS
[3581] B7D7 06,A3,0E LP2    CALL GETLP
[3582] B7DA 08              FMT
[3583] B7DB E0,00           DATA >E000
[3584] B7DD FB              FEND
[3585] B7DE 93,54           DDEC @TEMP1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0063 
RXB 2022
[3586] B7E0 57,D7           BR   LP2
[3587] B7E2 06,A2,E7 HDONE  CALL NGOOD
[3588] B7E5 D6,42,B3        CEQ  >B3,@CHAT
[3589] B7E8 77,D4           BS   HAGAIN
[3590] B7EA BC,7F,02 XPTRTN ST   @MNUM,@XPT        Restore X-pointer
[3591] B7ED 4A,BA           BR   LNKRTN            Return to caller
[3592]               **********************************************************
[3593]               * CALL VGET(row,column,length,$variable,...)             *
[3594]               **********************************************************
[3595] B7EF 06,A9,21 VGETZ  CALL COMB               * 
[3596] B7F2 06,B8,14 VAGAIN CALL HVGETS
[3597] B7F5 06,A3,0E LP1    CALL GETLP
[3598] B7F8 08              FMT
[3599] B7F9 E0,00           DATA >E000
[3600] B7FB 9E              BYTE >9E
[3601] B7FC FB              FEND
[3602] B7FD 93,54           DDEC @TEMP1
[3603] B7FF 78,0A           BS   VDONE
[3604] B801 8E,7E           CZ   @YPT
[3605] B803 57,F5           BR   LP1
[3606] B805 90,7F           INC  @XPT
[3607] B807 05,B7,F5        B    LP1
[3608] B80A 06,A2,E7 VDONE  CALL NGOOD
[3609] B80D D6,42,B3        CEQ  >B3,@CHAT
[3610] B810 77,F2           BS   VAGAIN
[3611] B812 57,EA           BR   XPTRTN
[3612]               ****************************
[3613] B814 06,A2,CE HVGETS CALL GETNUM    * SUBLP3,Comma?
[3614] B817 CF,4A,00        DCGT 24,@FAC   * Larger then 24?  
       B81A 18
[3615] B81B 6D,8D           BS   ERRBV     * Yes, ERROR BAD VALUE
[3616] B81D 93,4A           DDEC @FAC      * FAC-1
[3617] B81F E3,4A,00        DSLL 5,@FAC    * FAC times 32  
       B822 05
[3618] B823 BC,02,4A        ST   @FAC,@MNUM * Get Row
[3619] B826 06,A2,CE        CALL GETNUM    * SUBLP3,Comma?
[3620] B829 CF,4A,00        DCGT 32,@FAC   * Larger then 32?    
       B82C 20
[3621] B82D 6D,8D           BS   ERRBV     * Yes, ERROR BAD VALUE
[3622] B82F 93,4A           DDEC @FAC      * FAC-1
[3623] B831 A0,03,4B        ADD @FAC1,@MNUM+1    * Set column pointer
[3624] B834 06,A2,CE        CALL GETNUM
[3625] B837 CF,4A,00        DCGT >00FF,@FAC
       B83A FF
[3626] B83B 6D,8D           BS   ERRBV              * BAD VALUE
[3627] B83D BD,0C,4A        DST  @FAC,@BYTES
[3628] B840 BD,54,4A        DST  @FAC,@TEMP1
[3629] B843 0F,71           XML  GETSTR
[3630] B845 BD,12,1C        DST  @SREF,@STRPTR
[3631] B848 00              RTN
[3632]               **********************************************************
[3633]               * CALL GMOTION(#sprite,row-varable,col-variable,...)     *
[3634]               **********************************************************
[3635] B849 06,A9,21 GMOT   CALL COMB              * 
[3636] B84C 06,B0,B1 GMAGN  CALL SPNUM2
[3637] B84F BE,54,02        ST   >02,@TEMP1
[3638] B852 BD,56,E4        DST  V@>0480(@SPSAL),@TEMP2
       B855 80,08
[3639] B857 06,B1,63 GMO1   CALL PREPN
[3640] B85A BC,4B,56        ST   @TEMP2,@FAC+1
[3641] B85D C6,4B,7F        CH   >7F,@FAC+1
[3642] B860 58,66           BR   GMO2
[3643] B862 82,4B           NEG  @FAC+1
[3644] B864 83,4A           DNEG @FAC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0064 
RXB 2022
[3645] B866 06,A3,09 GMO2   CALL CIFSND
[3646] B869 D6,54,01        CEQ  >01,@TEMP1
[3647] B86C 78,72           BS   GMO3
[3648] B86E 0F,7E           XML  SPEED
[3649] B870 00,B3           DATA >00B3
[3650] B872 C0,57,56 GMO3   EX   @TEMP2,@TEMP2+1
[3651] B875 92,54           DEC  @TEMP1
[3652] B877 58,57           BR   GMO1
[3653] B879 D6,42,B3        CEQ  >B3,@CHAT
[3654] B87C 78,4C           BS   GMAGN
[3655] B87E 4A,BA           BR   LNKRTN
[3656]               **********************************************************
[3657]               * CALL RMOTION(#sprite,ALL)                              *
[3658]               * CALL RMOTION(#sprite,#sprite,...)                      *
[3659]               **********************************************************
[3660] B880 06,A9,21 RMOT   CALL COMB               *  
[3661] B883 0F,79    RMAGN  XML  PGMCHR
[3662] B885 D6,42,EC        CEQ  >EC,@CHAT
[3663] B888 58,9A           BR   NOALL
[3664] B88A 0F,7E           XML  SPEED
[3665] B88C 00,EC           DATA >00EC
[3666] B88E BF,00,00        DST  >001C,@PAD
       B891 1C
[3667] B892 BD,4A,00 NXALL  DST  @PAD,@FAC
[3668] B895 06,B0,C3        CALL SPNUM5
[3669] B898 58,A9           BR   RMALL
[3670] B89A BF,00,00 NOALL  DST  >0001,@PAD
       B89D 01
[3671] B89E D6,42,FD        CEQ  NUMBEZ,@CHAT
[3672] B8A1 4D,59           BR   ERRSYN
[3673] B8A3 06,A2,BD        CALL NUMFCH
[3674] B8A6 06,B0,BD        CALL SPNUM4
[3675] B8A9 BD,54,E4 RMALL  DST  V@>0480(@SPSAL),@TEMP1
       B8AC 80,08
[3676] B8AE BE,56,02        ST   >02,@TEMP2
[3677] B8B1 8E,54    RMOTLP CZ   @TEMP1
[3678] B8B3 78,C5           BS   J2
[3679] B8B5 D6,54,80        CEQ  >80,@TEMP1
[3680] B8B8 78,D1           BS   J3
[3681] B8BA C6,54,7F        CH   >7F,@TEMP1
[3682] B8BD 78,C3           BS   J1
[3683] B8BF 82,54           NEG  @TEMP1
[3684] B8C1 58,C5           BR   J2
[3685] B8C3 80,54    J1     ABS  @TEMP1
[3686] B8C5 C0,55,54 J2     EX   @TEMP1,@TEMP1+1
[3687] B8C8 92,56           DEC  @TEMP2
[3688] B8CA 58,B1           BR   RMOTLP
[3689] B8CC BD,E4,80        DST  @TEMP1,V@>0480(@SPSAL)
       B8CF 08,54
[3690] B8D1 93,00    J3     DDEC @PAD
[3691] B8D3 58,92           BR   NXALL
[3692] B8D5 D6,42,B3        CEQ  >B3,@CHAT
[3693] B8D8 78,83           BS   RMAGN
[3694] B8DA 4A,BA           BR   LNKRTN
[3695]               ***********************************************************
[3696]               * CALL COINC(#sprite,#sprite,tolerance,variable,...)       
[3697]               * CALL COINC(#sprite,dotrow,dotcol,tolerance,variable,...) 
[3698]               ***********************************************************
[3699] B8DC 06,AF,81 ZSCOI  CALL SPRCOI       *    
[3700] B8DF D6,42,B3 COINLP CEQ  >B3,@CHAT    *
[3701] B8E2 4A,BA           BR   LNKRTN       *
[3702] B8E4 0F,79           XML  PGMCHR       *
[3703] B8E6 06,AF,97        CALL GAF56        *
[3704] B8E9 58,DF           BR   COINLP       *

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0065 
RXB 2022
[3705]               ***********************************************************
[3706]               * CALL DISTANCE(#sprite,#sprite,variable,...)              
[3707]               * CALL DISTANCE(#sprite,dot-row,dot-col,variable,...)      
[3708]               ***********************************************************
[3709] B8EB 06,B0,07 ZDIST  CALL DIST         *    
[3710] B8EE D6,42,B3 DISLP  CEQ  >B3,@CHAT    *
[3711] B8F1 4A,BA           BR   LNKRTN       *
[3712] B8F3 06,B0,0A        CALL GAFC4        *
[3713] B8F6 58,EE           BR   DISLP        *
[3714]              
[3715]               ***********************************************************
[3716]               * CALL KEY(string,keyunit,Nvarible,Nvariable...)          *
[3717]               * CALL KEY(keyunit,Nvariable,Nvarible...)                 *
[3718]               ***********************************************************
[3719] B8F8 06,AB,FB ZKEY   CALL KEY               Get key
[3720] B8FB D6,42,B3        CEQ  COMMAZ,@CHAT
[3721] B8FE 78,F8           BS   ZKEY
[3722] B900 4A,BA           BR   LNKRTN
[3723]               ***********************************************************
[3724] B902 BC,00,4B KEYJOY ST   @FAC1,@PAD        Keyboard selection
[3725] B905 06,A9,08        CALL NUMVAR            Get variable for key-code
[3726] B908 D6,42,B3        CEQ  COMMAZ,@CHAT      If not comma - error
[3727] B90B 4D,59           BR   ERRSYN            SYNTAX error
[3728] B90D 0F,79           XML  PGMCHR            Get next character
[3729] B90F 06,A9,08        CALL NUMVAR            Get variable for key-status
[3730] B912 BC,74,00        ST   @PAD,@KEYBD       Keyboard selection
[3731] B915 31,00,08        MOVE 8,G@FLT1,@FAC     Set up float
       B918 4A,A3,44
[3732] B91B 06,B9,22        CALL KEYSTR            * RXB KEY STRING COMPARISON *
[3733] B91E BC,04,7C        ST   @STATUS,@VARY     Save stutus
[3734] B921 01              RTNC                   Return scan condition co
[3735]               ***********************************************************
[3736] B922 D7,10,99 KEYSTR DCEQ >994A,@TOPSTK     Flag set?
       B925 4A
[3737] B926 59,56           BR   RSCAN3            No.
[3738] B928 BD,08,04        DST  @VARY,@PAD8       String address.
[3739] B92B BD,02,06        DST  @CCPPTR,@ACCUM    Copy length.
[3740] B92E 86,68           CLR  @BYTE3            Zero out counter
[3741] B930 D6,66,9B RSCAN  CEQ  ONZ,@BYTE1        ON flag?
[3742] B933 59,39           BR   RSCAN0            No
[3743] B935 03              SCAN                   Get a key
[3744] B936 05,B9,3C        B    RSCAN1            Jump past normal KEY
[3745] B939 03       RSCAN0 SCAN                   Any key?
[3746] B93A 59,39           BR   RSCAN0            No.
[3747] B93C 8F,06    RSCAN1 DCZ  @CCPPTR           Length 0?
[3748] B93E 79,57           BS   RSCAN4            Yes.
[3749] B940 90,68    RSCAN2 INC  @BYTE3            Counter +1
[3750] B942 D4,75,B0        CEQ  V*PAD8,@RKEY      Same?
       B945 08
[3751] B946 79,5C           BS   RSCAN5            Yes.
[3752] B948 91,08           DINC @PAD8             Address +1
[3753] B94A 93,02           DDEC @ACCUM            Length -1
[3754] B94C 59,40           BR   RSCAN2            No matcth.
[3755] B94E D6,66,9B        CEQ  ONZ,@BYTE1        ON flag?
[3756] B951 79,57           BS   RSCAN4            Yes
[3757] B953 05,B9,22        B    KEYSTR            Restart.
[3758] B956 03       RSCAN3 SCAN                   Normal key scan.
[3759] B957 86,74    RSCAN4 CLR  @KEYBD            Clear key unit
[3760] B959 87,10           DCLR @TOPSTK           Clear flag.
[3761] B95B 01              RTNC                   Return save condition
[3762] B95C 06,B9,57 RSCAN5 CALL RSCAN4
[3763] B95F D4,00,00        CEQ  @PAD,@PAD         Force condition bit on
[3764] B962 01              RTNC                   Return save condition
[3765]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0066 
RXB 2022
[3766]               * CALL ONKEY(string,keyunit,variable,variable)            *
[3767]               * GOTO line#,line#,line#...                               *
[3768]               ***********************************************************
[3769] B963 BE,66,9B ZONKEY ST   ONZ,@BYTE1
[3770] B966 8E,44           CZ   @PRGFLG           Program mode?
[3771] B968 6D,85           BS   ERRLNF            ERROR LINE NOT FOUND
[3772] B96A 06,AB,FB        CALL KEY               Get normal key,status
[3773] B96D 8E,04           CZ   @VARY             Was a key pressed?
[3774] B96F 59,73           BR   GOTON0            No ONZ flag stays set
[3775] B971 86,66           CLR  @BYTE1            Clear ONZ flag
[3776] B973 D6,42,B6 GOTON0 CEQ  RPARZ,@CHAT       )
[3777] B976 4D,59           BR   ERRSYN            SYNTAX ERROR
[3778] B978 0F,79           XML  PGMCHR            Skip )
[3779] B97A D6,42,86        CEQ  GOTOZ,@CHAT       GOTO flag?
[3780] B97D 4D,59           BR   ERRSYN            SYNTAX ERROR
[3781] B97F 86,67           CLR  @BYTE2            Zero out Counter
[3782] B981 90,67    ONLP   INC  @BYTE2            Counter +1
[3783] B983 0F,79           XML  PGMCHR            Skip GO
[3784] B985 D6,42,C9        CEQ  LNZ,@CHAT         Line# token?
[3785] B988 4D,59           BR   ERRSYN            SYNTAX ERROR
[3786] B98A 0F,79           XML  PGMCHR            Skip line# token
[3787] B98C BC,4A,42        ST   @CHAT,@FAC        Store high byte line#
[3788] B98F 0F,79           XML  PGMCHR            Skip high byte line#
[3789] B991 BC,4B,42        ST   @CHAT,@FAC1       Store low byte line#
[3790] B994 0F,79           XML  PGMCHR            Skip low byte line#
[3791] B996 D4,67,68        CEQ  @BYTE3,@BYTE2     $ counter = line# counter
[3792] B999 59,9E           BR   ONKEY1            No
[3793] B99B BD,04,4A        DST  @FAC,@VARY        Save line#
[3794] B99E D6,42,B3 ONKEY1 CEQ  COMMAZ,@CHAT      ,?
[3795] B9A1 79,81           BS   ONLP              Yes, keep going
[3796] B9A3 BD,4A,04        DST  @VARY,@FAC        Get saved line#
[3797] B9A6 D6,66,9B        CEQ  ONZ,@BYTE1        ONZ flag?
[3798] B9A9 79,AE           BS   GKEY1             Yes, load line#
[3799] B9AB 06,00,12        CALL RETURN            Return to XB
[3800]               **********************************************************
[3801] B9AE BD,4C,32 GKEY1  DST  @ENLN,@FAC2        Get last address
[3802] B9B1 A7,4C,00        DSUB 3,@FAC2            Point to first LINE#
       B9B4 03
[3803] B9B5 06,80,2E GKEY2  CALL GRSUB3             Read from VDP/RAM
[3804] B9B8 4C              BYTE FAC2
[3805] B9B9 D5,4A,58        DCEQ @EEE1,@FAC         Same?
[3806] B9BC 79,C9           BS   GKEY3              Yes, found line#
[3807] B9BE C5,4C,30        DCH  @STLN,@FAC2        No line# left
[3808] B9C1 4D,85           BR   ERRLNF             ERROR LINE NOT FOUND
[3809] B9C3 A7,4C,00        DSUB 4,@FAC2            Next LINE#
       B9C6 04
[3810] B9C7 59,B5           BR   GKEY2              Loop
[3811] B9C9 BD,2E,4C GKEY3  DST  @FAC2,@EXTRAM      Got LINE#
[3812] B9CC A3,2E,00        DADD 4,@EXTRAM          Point to begining of line
       B9CF 04
[3813] B9D0 95,2E           DINCT @EXTRAM           Point to ADDRESS
[3814] B9D2 BD,2C,2E        DST  @EXTRAM,@PGMPTR    Set pointer to line to run
[3815] B9D5 95,2C           DINCT @PGMPTR           Point to tokens
[3816] B9D7 06,00,12        CALL RETURN             Return to XB
[3817]               **********************************************************
[3818]               *                  SUBPROGRAM FOR 'JOYSTICK'
[3819]               **********************************************************
[3820] B9DA 06,BA,78 JOYST  CALL SPAR              KEY UNIT
[3821]               * RXB PATCH LABEL ************
[3822] B9DD 0F,7E    JOYRPT XML  SPEED             Insure in range
[3823] B9DF 02              BYTE RANGE          *   of 1 - 4
[3824] B9E0 01              BYTE 1
[3825] B9E1 00,04           DATA 4
[3826]               *                             GET VARIABLES FOR X, Y

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0067 
RXB 2022
[3827]               *                              AND SCAN KEYBOARD
[3828] B9E3 BC,00,4B        ST   @FAC1,@PAD        Keyboard selection
[3829] B9E6 06,A9,08        CALL NUMVAR            Get variable for key-code
[3830] B9E9 D6,42,B3        CEQ  COMMAZ,@CHAT      If not comma - error
[3831] B9EC 4D,59           BR   ERRSYN
[3832] B9EE 0F,79           XML  PGMCHR            Get next character
[3833] B9F0 06,A9,08        CALL NUMVAR            Get variable for key-status
[3834] B9F3 BC,74,00        ST   @PAD,@KEYBD       Keyboard selection
[3835] B9F6 31,00,08        MOVE 8,G@FLT1,@FAC     Set up float
       B9F9 4A,A3,44
[3836] B9FC 03              SCAN                   SCAN the keyboard
[3837]               * RXB PATCH CODE SAVE KEY & JOYST
[3838] B9FD BC,17,75 JOYSTS ST   @RKEY,@FNUM       SAVE KEY VALUE 
[3839] BA00 BD,14,76        DST  @JOYY,@VAR9       JOYY & JOYX
[3840] BA03 86,74           CLR  @KEYBD            Clear the code(No affect on s
[3841] BA05 BC,00,76        ST   @JOYY,@PAD        JOYSTICK Y POSITION
[3842] BA08 06,A8,F2        CALL JOYXY             -4 to +4
[3843] BA0B BF,4A,40        DST  >4001,@FAC        Re-store F.P. 1 in FAC
       BA0E 01
[3844] BA0F BC,00,77        ST   @JOYX,@PAD        JOYSTICK X POSITION
[3845] BA12 06,A8,F2        CALL JOYXY             -4 to +4
[3846] BA15 00              RTN                    Return 
[3847]               ***********************************************************
[3848] BA16 06,B9,DA ZJOYST CALL JOYST
[3849] BA19 D6,42,B3 JOYAGN CEQ  COMMAZ,@CHAT
[3850] BA1C 4A,BA           BR   LNKRTN
[3851] BA1E 06,AC,56        CALL CPAR3
[3852] BA21 06,B9,DD        CALL JOYRPT
[3853] BA24 5A,19           BR   JOYAGN
[3854]               ***********************************************************
[3855]               * MOTION PATCH for GO and STOP
[3856] BA26 0F,79    SPGS   XML  PGMCHR            ( or ,
[3857] BA28 D6,42,EC        CEQ  ALLZ,@CHAT        ALL?
[3858] BA2B 5A,53           BR   SPGS1             No.
[3859] BA2D 0F,79           XML  PGMCHR            Skip ALL
[3860] BA2F 0F,79           XML  PGMCHR            Skip ,
[3861] BA31 BF,4A,00        DST  1,@FAC            First sprite
       BA34 01
[3862] BA35 06,B0,C3        CALL SPNUM5            Get sprite table
[3863] BA38 06,B1,04        CALL SPMOVE            Store velocity
[3864] BA3B BE,4A,1C        ST   28,@FAC           Last sprite
[3865] BA3E 87,00           DCLR @PAD              Index
[3866] BA40 35,00,02 SPGSA  MOVE 2,V@>0780,V@>0780(@PAD)
       BA43 E7,80,00
       BA46 A7,80
[3867] BA48 A3,00,00        DADD 4,@PAD            Index +4
       BA4B 04
[3868] BA4C 92,4A           DEC  @FAC              Sprite -1
[3869] BA4E 5A,40           BR   SPGSA             Done?
[3870] BA50 05,AF,DC        B    SPRMV4            Done?
[3871] BA53 D6,42,FD SPGS1  CEQ  NUMBEZ,@CHAT      #?
[3872] BA56 5A,5E           BR   SPGS2             No.
[3873] BA58 06,B0,B3        CALL SPNUM6            Standard routine.
[3874] BA5B 05,AF,D9        B    SPRMV3            No.
[3875] BA5E D6,42,85 SPGS2  CEQ  GOZ,@CHAT         GO?
[3876] BA61 5A,6A           BR   SPGS3             No.
[3877] BA63 B2,80,C2        AND  >BF,@>83C2        GO!!!
       BA66 BF
[3878] BA67 05,BA,73        B    SPGS4             Done.
[3879] BA6A D6,42,98 SPGS3  CEQ  STOPZ,@CHAT       STOP?
[3880] BA6D 4D,59           BR   ERRSYN            No
[3881] BA6F B6,80,C2        OR   >40,@>83C2        STOP!!!
       BA72 40
[3882] BA73 0F,79    SPGS4  XML  PGMCHR            Skip GO or STOP

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0068 
RXB 2022
[3883] BA75 05,AF,DC SPGSE  B    SPRMV4            Done?
[3884]               *********************************************************
[3885]               * RXB KEY & JOYSTICK LEFT PARENTHESES AND CHECK FOR STRING?
[3886] BA78 D6,42,B7 SPAR   CEQ  LPARZ,@CHAT       (?
[3887] BA7B 7A,82           BS   SPAR1             Yes.
[3888] BA7D D6,42,B3        CEQ  COMMAZ,@CHAT      ,?
[3889] BA80 4D,59           BR   ERRSYN            No.
[3890] BA82 0F,79    SPAR1  XML  PGMCHR            Skip ( or ,
[3891] BA84 0F,74           XML  PARSE             Get string or value.
[3892] BA86 B6              BYTE RPARZ
[3893] BA87 D6,4C,65        CEQ  >65,@FAC2         RXB version String?
[3894] BA8A 5A,9A           BR   SPAR2             No normal XB version
[3895] BA8C BD,04,4E        DST  @FAC4,@VARY       Save string address.
[3896] BA8F BD,06,50        DST  @FAC6,@VARY2      Save string length.
[3897] BA92 BF,10,99        DST  >994A,@TOPSTK     Set RXB flag.
       BA95 4A
[3898] BA96 06,AC,3F        CALL LPARR           * Left PARENTHESES or COMMA 
[3899]               * RXB Version               * Get String or key value
[3900] BA99 00              RTN
[3901]               * RXB COMMA SPEED CHECKER
[3902] BA9A 0F,7E    SPAR2  XML  SPEED
[3903] BA9C 00              BYTE SYNCHK          * Syntax checker
[3904] BA9D B3              BYTE COMMAZ          * Only COMMA is valid
[3905] BA9E 00              RTN
[3906]               ***********************************************************
[3907]               * CALL JOYMOTION(keyunit,X,Y,#sprite,Rindex,Cindex)        
[3908]               * CALL JOYMOTION(keyunit,X,Y,#sprite,Rindex,Cindex,KEY)    
[3909]               * CALL JOYMOTION(keyunit,X,Y,#sprite,Rindex,Cindex,KEY)    
[3910]               * GOTO line-number                                         
[3911]               ***********************************************************
[3912] BA9F 06,B9,DA ZJOMO  CALL JOYST          * Get Key unit, X & Y 
[3913] BAA2 D6,42,B3        CEQ  COMMAZ,@CHAT   * COMMA?
[3914] BAA5 4D,59           BR   ERRSYN         * SYNTAX ERROR
[3915] BAA7 06,B0,B1        CALL SPNUM2         * SPSAL=SPRITE ADDRESS 
[3916] BAAA 06,B1,4A        CALL COMMA1            Parse up to comma and skip
[3917] BAAD 06,B1,26        CALL RANGEV            Check if numeric and convert
[3918]               *                              to integer
[3919] BAB0 BC,0A,4B        ST   @FAC1,@SPTMP      Store Y velocity
[3920] BAB3 0F,74           XML  PARSE             Get X velocity
[3921] BAB5 B6              BYTE RPARZ           * Check for ")" or less
[3922] BAB6 06,B1,26        CALL RANGEV            Numeric check and convert
[3923]               *                              to integer
[3924] BAB9 BC,4A,0A       ST   @SPTMP,@FAC     * @FAC=Y velocity, @FAC1=X veloc
[3925]               * CHECK DIRECTION OF JOYST AND SET UP FAC FOR LOADING VALUE
[3926] BABC D7,14,00        DCEQ >0000,@VAR9   * >0000 JOYST
       BABF 00
[3927] BAC0 5A,C4           BR   ZJOMO1        * Go UP 
[3928] BAC2 87,4A           DCLR @FAC          * Zero both
[3929] BAC4 D7,14,04 ZJOMO1 DCEQ >0400,@VAR9   * UP
       BAC7 00
[3930] BAC8 5A,CE           BR   ZJOMO2        * Go DOWN
[3931] BACA 82,4A           NEG  @FAC          * Negative
[3932] BACC 86,4B           CLR  @FAC1         * Zero
[3933] BACE D7,14,FC ZJOMO2 DCEQ >FC00,@VAR9   * DOWN
       BAD1 00
[3934] BAD2 5A,D8           BR   ZJOMO3        * Go LEFT
[3935] BAD4 80,4A           ABS  @FAC          * Postive
[3936] BAD6 86,4B           CLR  @FAC1         * Zero
[3937] BAD8 D7,14,00 ZJOMO3 DCEQ >00FC,@VAR9   * LEFT
       BADB FC
[3938] BADC 5A,E2           BR   ZJOMO4        * Go RIGHT
[3939] BADE 86,4A           CLR  @FAC          * Zero
[3940] BAE0 82,4B           NEG  @FAC1         * Negative
[3941] BAE2 D7,14,00 ZJOMO4 DCEQ >0004,@VAR9   * RIGHT

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0069 
RXB 2022
       BAE5 04
[3942] BAE6 5A,EC           BR   ZJOMO5        * Go DOWNLEFT
[3943] BAE8 86,4A           CLR @FAC           * Zero
[3944] BAEA 80,4B           ABS @FAC1          * Postive
[3945] BAEC D7,14,FC ZJOMO5 DCEQ >FCFC,@VAR9   * DOWNLEFT
       BAEF FC
[3946] BAF0 5A,F6           BR   ZJOMO6        * Go DOWNRIGHT
[3947] BAF2 80,4A           ABS  @FAC          * Postitive
[3948] BAF4 82,4B           NEG  @FAC1         * Negative
[3949] BAF6 D7,14,FC ZJOMO6 DCEQ >FC04,@VAR9   * DOWNRIGHT     
       BAF9 04
[3950] BAFA 5B,00           BR   ZJOMO7        * Go UPLEFT
[3951] BAFC 80,4A           ABS  @FAC          * Positive
[3952] BAFE 80,4B           ABS  @FAC1         * Postive
[3953] BB00 D7,14,04 ZJOMO7 DCEQ >04FC,@VAR9   * UPLEFT
       BB03 FC
[3954] BB04 5B,0A           BR   ZJOMO8        * Go UPRIGHT
[3955] BB06 82,4A           NEG  @FAC          * Negative
[3956] BB08 82,4B           NEG  @FAC1         * Negative
[3957] BB0A D7,14,04 ZJOMO8 DCEQ >0404,@VAR9   * UPRIGHT 
       BB0D 04
[3958] BB0E 5B,14           BR   ZJOMO9        * Done
[3959] BB10 82,4A           NEG  @FAC          * Negative
[3960] BB12 80,4B           ABS  @FAC1         * Positive    
[3961] BB14 BD,E4,80 ZJOMO9 DST  @FAC,V@>0480(@SPSAL) * Store velocities SPSAL
       BB17 08,4A
[3962] BB19 C4,A3,AA        CH   @NOMSPR,V@SPNUM    * Check current sprite
       BB1C 7A
[3963] BB1D 5B,23           BR   ZJOKG              *  against sprite motion
[3964]               *                              *   counter
[3965] BB1F BC,7A,A3        ST   V@SPNUM,@NOMSPR * higher? Yes, replace it
       BB22 AA
[3966]               * KEY SECTION
[3967] BB23 D6,42,B6 ZJOKG  CEQ  RPARZ,@CHAT   * )?
[3968] BB26 6A,BA           BS   LNKRTN        * Yes, END RETURN TO XB
[3969] BB28 06,AD,49        CALL ERRCOM      * Check for comma, push on stack  
[3970] BB2B BC,4B,17        ST   @FNUM,@FAC1   * KEY         
[3971] BB2E 06,A3,09        CALL CIFSND        * Convert to FP, ASSIGN     
[3972] BB31 D6,42,B6        CEQ  RPARZ,@CHAT   * )?
[3973] BB34 4D,59           BR   ERRSYN        * SYNTAX ERROR
[3974] BB36 0F,79           XML  PGMCHR        * Skip )
[3975]               * GOTO LINE# SECTION
[3976] BB38 D6,42,86        CEQ  GOTOZ,@CHAT   * GOTO flag?
[3977] BB3B 5B,55           BR   ZJOMOR        * No, just RETURN to XB
[3978] BB3D 0F,79           XML  PGMCHR        * Skip GOTO or COMMA
[3979] BB3F D6,42,C9        CEQ  LNZ,@CHAT     * Line# token?
[3980] BB42 4D,59           BR   ERRSYN        * SYNTAX ERROR
[3981] BB44 0F,79           XML  PGMCHR        * Skip line# token
[3982] BB46 BC,4A,42        ST   @CHAT,@FAC    * Store high byte line#
[3983] BB49 0F,79           XML  PGMCHR        * Skip high byte line#
[3984] BB4B BC,4B,42        ST   @CHAT,@FAC1   * Store low byte line#
[3985] BB4E 0F,79           XML  PGMCHR        * Skip low byte line#
[3986] BB50 D6,17,12        CEQ  18,@FNUM      * FIRE BUTTON 1?
[3987] BB53 79,AE           BS   GKEY1         * Yes, find & run line#
[3988] BB55 06,00,12 ZJOMOR CALL RETURN        * RETURN TO XB
[3989]               ***********************************************************
[3990]               * CALL JOYLOCATE(keyunit,X,Y,Rindex,Cindex,#sprite,dr,dc)  
[3991]               * CALL JOYLOCATE(keyunit,X,Y,Rindex,Cindex,#sprite,dr,dc,K)
[3992]               * CALL JOYLOCATE(keyunit,X,Y,Rindex,Cindex,#sprite,dr,dc,K)
[3993]               * GOTO line-number                                         
[3994]               ***********************************************************
[3995] BB58 06,B9,DA ZJOLO  CALL JOYST        * Get Key unit, X & Y 
[3996] BB5B D6,42,B3        CEQ  COMMAZ,@CHAT * COMMA?
[3997] BB5E 4D,59           BR   ERRSYN       * SYNTAX ERROR

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0070 
RXB 2022
[3998] BB60 0F,79           XML  PGMCHR       * Skip COMMA
[3999] BB62 06,B0,D5        CALL SPLOC       * Get index into SP04 & SP06
[4000] BB65 BC,00,05        ST   @SP04+1,@PAD * Get Rindex
[4001] BB68 94,00           INCT @PAD         * RESET VALUE
[4002] BB6A BC,01,06        ST   @SP06,@PAD1  * Get Cindex
[4003] BB6D 90,01           INC  @PAD1        * RESET VALUE
[4004] BB6F D6,42,B3        CEQ  COMMAZ,@CHAT   * COMMA?
[4005] BB72 4D,59           BR   ERRSYN         * SYNTAX ERROR
[4006] BB74 06,B0,B1        CALL SPNUM2         * SPSAL=SPRITE ADDRESS 
[4007] BB77 06,B1,63        CALL PREPN         * Set up for variable
[4008] BB7A BD,4A,B0        DST  V*SPSAL,@FAC * Get current dr & dc into FAC  
       BB7D 08
[4009]               *
[4010]               * CHECK DIRECTION OF JOYST AND SET UP FAC FOR LOADING VALUE
[4011] BB7E D7,14,00        DCEQ >0000,@VAR9   * >0000 JOYST
       BB81 00
[4012] BB82 7B,D8           BS   ZJOLO9        * No change 
[4013] BB84 D7,14,04 ZJOLO1 DCEQ >0400,@VAR9   * UP
       BB87 00
[4014] BB88 5B,8D           BR   ZJOLO2        * Go DOWN
[4015] BB8A A4,4A,00        SUB  @PAD,@FAC     * Negative
[4016] BB8D D7,14,FC ZJOLO2 DCEQ >FC00,@VAR9   * DOWN
       BB90 00
[4017] BB91 5B,96           BR   ZJOLO3        * Go LEFT
[4018] BB93 A0,4A,00        ADD  @PAD,@FAC     * Postive
[4019] BB96 D7,14,00 ZJOLO3 DCEQ >00FC,@VAR9   * LEFT
       BB99 FC
[4020] BB9A 5B,9F           BR   ZJOLO4        * Go RIGHT
[4021] BB9C A4,4B,00        SUB  @PAD,@FAC1    * Negative
[4022] BB9F D7,14,00 ZJOLO4 DCEQ >0004,@VAR9   * RIGHT
       BBA2 04
[4023] BBA3 5B,A8           BR   ZJOLO5        * Go DOWNLEFT
[4024] BBA5 A0,4B,00        ADD  @PAD,@FAC1    * Postive
[4025] BBA8 D7,14,FC ZJOLO5 DCEQ >FCFC,@VAR9   * DOWNLEFT
       BBAB FC
[4026] BBAC 5B,B4           BR   ZJOLO6        * Go DOWNRIGHT
[4027] BBAE A0,4A,00        ADD  @PAD,@FAC     * Postitive
[4028] BBB1 A4,4B,00        SUB  @PAD,@FAC1    * Negative
[4029] BBB4 D7,14,FC ZJOLO6 DCEQ >FC04,@VAR9   * DOWNRIGHT     
       BBB7 04
[4030] BBB8 5B,C0           BR   ZJOLO7        * Go UPLEFT
[4031] BBBA A0,4A,00        ADD  @PAD,@FAC     * Positive
[4032] BBBD A0,4B,00        ADD  @PAD,@FAC1    * Postive
[4033] BBC0 D7,14,04 ZJOLO7 DCEQ >04FC,@VAR9   * UPLEFT
       BBC3 FC
[4034] BBC4 5B,CC           BR   ZJOLO8        * Go UPRIGHT
[4035] BBC6 A4,4A,00        SUB  @PAD,@FAC     * Negative
[4036] BBC9 A4,4B,00        SUB  @PAD,@FAC1    * Negative
[4037] BBCC D7,14,04 ZJOLO8 DCEQ >0404,@VAR9   * UPRIGHT 
       BBCF 04
[4038] BBD0 5B,D8           BR   ZJOLO9        * Done
[4039] BBD2 A4,4A,00        SUB  @PAD,@FAC     * Negative
[4040] BBD5 A0,4B,00        ADD  @PAD,@FAC1    * Positive  
[4041] BBD8 BD,B0,08 ZJOLO9 DST  @FAC,V*SPSAL  * Load ROW:COL into Sprite
       BBDB 4A
[4042] BBDC BD,0C,4A        DST  @FAC,@BYTES   * Save value
[4043] BBDF 06,A3,1F        CALL CLRFAC
[4044] BBE2 BC,4B,0C        ST   @BYTES,@FAC1
[4045] BBE5 06,A3,09        CALL CIFSND     * Put into Row
[4046] BBE8 06,B1,4D        CALL COMMA2     * Next value & skip COMMA
[4047] BBEB 06,B1,63        CALL PREPN      * Prepare X-pos return variable
[4048] BBEE 06,A3,1F        CALL CLRFAC
[4049] BBF1 BC,4B,0D        ST   @BYTES+1,@FAC1 * Get X position
[4050] BBF4 06,A3,09        CALL CIFSND     * Assign value

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0071 
RXB 2022
[4051]               * KEY SECTION
[4052] BBF7 05,BB,23        B    ZJOKG
[4053]               ***********************************************************
[4054]               * CALL SWAPCHAR(character-code,character-code[,...])       
[4055]               ***********************************************************
[4056] BBFA 06,A9,21 SWCHR  CALL COMB       * SWAPCHAR(CHAR#,CHAR#)
[4057] BBFD 06,BC,AB SWCHAG CALL SSDSLL
[4058] BC00 BD,0E,4A        DST  @FAC,@VAR4
[4059] BC03 D6,42,B3        CEQ  COMMAZ,@CHAT
[4060] BC06 4D,59           BR   ERRSYN
[4061] BC08 06,BC,AB        CALL SSDSLL
[4062] BC0B BD,10,4A        DST  @FAC,@VAR5
[4063] BC0E 35,00,08        MOVE 8,V@>0300(@VAR4),@FAC
       BC11 4A,E3,00
       BC14 0E
[4064] BC15 35,00,08        MOVE 8,V@>0300(@VAR5),V@>0300(@VAR4)
       BC18 E3,00,0E
       BC1B E3,00,10
[4065] BC1E 35,00,08        MOVE 8,@FAC,V@>0300(@VAR5)
       BC21 E3,00,10
       BC24 4A
[4066] BC25 D6,42,B3        CEQ  COMMAZ,@CHAT
[4067] BC28 7B,FD           BS   SWCHAG
[4068] BC2A 4A,BA           BR   LNKRTN
[4069]               ***********************************************************
[4070]               * CALL SWAPCOLOR(#sprite-number,#sprite-number[,...])      
[4071]               * CALL SWAPCOLOR(character-set,character-set[,...])        
[4072]               ***********************************************************
[4073] BC2C 0F,7E    SWCLR  XML  SPEED            * Must be
[4074] BC2E 00              BYTE SYNCHK           *  at a
[4075] BC2F B7              BYTE LPARZ            *   left parenthesis
[4076] BC30 D6,42,FD SCOL10 CEQ  NUMBEZ,@CHAT
[4077] BC33 5C,60           BR   SCOL20
[4078] BC35 06,B0,B8        CALL SPNUM3
[4079] BC38 BC,0E,E0        ST   V@>0003(@FAC),@VAR4
       BC3B 03,4A
[4080] BC3D BD,10,4A        DST  @FAC,@VAR5
[4081] BC40 D6,42,FD        CEQ  NUMBEZ,@CHAT
[4082] BC43 4D,59           BR   ERRSYN
[4083] BC45 06,A2,AE        CALL STRFCH
[4084] BC48 06,B0,BD        CALL SPNUM4
[4085] BC4B BC,E0,03        ST   V@>0003(@FAC),V@>0003(@VAR5)
       BC4E 10,E0,03
       BC51 4A
[4086] BC52 BC,E0,03        ST   @VAR4,V@>0003(@FAC)
       BC55 4A,0E
[4087] BC57 D6,42,B3        CEQ  COMMAZ,@CHAT
[4088] BC5A 4A,BA           BR   LNKRTN
[4089] BC5C 0F,79           XML  PGMCHR
[4090] BC5E 5C,30           BR   SCOL10
[4091] BC60 0F,7E    SCOL20 XML  SPEED
[4092] BC62 01              BYTE >01
[4093] BC63 06,BC,BD        CALL S00T10
[4094] BC66 A3,4A,08        DADD >080F,@FAC
       BC69 0F
[4095] BC6A BD,0E,4A        DST  @FAC,@VAR4
[4096] BC6D 0F,74           XML  PARSE
[4097] BC6F B6              BYTE RPARZ
[4098] BC70 06,BC,BD        CALL S00T10
[4099] BC73 A3,4A,08        DADD >080F,@FAC
       BC76 0F
[4100] BC77 BC,00,B0        ST   V*FAC,@PAD
       BC7A 4A
[4101] BC7B BC,B0,4A        ST   V*VAR4,V*FAC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0072 
RXB 2022
       BC7E B0,0E
[4102] BC80 BC,B0,0E        ST   @PAD,V*VAR4
       BC83 00
[4103] BC84 D6,42,B3        CEQ  COMMAZ,@CHAT
[4104] BC87 4A,BA           BR   LNKRTN
[4105] BC89 0F,79           XML  PGMCHR
[4106] BC8B 5C,60           BR   SCOL20
[4107]               *****************************************
[4108]               * CALL CLEARPRINT
[4109]               *****************************************
[4110] BC8D BF,02,00 CLRS   DST  2,@MNUM     Row 0:Column 3
       BC90 02
[4111] BC91 BF,4A,00        DST  28,@FAC     28 length
       BC94 1C
[4112] BC95 BE,0C,18 CLRSC  ST   24,@BYTES   Number of rows
[4113] BC98 BE,00,20        ST   >20,@PAD    SPACE Character 
[4114] BC9B 86,8F,DD        CLR  @>6004      Set ROM 3 page
       BC9E 04
[4115] BC9F 0F,74    CLRSA  XML  HCHAR       Disply them
[4116] BCA1 A3,02,00        DADD 32,@MNUM    COLUMN+32
       BCA4 20
[4117] BCA5 92,0C           DEC  @BYTES      Row-1
[4118] BCA7 5C,9F           BR   CLRSA       Repeat till zero
[4119] BCA9 4A,BE           BR   LNKRT2      Return to caller
[4120]               *****************************************
[4121] BCAB 06,A2,AE SSDSLL CALL STRFCH
[4122] BCAE 06,BC,B6        CALL S1ET9F
[4123] BCB1 E3,4A,00        DSLL 3,@FAC
       BCB4 03
[4124] BCB5 00              RTN
[4125]               *****************************************
[4126] BCB6 0F,7E    S1ET9F XML  SPEED  * CHECK FROM
[4127] BCB8 02,1E           DATA >021E  * 30 TO 159
[4128] BCBA 00,9F           DATA >009F  *
[4129] BCBC 00              RTN         *
[4130]               ******************************************
[4131] BCBD 0F,7E    S00T10 XML  SPEED  * CHECK FROM
[4132] BCBF 02,00           DATA >0200  * 0 TO 16
[4133] BCC1 00,10           DATA >0010  *
[4134] BCC3 00              RTN         *
[4135]               ***********************************************************
[4136]               * RXB SIZE ADDRESS DISPLAY
[4137] BCC4 0F,83    CASCII XML  SCROLL
[4138] BCC6 BC,00,5C        ST   @ARG,@PAD         * Bit 1
[4139] BCC9 E6,00,04        SRL  4,@PAD            * Strip off Bit 2
[4140] BCCC CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4141] BCCF 7C,D6           BS   BIT1D             * Yes
[4142] BCD1 A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4143] BCD4 5C,DC           BR   BIT2              * Done Bit 1
[4144] BCD6 A6,00,0A BIT1D  SUB  10,@PAD
[4145] BCD9 A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"
[4146] BCDC BC,4A,00 BIT2   ST   @PAD,@FAC         * Save Bit 1 as ASCII
[4147] BCDF BC,00,5C        ST   @ARG,@PAD         * Bit 2
[4148] BCE2 E2,00,04        SLL  4,@PAD            * Strip off Bit 1
[4149] BCE5 E6,00,04        SRL  4,@PAD            * Reset Bit 2
[4150] BCE8 CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4151] BCEB 7C,F2           BS   BIT2D             * Yes
[4152] BCED A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4153] BCF0 5C,F8           BR   BIT3              * Done Bit 2
[4154] BCF2 A6,00,0A BIT2D  SUB  10,@PAD
[4155] BCF5 A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"          
[4156] BCF8 BC,4B,00 BIT3   ST   @PAD,@FAC1        * Save Bit 2 as ASCII      
[4157] BCFB BC,00,5D        ST   @ARG1,@PAD        * Bit 3
[4158] BCFE E6,00,04        SRL  4,@PAD            * Strip off Bit 4        

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0073 
RXB 2022
[4159] BD01 CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4160] BD04 7D,0B           BS   BIT3D             * Yes
[4161] BD06 A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4162] BD09 5D,11           BR   BIT4              * Done Bit 3
[4163] BD0B A6,00,0A BIT3D  SUB  10,@PAD
[4164] BD0E A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"
[4165] BD11 BC,4C,00 BIT4   ST   @PAD,@FAC2        * Save Bit 3 as ASCII
[4166] BD14 BC,00,5D        ST   @ARG1,@PAD        * Bit 4
[4167] BD17 E2,00,04        SLL  4,@PAD            * Strip off Bit 3
[4168] BD1A E6,00,04        SRL  4,@PAD            * Reset Bit 4
[4169] BD1D CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4170] BD20 7D,27           BS   BIT4D             * Yes
[4171] BD22 A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4172] BD25 5D,2D           BR   BITDI             * Done Bit 2
[4173] BD27 A6,00,0A BIT4D  SUB  10,@PAD
[4174] BD2A A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"          
[4175] BD2D BC,4D,00 BITDI  ST   @PAD,@FAC3        * Save Bit 2 as ASCII      
[4176] BD30 08              FMT
[4177] BD31 FC,60            SCRO >60
[4178] BD33 FE,17            ROW 23
[4179] BD35 FF,04            COL 4
[4180] BD37 40,3E            HCHA 1,62
[4181] BD39 FE,17            ROW 23
[4182] BD3B FF,05            COL 5
[4183] BD3D E3,4A            HSTR 4,@FAC   
[4184] BD3F FB              FEND
[4185] BD40 00              RTN
[4186]               ***********************************************************
[4187]               * CALL COLLIDE(#SPR1,#SPR2,TOLERANCE,S1DOTROW,S1DOTCOL)    
[4188]               * CALL COLLIDE(#SPR,DOTROW,DOTCOL,TOLERANCE,DOTROW,DOTCOL) 
[4189]                  
[4190]               ***********************************************************
[4191] BD41 06,A9,21 COLL   CALL COMB              If not '(' - error
[4192] BD44 06,B0,B1 COLL3  CALL SPNUM2            Skip ( or , get SPRITE 1 valu
[4193] BD47 BD,00,B0        DST  V*FAC,@PAD        Read ROW:COL position SPRITE1
       BD4A 4A
[4194] BD4B D6,42,C8        CEQ  NUMZ,@CHAT      #?
[4195] BD4E 5D,64           BR   COLL1             Yes SPRITE not Dot values  
[4196] BD50 06,A2,DE        CALL SUBLP4            Get DOT ROW
[4197] BD53 92,4B           DEC  @FAC1             Adjust for Assembly
[4198] BD55 BC,02,4B        ST   @FAC1,@PAD2       Save DOT ROW
[4199] BD58 06,A2,CE        CALL GETNUM            Get DOT COL 
[4200] BD5B 92,4B           DEC  @FAC1             Adjust for Assembly
[4201] BD5D BC,03,4B        ST   @FAC1,@PAD3       Save DOT COL 
[4202] BD60 0F,79           XML  PGMCHR            Skip COMMA 
[4203] BD62 5D,6B           BR   COLL2             Go to TOLLERANCE
[4204] BD64 06,B0,B3 COLL1  CALL SPNUM6            Skip # get SPRITE 2 value
[4205] BD67 BD,02,B0        DST  V*FAC,@PAD2       Read ROW:COL position SPRITE2
       BD6A 4A
[4206] BD6B 06,A2,DE COLL2  CALL SUBLP4            Get TOLERANCE in FAC     
[4207] BD6E 86,8F,DD        CLR  @>6004            Set ROM 3 page
       BD71 04
[4208] BD72 0F,80           XML  COLLSP            COLLIDE SPRITES
[4209] BD74 0F,79           XML  PGMCHR            Skip COMMA
[4210] BD76 06,A3,02        CALL SNDER            Get variable info
[4211] BD79 06,A3,1F        CALL CLRFAC           Clear for FP
[4212] BD7C BD,4A,00        DST  @PAD,@FAC        Get QUOTIENT
[4213] BD7F 06,A3,09        CALL CIFSND           Send QUOTIENT
[4214] BD82 0F,79           XML  PGMCHR           Skip COMMA
[4215] BD84 06,A3,02        CALL SNDER            Get variable info 
[4216] BD87 06,A3,1F        CALL CLRFAC           Clear for FP       
[4217] BD8A BD,4A,02        DST  @PAD2,@FAC       REMAINDER
[4218] BD8D 06,A3,09        CALL CIFSND           Send REMAINDER 
[4219] BD90 D6,42,B3        CEQ  >B3,@CHAT        ,?

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0074 
RXB 2022
[4220] BD93 7D,44           BS   COLL3            Yes loop
[4221] BD95 4A,BA           BR   LNKRTN           RETURN TO XB
[4222]               *******************************
[4223] BD97 0F,7A    SETSND XML  SYM               Pick up name & search table
[4224] BD99 0F,7B           XML  SMB               Evaluate any subscripts
[4225] BD9B C6,4C,63        CH   >63,@FAC2         If not numeric, error
[4226] BD9E 6D,91           BS   ERRIAL            ERROR INCORRECT ARGUMENT LIST
[4227] BDA0 06,A3,1F        CALL CLRFAC            Clear FAC 8 bytes
[4228] BDA3 00              RTN                    Return
[4229]               ***********************************************************
[4230]              
[4231]              
[4232]                      AORG >1FE0
[4233]               * MOSTLY SUBROUTINES FOR GROM 6
[4234] BFE0 49,21           BR   COMB        * >BFE0
[4235] BFE2 42,AE           BR   STRFCH      * >BFE2
[4236] BFE4 42,B0           BR   STRPAR      * >BFE4
[4237] BFE6 42,B4           BR   STRGET      * >BFE6
[4238] BFE8 42,BD           BR   NUMFCH      * >BFE8
[4239] BFEA 42,C6           BR   CFIFCH      * >BFEA
[4240] BFEC 42,D1           BR   GNRTN       * >BFEC
[4241] BFEE 42,E7           BR   NGOOD       * >BFEE
[4242] BFF0 43,02           BR   SNDER       * >BFF0
[4243] BFF2 43,09           BR   CIFSND      * >BFF2
[4244] BFF4 43,0B           BR   SNDASS      * >BFF4
[4245] BFF6 42,D7           BR   SUBLP3      * >BFF6
[4246] BFF8 42,DE           BR   SUBLP4      * >BFF8
[4247] BFFA 43,1F           BR   CLRFAC      * >BFFA
[4248] BFFC 42,CE           BR   GETNUM      * >BFFC
[4249]               ********************************************************
[4250]                      END

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0075 
RXB 2022
Symbol Table #1 (New,alpha)  
0041 A          00CB ABSZ       801E ACCEPT     A192 ACCEPX     00A4 ACCEPZ     
8302 ACCUM      00EC ALLZ       00BB ANDZ       00F9 APPENZ     835D ARG1       
835E ARG2       8360 ARG4       8362 ARG6       8363 ARG7       8364 ARG8       
A7F5 ASC        A46B ASC01      A474 ASC02      0076 ASCHEX     00DC ASCZ       
007C ASSGNV     B158 ASSRTN     00CC ATNZ       A7C6 ATTNUT     A915 ATTREG     
00F0 ATZ        0008 BACK       00F1 BASEZ      00EE BEEPZ      BCD6 BIT1D      
BCDC BIT2       BCF2 BIT2D      BCF8 BIT3       BD0B BIT3D      BD11 BIT4       
BD27 BIT4D      BD2D BITDI      0020 BKGD       AC6A BORAGN     AC94 BORCRN     
AC65 BORDER     AC8D BORDES     0002 BREAK      008E BREAKZ     8346 BUFLEV     
8366 BYTE1      8367 BYTE2      8368 BYTE3      830C BYTES      009D CALLZ      
BCC4 CASCII     837D CB         834E CCC        834A CCHAR      8306 CCPPTR     
0012 CFI        A2C6 CFIFCH     AD99 CHAR1      AD9B CHAR2      AB5E CHAR40     
AB1E CHAR5      AB8D CHAR50     AB9F CHARL2     ABBA CHARL3     ABF4 CHARL4     
AB1B CHARLY     8342 CHAT       6A78 CHKEND     B08B CHRALL     ABE2 CHRFIL     
007F CHRLDR     B06F CHRSET     601C CHRTAB     000D CHRTN      A450 CHRZ01     
00D6 CHRZZ      0080 CIF        A309 CIFSND     00C5 CIRCUZ     A33E CKSTNM     
B5C2 CLEAR      800A CLOSE      A18F CLOSEX     00A0 CLOSEZ     A31F CLRFAC     
0007 CLRLN      A10A CLRRTN     BC8D CLRS       BC9F CLRSA      BC95 CLRSC      
8012 CLSALL     B02F CODIST     B8DF COINLP     A869 COL08      A87C COL09      
A884 COL10      A891 COL20      A89A COL21      A8C8 COL22      BD41 COLL       
BD64 COLL1      BD6B COLL2      BD44 COLL3      0080 COLLSP     003A COLON      
00B5 COLONZ     A865 COLOR      A921 COMB       B14A COMMA1     B14D COMMA2     
002C COMMAT     00B3 COMMAZ     A3DF CONC06     A389 CONCAT     00B8 CONCZ      
A244 CONPI      0075 CONT       B2BC CONTIN     A850 CONV1      00CD COSZ       
AC4A CPAR       AC4E CPAR2      AC56 CPAR3      0820 CRNBUF     0390 CSNTMP     
03BA CSNTP1     0010 CSNUM      007E CURSOR     8334 DATA       834D DATAAD     
A7D9 DATAST     0093 DATAZ      A7F4 DATST1     8354 DDD1       0089 DEFZ       
8002 DELET      A198 DELETX     0099 DELETZ     A775 DELINK     00E9 DIGITZ     
008A DIMZ       B278 DIRSPH     B1A1 DIRSPK     B8EE DISLP      6A7C DISO       
8000 DISPL1     A195 DISPLX     00A2 DISPLZ     B007 DIST       00C4 DIVIZ      
0003 DLETE      0024 DOLLAR     000A DOWN       000A DWNARR     007F EDGECH     
8350 EEE        8358 EEE1       0081 ELSEZ      008B ENDZ       8332 ENLN       
6A80 ENT09      6A7E ENTER      801C EOF        A177 EOFX       00BE EQUALZ     
00EF ERASEZ     837C ERCODE     A816 ERORZ      ACE1 ERR10      AD89 ERRBA      
A137 ERRBRK     AD81 ERRBS      AD8D ERRBV      AD4E ERRC05     8322 ERRCOD     
AD49 ERRCOM     AD71 ERRFNN     AD91 ERRIAL     038A ERRLN      AD85 ERRLNF     
AD65 ERRMEM     AD61 ERRMUV     AD6D ERRNWF     A604 ERROLP     00A5 ERRORZ     
A0DD ERRRDY     AD79 ERRRSC     AD7D ERRRWG     AD95 ERRSNF     AD5D ERRSNM     
AD75 ERRSNS     AD69 ERRSO      B5BE ERRSSL     AD59 ERRSYN     AC9B ERRWXY     
6A84 ERRZZ      A090 EXEC       A09D EXEC1      A0B0 EXEC20     A11B EXEC6C     
A11F EXEC6D     A10E EXECBK     0076 EXECG      A0D3 EXECND     A0E1 EXECTR     
00CE EXPZZ      832E EXTRAM     0046 F          834B FAC1       8354 FAC10      
8355 FAC11      8356 FAC12      8358 FAC14      8359 FAC15      834C FAC2       
834D FAC3       834E FAC4       834F FAC5       8350 FAC6       8351 FAC7       
8352 FAC8       8353 FAC9       000A FCOMP      0009 FDIV       834E FFF        
8356 FFF1       00FA FIXEDZ     8345 FLAG       A344 FLT1       A9AA FLTS       
0008 FMUL       B3C7 FNDNUM     8317 FNUM       0009 FORW       008C FORZ       
B4BD FOUND      8340 FREPTR     A01A GA01A      A01C GA01C      A01E GA01E      
A024 GA024      A0A2 GA0AE      A0A6 GA0B2      A0F6 GA102      A1AB GA1B7      
A1B8 GA1C4      A202 GA20E      A20A GA216      A219 GA225      A221 GA22D      
A257 GA263      A371 GA420      A37C GA42B      A3AC GA45B      A48F GA53E      
A4E7 GA57C      A50F GA5A4      A519 GA5AE      A5B4 GA649      A5C4 GA659      
A5E4 GA679      A63C GA6D1      A645 GA6DA      A66A GA6FF      A68B GA720      
A6A6 GA73B      A707 GA79C      A70A GA79F      A74D GA7E2      A761 GA7F6      
A767 GA7FC      A79E GA833      A7B1 GA846      A7B5 GA84A      A7B7 GA84C      
A7C1 GA856      A7F2 GA887      A802 GA897      A810 GA8A5      A864 GA8F9      
AA9F GA919      A8FD GA995      A905 GA99D      A9D6 GAA39      A9EA GAA4D      
AB33 GAB1F      AB3C GAB28      AB7F GAB6B      AB96 GAB82      AB98 GAB84      
ABC5 GABB1      ABD7 GABC3      ABFE GABD1      AC31 GAC04      AC34 GAC07      
AC9E GAC99      ACB4 GACAF      ACBF GACBA      ACCA GACC5      ACD3 GACCE      
ACD5 GACD0      AD07 GAD03      AD0F GAD0B      AD41 GAD3E      AD44 GAD42      
AEFC GAEBB      AF22 GAEE1      AF37 GAEF6      AF3E GAEFD      AF5C GAF1C      
AF5E GAF1E      AF97 GAF56      AFAD GAF6C      B00A GAFC4      B02B GAFE5      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0076 
RXB 2022
B057 GB011      B05D GB017      B143 GB0DB      B149 GB0E1      B1BF GB158      
B1D7 GB170      B1DA GB173      B1E5 GB17E      B1EF GB188      B1FD GB196      
B207 GB1A0      B20E GB1A7      B235 GB1CE      B263 GB1FC      B265 GB1FE      
B2A8 GB241      B2BF GB258      B301 GB29C      B30F GB2AA      B350 GB2EB      
B37B GB316      B37D GB318      B3A1 GB33C      B3AB GB346      B3B4 GB34F      
B3B7 GB352      B3D5 GB370      B3E1 GB37C      B3F0 GB38B      B400 GB39B      
B411 GB3AC      B41E GB3B9      B429 GB3C4      B42A GB3C5      B439 GB3D4      
B442 GB3DD      B459 GB3F4      B469 GB404      B472 GB40D      B495 GB430      
B4B3 GB44E      B4F2 GB48D      B4FD GB498      B506 GB4A1      B525 GB4C0      
B52B GB4C6      B536 GB4D1      B54D GB4E8      AA83 GCHAR2     AA80 GCHARZ     
E025 GE025      A30E GETLP      A2CE GETNUM     B384 GETPRM     0071 GETSTR     
B401 GETTIM     B9AE GKEY1      B9B5 GKEY2      B9C9 GKEY3      B84C GMAGN      
B857 GMO1       B866 GMO2       B872 GMO3       B849 GMOT       A2D1 GNRTN      
0087 GOSUBZ     B973 GOTON0     0086 GOTOZ      0085 GOZ        AAFA GPHV       
AAFD GPHVRC     A223 GPLCAL     008C GREAD1     003E GREAT      00C0 GREATZ     
0022 GRINT      6034 GRSUB1     802C GRSUB2     802E GRSUB3     008B GVWITE     
6036 GWSUB      B7D4 HAGAIN     0074 HCHAR      AAB5 HCHAR2     AAA8 HCHARZ     
B7E2 HDONE      B6B7 HEX        B717 HEX00      B74A HEX01      B760 HEX02      
B76E HEX03      B77C HEX04      B783 HEX05      B6BA HEXAGN     B731 HEXDON     
B705 HEXNS      B70D HEXNS2     B738 HEXSTR     B7D1 HGETZ      B78D HPOUT      
0077 HPUT       B787 HPUTS      B784 HPUTZ      AADA HVCHR      AAF9 HVCHS      
B814 HVGETS     B7BD HVPUTN     002D HYPEN      0084 IFZ        00A3 IMAGEZ     
8006 INPUT      A189 INPUTX     0092 INPUTZ     0004 INSRT      A8DD INTARG     
00F5 INTERZ     A281 INTRND     00CF INTZ       B8C3 J1         B8C5 J2         
B8D1 J3         BA19 JOYAGN     B9DD JOYRPT     B9DA JOYST      B9FD JOYSTS     
8377 JOYX       A8F2 JOYXY      8376 JOYY       ABFB KEY        AC12 KEY1B      
AC36 KEY1C      AC3A KEY2       AC3C KEY2A      8374 KEYBD      B902 KEYJOY     
B922 KEYSTR     AC85 LDSCRN     A444 LEN01      A44C LEN02      8360 LENCST     
8362 LENWST     00D5 LENZ       003C LESS       00BF LESSZ      008D LETZ       
A83E LINE       A60F LINEGP     A026 LINK1      A030 LINK2      A03A LINK3      
A044 LINK4      A04E LINK5      A058 LINK6      A062 LINK7      A06B LINK8      
A073 LINK9      A07D LINKA      A088 LINKB      AD9F LINKS1     ADAA LINKS2     
ADB8 LINKS3     ADC5 LINKS4     ADCF LINKS5     ADDB LINKS6     ADE6 LINKS7     
ADF1 LINKS8     ADFD LINKS9     AE0A LINKSA     AE12 LINKSB     AE1C LINKSC     
AE28 LINKSD     AE32 LINKSE     AE3C LINKSF     AE45 LINKSG     AE4E LINKSH     
AE57 LINKSI     AE60 LINKSJ     AE6C LINKSK     AE78 LINKSL     AE80 LINKSM     
AE8E LINKSN     AE9C LINKSO     AEA9 LINKSP     AEB7 LINKSQ     AEC6 LINKSS     
8030 LINPUT     A19B LINPUX     00AA LINPUZ     0002 LISTZ      A34C LITS05     
A37D LITS06     A355 LITS07     A357 LITS08     A362 LITS09     8336 LNBUF      
A619 LNGP1      A62D LNGP2      A651 LNGP2B     A665 LNGP4      AABE LNKRT2     
AABA LNKRTN     00C9 LNZ        B552 LOADAD     0371 LODFLG     00D0 LOGZ       
B496 LOOKUP     B252 LOOP1      B294 LOOPR      B7F5 LP1        B7D7 LP2        
AC3F LPARR      00B7 LPARZ      8348 LSUBP      A261 MAXMIN     00DF MAXZ       
0008 MERGEZ     002D MINUS      00C2 MINUSZ     00E0 MINZ       8302 MNUM       
B5CA MOVES      B5CD MOVESA     B5F8 MOVESB     B613 MOVESC     B6B0 MOVESD     
B610 MOVESN     B5F2 MOVESX     B626 MTYPE      B630 MTYPE0     B638 MTYPE1     
B646 MTYPE2     B653 MTYPE3     B65D MTYPE4     B666 MTYPE5     B675 MTYPE6     
B683 MTYPE7     B68D MTYPE8     B695 MTYPE9     B6A3 MTYPEA     B61E MTYPES     
00C3 MULTZ      B15D MYNR       A5F6 NBREAK     B4D8 NEXT       B218 NEXT1      
B22D NEXT2      0096 NEXTZ      A2E7 NGOOD      A2E9 NGOOD1     0039 NINE       
02E2 NLNADD     A24C NMAX       A252 NMAXZ1     A259 NMIN       B89A NOALL      
837A NOMSPR     B47B NOTIME     00BD NOTZ       A23C NPI        800E NREAD      
A180 NREADX     A287 NRND       A28D NRND1      A29B NRND2      A29D NRND3      
A2AA NRND4      A2AC NRND5      A336 NRNDCT     A327 NRNDMZ     A5EC NTRACE     
8328 NUDTAB     A13B NUDTB      B155 NULRTN     0023 NUMBER     00FD NUMBEZ     
0000 NUMBR      00C8 NUMCOZ     B47F NUMERC     00E8 NUMERZ     A2BD NUMFCH     
A2C0 NUMSNM     A908 NUMVAR     00C8 NUMZ       A608 NUNBRK     A5F1 NUNTRC     
B892 NXALL      B2D1 NXTPAR     B542 NXTPHR     0060 OFFSET     0005 OLDZ       
A20C ONBRK      0378 ONECHR     A1CE ONERR      A1E6 ONERR2     A1FA ONERR4     
B99E ONKEY1     B981 ONLP       A19E ONWARN     A1C3 ONWRN5     A1C5 ONWRN7     
009B ONZ        8008 OPEN       A18C OPENX      009F OPENZ      009E OPTIOZ     
00BA ORZ        00F7 OUTPUZ     B027 OVER       8301 PAD1       8302 PAD2       
8303 PAD3       8304 PAD4       8306 PAD6       8308 PAD8       830A PADA       
830B PADB       0001 PARCOM     A4D2 PARFF      0074 PARSE      002E PERIOD     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0077 
RXB 2022
00FB PERMAZ     0079 PGMCHR     832C PGMPTR     835D PHDATA     8300 PHLEN      
8301 PHRADD     B39A PHRASE     00DD PIZ        002B PLUS       00C1 PLUSZ      
A528 POS01      A563 POS02      A571 POS04      A580 POS06      A582 POS08      
A587 POS10      A58F POS12      00D9 POSZ       B163 PREPN      8344 PRGFLG     
8004 PRINT      A183 PRINTX     009C PRINTZ     83CE PRTNFN     835E PTCBED     
830E PTCCIP     8308 PTCCIS     8314 PTCCPH     8304 PTEBSL     8312 PTFBPH     
8300 PTFBSL     830C PTFCIP     8306 PTFCIS     B455 PTIME      8302 PTLBSL     
834F PTLCIL     8310 PTLCIP     830A PTLCIS     8316 PTLCPH     A381 PUSSTR     
B7A4 PUTZ       B7D0 PUTZ1      0022 QUOTE      8389 RAMFLG     8386 RAMFRE     
8384 RAMTOP     AC5C RAN16      8378 RANDOM     0095 RANDOZ     0002 RANGE      
B126 RANGEV     8358 READ       B584 READAD     0097 READZ      8022 REC        
0006 RECALL     A17D RECX       00DE RECZ       00F4 RELATZ     009A REMZ       
0006 RESEQZ     800C RESTOR     A186 RESTOX     0094 RESTOZ     0088 RETURZ     
8375 RKEY       B883 RMAGN      B8A9 RMALL      B880 RMOT       B8B1 RMOTLP     
B364 RNDAG      A338 RNDM1      03A5 RNDX1      03A0 RNDX2      00D7 RNDZ       
00B6 RPARZ      A593 RPTZ01     A5D2 RPTZ02     00E1 RPTZZ      B930 RSCAN      
B939 RSCAN0     B93C RSCAN1     B940 RSCAN2     B956 RSCAN3     B957 RSCAN4     
B95C RSCAN5     0082 RTNB       8326 RTNG       A524 RTNSET     00A9 RUNZ       
BCBD S00T10     BCB6 S1ET9F     0388 SAVEVP     0007 SAVEZ      B171 SAY        
0384 SBUFLV     AF7E SCIFDN     BC30 SCOL10     BC60 SCOL20     0083 SCROLL     
AC7A SCRON      B4BE SEARCH     A3E1 SEGZ01     A425 SEGZ06     A440 SEGZ08     
00D8 SEGZZ      003B SEMICO     00B4 SEMICZ     00F6 SEQUEZ     B396 SETCB      
B5B7 SETRW      BD97 SETSND     0386 SEXTRM     0398 SFLAG      00D1 SGNZZ      
00D2 SINZ       00EB SIZEZ      0396 SLSUBP     007B SMB        AA5C SND05      
A30B SNDASS     A302 SNDER      A9B2 SNDREG     A9F4 SOUND1     AA3C SOUND2     
AA23 SOUND3     AA5A SOUND5     AA6B SOUND6     8300 SP00       8302 SP02       
8304 SP04       8306 SP06       0020 SPACE      BA78 SPAR       BA82 SPAR1      
BA9A SPAR2      B0F2 SPCHR      A8D1 SPCOL      AF04 SPDEL1     AF30 SPDEL2     
B232 SPEAK      007E SPEED      B2C8 SPGET      0382 SPGMPT     BA26 SPGS       
BA53 SPGS1      BA5E SPGS2      BA6A SPGS3      BA73 SPGS4      BA40 SPGSA      
BA75 SPGSE      8369 SPKSTS     834B SPLFLG     B0D5 SPLOC      B0D8 SPLOC2     
B104 SPMOVE     B125 SPMOVF     03AA SPNUM      B0B1 SPNUM2     B0B8 SPNUM3     
B0BD SPNUM4     B0C3 SPNUM5     B0B3 SPNUM6     AF81 SPRCOI     AF01 SPRDEL     
6016 SPRINT     AFE6 SPRLC2     AFE3 SPRLOC     AFB6 SPRMAG     AFB9 SPRMLP     
AFD3 SPRMOV     AFD6 SPRMV2     AFD9 SPRMV3     AFDC SPRMV4     AF43 SPRP02     
AF73 SPRP03     AFF7 SPRPAT     AF40 SPRPOS     AFFA SPRPT2     0300 SPRSAL     
AED8 SPRT3      AEEB SPRT4      AED2 SPRTE      07FF SPRVB      8308 SPSAL      
830A SPTMP      00D3 SQRZ       A93E SQU05      A927 SQUISH     8020 SRDATA     
831C SREF       BCAB SSDSLL     0082 SSEPZ      000C SSUB       830A STADDR     
0372 START      B59C STDATA     00B2 STEPZ      8330 STLN       0098 STOPZ      
A2AE STRFCH     A2B4 STRGET     00C7 STRINZ     8364 STRLEN     A2B0 STRPAR     
8312 STRPTR     0065 STRVAL     A47C STRZ01     A481 STRZ02     00DB STRZZ      
8324 STVSPT     A2D7 SUBLP3     A2DE SUBLP4     00A8 SUBNDZ     00A7 SUBXTZ     
00A1 SUBZ       BBFD SWCHAG     BBFA SWCHR      BC2C SWCLR      007A SYM        
0376 SYMBOL     833E SYMTAB     0000 SYNCHK     63A5 SZNEW      601E SZRUN      
A17A SZRUNX     00FC TABZ       00D4 TANZ       8354 TEMP1      8356 TEMP2      
8364 TEMP4      8366 TEMP5      8368 TEMP6      00B0 THENZ      8379 TIMER      
B3F1 TIMING     8351 TIMLEN     63DD TOPL15     6372 TOPLEV     8310 TOPSTK     
834C TOTTIM     00B1 TOZ        0090 TRACEZ     0083 TREMZ      B498 TRYAGN     
00EA UALPHZ     A667 UBSUB      A677 UBSUB1     A682 UDF        A662 UNBK01     
008F UNBREZ     00C8 UNQSTZ     0091 UNTRAZ     000B UPARR      00F8 UPDATZ     
000B UPMV       00ED USINGZ     B7F2 VAGAIN     00DA VAL        A4A6 VAL01      
A4B8 VAL05      A4DC VALCD      00FE VALIDZ     A4CB VALNUM     830E VAR4       
8310 VAR5       8311 VAR6       8312 VAR7       8314 VAR9       00F3 VARIAZ     
8320 VARW       8304 VARY       8306 VARY2      0075 VCHAR      AAD3 VCHAR2     
AAC6 VCHARZ     B80A VDONE      83D4 VDPR1      837B VDPSTT     B7EF VGETZ      
0078 VPOP       B79D VPOUT      0077 VPUSH      0078 VPUT       B797 VPUTS      
B794 VPUTZ      0379 VRMSND     03C0 VROAZ      001C VWIDTH     B5AC WAIT       
A0C8 WARNGZ     00A6 WARNZ      6A82 WARNZZ     835A WRITE      A65C WRNLNF     
A0CD WRNN01     A85C WRNNO      A3A8 WRNST1     A5AC WRNST2     0003 X2         
0073 XBCNS      8316 XFLAG      A5EF XMLCON     00BC XORZ       B7EA XPTRTN     
A9BB XSOUND     B8EB ZDIST      0030 ZERO       BB23 ZJOKG      BB58 ZJOLO      
BB84 ZJOLO1     BB8D ZJOLO2     BB96 ZJOLO3     BB9F ZJOLO4     BBA8 ZJOLO5     
BBB4 ZJOLO6     BBC0 ZJOLO7     BBCC ZJOLO8     BBD8 ZJOLO9     BA9F ZJOMO      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0078 
RXB 2022
BAC4 ZJOMO1     BACE ZJOMO2     BAD8 ZJOMO3     BAE2 ZJOMO4     BAEC ZJOMO5     
BAF6 ZJOMO6     BB00 ZJOMO7     BB0A ZJOMO8     BB14 ZJOMO9     BB55 ZJOMOR     
BA16 ZJOYST     B8F8 ZKEY       B963 ZONKEY     B8DC ZSCOI      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0079 
RXB 2022
Symbol Table #2 (New,value)  
0000 NUMBR      0000 SYNCHK     0001 PARCOM     0002 BREAK      0002 LISTZ      
0002 RANGE      0003 DLETE      0003 X2         0004 INSRT      0005 OLDZ       
0006 RECALL     0006 RESEQZ     0007 CLRLN      0007 SAVEZ      0008 BACK       
0008 FMUL       0008 MERGEZ     0009 FDIV       0009 FORW       000A DOWN       
000A DWNARR     000A FCOMP      000B UPARR      000B UPMV       000C SSUB       
000D CHRTN      0010 CSNUM      0012 CFI        001C VWIDTH     0020 BKGD       
0020 SPACE      0022 GRINT      0022 QUOTE      0023 NUMBER     0024 DOLLAR     
002B PLUS       002C COMMAT     002D HYPEN      002D MINUS      002E PERIOD     
0030 ZERO       0039 NINE       003A COLON      003B SEMICO     003C LESS       
003E GREAT      0041 A          0046 F          0060 OFFSET     0065 STRVAL     
0071 GETSTR     0073 XBCNS      0074 HCHAR      0074 PARSE      0075 CONT       
0075 VCHAR      0076 ASCHEX     0076 EXECG      0077 HPUT       0077 VPUSH      
0078 VPOP       0078 VPUT       0079 PGMCHR     007A SYM        007B SMB        
007C ASSGNV     007E CURSOR     007E SPEED      007F CHRLDR     007F EDGECH     
0080 CIF        0080 COLLSP     0081 ELSEZ      0082 RTNB       0082 SSEPZ      
0083 SCROLL     0083 TREMZ      0084 IFZ        0085 GOZ        0086 GOTOZ      
0087 GOSUBZ     0088 RETURZ     0089 DEFZ       008A DIMZ       008B ENDZ       
008B GVWITE     008C FORZ       008C GREAD1     008D LETZ       008E BREAKZ     
008F UNBREZ     0090 TRACEZ     0091 UNTRAZ     0092 INPUTZ     0093 DATAZ      
0094 RESTOZ     0095 RANDOZ     0096 NEXTZ      0097 READZ      0098 STOPZ      
0099 DELETZ     009A REMZ       009B ONZ        009C PRINTZ     009D CALLZ      
009E OPTIOZ     009F OPENZ      00A0 CLOSEZ     00A1 SUBZ       00A2 DISPLZ     
00A3 IMAGEZ     00A4 ACCEPZ     00A5 ERRORZ     00A6 WARNZ      00A7 SUBXTZ     
00A8 SUBNDZ     00A9 RUNZ       00AA LINPUZ     00B0 THENZ      00B1 TOZ        
00B2 STEPZ      00B3 COMMAZ     00B4 SEMICZ     00B5 COLONZ     00B6 RPARZ      
00B7 LPARZ      00B8 CONCZ      00BA ORZ        00BB ANDZ       00BC XORZ       
00BD NOTZ       00BE EQUALZ     00BF LESSZ      00C0 GREATZ     00C1 PLUSZ      
00C2 MINUSZ     00C3 MULTZ      00C4 DIVIZ      00C5 CIRCUZ     00C7 STRINZ     
00C8 NUMCOZ     00C8 NUMZ       00C8 UNQSTZ     00C9 LNZ        00CB ABSZ       
00CC ATNZ       00CD COSZ       00CE EXPZZ      00CF INTZ       00D0 LOGZ       
00D1 SGNZZ      00D2 SINZ       00D3 SQRZ       00D4 TANZ       00D5 LENZ       
00D6 CHRZZ      00D7 RNDZ       00D8 SEGZZ      00D9 POSZ       00DA VAL        
00DB STRZZ      00DC ASCZ       00DD PIZ        00DE RECZ       00DF MAXZ       
00E0 MINZ       00E1 RPTZZ      00E8 NUMERZ     00E9 DIGITZ     00EA UALPHZ     
00EB SIZEZ      00EC ALLZ       00ED USINGZ     00EE BEEPZ      00EF ERASEZ     
00F0 ATZ        00F1 BASEZ      00F3 VARIAZ     00F4 RELATZ     00F5 INTERZ     
00F6 SEQUEZ     00F7 OUTPUZ     00F8 UPDATZ     00F9 APPENZ     00FA FIXEDZ     
00FB PERMAZ     00FC TABZ       00FD NUMBEZ     00FE VALIDZ     02E2 NLNADD     
0300 SPRSAL     0371 LODFLG     0372 START      0376 SYMBOL     0378 ONECHR     
0379 VRMSND     0382 SPGMPT     0384 SBUFLV     0386 SEXTRM     0388 SAVEVP     
038A ERRLN      0390 CSNTMP     0396 SLSUBP     0398 SFLAG      03A0 RNDX2      
03A5 RNDX1      03AA SPNUM      03BA CSNTP1     03C0 VROAZ      07FF SPRVB      
0820 CRNBUF     6016 SPRINT     601C CHRTAB     601E SZRUN      6034 GRSUB1     
6036 GWSUB      6372 TOPLEV     63A5 SZNEW      63DD TOPL15     6A78 CHKEND     
6A7C DISO       6A7E ENTER      6A80 ENT09      6A82 WARNZZ     6A84 ERRZZ      
8000 DISPL1     8002 DELET      8004 PRINT      8006 INPUT      8008 OPEN       
800A CLOSE      800C RESTOR     800E NREAD      8012 CLSALL     801C EOF        
801E ACCEPT     8020 SRDATA     8022 REC        802C GRSUB2     802E GRSUB3     
8030 LINPUT     8300 PHLEN      8300 PTFBSL     8300 SP00       8301 PAD1       
8301 PHRADD     8302 ACCUM      8302 MNUM       8302 PAD2       8302 PTLBSL     
8302 SP02       8303 PAD3       8304 PAD4       8304 PTEBSL     8304 SP04       
8304 VARY       8306 CCPPTR     8306 PAD6       8306 PTFCIS     8306 SP06       
8306 VARY2      8308 PAD8       8308 PTCCIS     8308 SPSAL      830A PADA       
830A PTLCIS     830A SPTMP      830A STADDR     830B PADB       830C BYTES      
830C PTFCIP     830E PTCCIP     830E VAR4       8310 PTLCIP     8310 TOPSTK     
8310 VAR5       8311 VAR6       8312 PTFBPH     8312 STRPTR     8312 VAR7       
8314 PTCCPH     8314 VAR9       8316 PTLCPH     8316 XFLAG      8317 FNUM       
831C SREF       8320 VARW       8322 ERRCOD     8324 STVSPT     8326 RTNG       
8328 NUDTAB     832C PGMPTR     832E EXTRAM     8330 STLN       8332 ENLN       
8334 DATA       8336 LNBUF      833E SYMTAB     8340 FREPTR     8342 CHAT       
8344 PRGFLG     8345 FLAG       8346 BUFLEV     8348 LSUBP      834A CCHAR      
834B FAC1       834B SPLFLG     834C FAC2       834C TOTTIM     834D DATAAD     
834D FAC3       834E CCC        834E FAC4       834E FFF        834F FAC5       

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0080 
RXB 2022
834F PTLCIL     8350 EEE        8350 FAC6       8351 FAC7       8351 TIMLEN     
8352 FAC8       8353 FAC9       8354 DDD1       8354 FAC10      8354 TEMP1      
8355 FAC11      8356 FAC12      8356 FFF1       8356 TEMP2      8358 EEE1       
8358 FAC14      8358 READ       8359 FAC15      835A WRITE      835D ARG1       
835D PHDATA     835E ARG2       835E PTCBED     8360 ARG4       8360 LENCST     
8362 ARG6       8362 LENWST     8363 ARG7       8364 ARG8       8364 STRLEN     
8364 TEMP4      8366 BYTE1      8366 TEMP5      8367 BYTE2      8368 BYTE3      
8368 TEMP6      8369 SPKSTS     8374 KEYBD      8375 RKEY       8376 JOYY       
8377 JOYX       8378 RANDOM     8379 TIMER      837A NOMSPR     837B VDPSTT     
837C ERCODE     837D CB         8384 RAMTOP     8386 RAMFRE     8389 RAMFLG     
83CE PRTNFN     83D4 VDPR1      A01A GA01A      A01C GA01C      A01E GA01E      
A024 GA024      A026 LINK1      A030 LINK2      A03A LINK3      A044 LINK4      
A04E LINK5      A058 LINK6      A062 LINK7      A06B LINK8      A073 LINK9      
A07D LINKA      A088 LINKB      A090 EXEC       A09D EXEC1      A0A2 GA0AE      
A0A6 GA0B2      A0B0 EXEC20     A0C8 WARNGZ     A0CD WRNN01     A0D3 EXECND     
A0DD ERRRDY     A0E1 EXECTR     A0F6 GA102      A10A CLRRTN     A10E EXECBK     
A11B EXEC6C     A11F EXEC6D     A137 ERRBRK     A13B NUDTB      A177 EOFX       
A17A SZRUNX     A17D RECX       A180 NREADX     A183 PRINTX     A186 RESTOX     
A189 INPUTX     A18C OPENX      A18F CLOSEX     A192 ACCEPX     A195 DISPLX     
A198 DELETX     A19B LINPUX     A19E ONWARN     A1AB GA1B7      A1B8 GA1C4      
A1C3 ONWRN5     A1C5 ONWRN7     A1CE ONERR      A1E6 ONERR2     A1FA ONERR4     
A202 GA20E      A20A GA216      A20C ONBRK      A219 GA225      A221 GA22D      
A223 GPLCAL     A23C NPI        A244 CONPI      A24C NMAX       A252 NMAXZ1     
A257 GA263      A259 NMIN       A261 MAXMIN     A281 INTRND     A287 NRND       
A28D NRND1      A29B NRND2      A29D NRND3      A2AA NRND4      A2AC NRND5      
A2AE STRFCH     A2B0 STRPAR     A2B4 STRGET     A2BD NUMFCH     A2C0 NUMSNM     
A2C6 CFIFCH     A2CE GETNUM     A2D1 GNRTN      A2D7 SUBLP3     A2DE SUBLP4     
A2E7 NGOOD      A2E9 NGOOD1     A302 SNDER      A309 CIFSND     A30B SNDASS     
A30E GETLP      A31F CLRFAC     A327 NRNDMZ     A336 NRNDCT     A338 RNDM1      
A33E CKSTNM     A344 FLT1       A34C LITS05     A355 LITS07     A357 LITS08     
A362 LITS09     A371 GA420      A37C GA42B      A37D LITS06     A381 PUSSTR     
A389 CONCAT     A3A8 WRNST1     A3AC GA45B      A3DF CONC06     A3E1 SEGZ01     
A425 SEGZ06     A440 SEGZ08     A444 LEN01      A44C LEN02      A450 CHRZ01     
A46B ASC01      A474 ASC02      A47C STRZ01     A481 STRZ02     A48F GA53E      
A4A6 VAL01      A4B8 VAL05      A4CB VALNUM     A4D2 PARFF      A4DC VALCD      
A4E7 GA57C      A50F GA5A4      A519 GA5AE      A524 RTNSET     A528 POS01      
A563 POS02      A571 POS04      A580 POS06      A582 POS08      A587 POS10      
A58F POS12      A593 RPTZ01     A5AC WRNST2     A5B4 GA649      A5C4 GA659      
A5D2 RPTZ02     A5E4 GA679      A5EC NTRACE     A5EF XMLCON     A5F1 NUNTRC     
A5F6 NBREAK     A604 ERROLP     A608 NUNBRK     A60F LINEGP     A619 LNGP1      
A62D LNGP2      A63C GA6D1      A645 GA6DA      A651 LNGP2B     A65C WRNLNF     
A662 UNBK01     A665 LNGP4      A667 UBSUB      A66A GA6FF      A677 UBSUB1     
A682 UDF        A68B GA720      A6A6 GA73B      A707 GA79C      A70A GA79F      
A74D GA7E2      A761 GA7F6      A767 GA7FC      A775 DELINK     A79E GA833      
A7B1 GA846      A7B5 GA84A      A7B7 GA84C      A7C1 GA856      A7C6 ATTNUT     
A7D9 DATAST     A7F2 GA887      A7F4 DATST1     A7F5 ASC        A802 GA897      
A810 GA8A5      A816 ERORZ      A83E LINE       A850 CONV1      A85C WRNNO      
A864 GA8F9      A865 COLOR      A869 COL08      A87C COL09      A884 COL10      
A891 COL20      A89A COL21      A8C8 COL22      A8D1 SPCOL      A8DD INTARG     
A8F2 JOYXY      A8FD GA995      A905 GA99D      A908 NUMVAR     A915 ATTREG     
A921 COMB       A927 SQUISH     A93E SQU05      A9AA FLTS       A9B2 SNDREG     
A9BB XSOUND     A9D6 GAA39      A9EA GAA4D      A9F4 SOUND1     AA23 SOUND3     
AA3C SOUND2     AA5A SOUND5     AA5C SND05      AA6B SOUND6     AA80 GCHARZ     
AA83 GCHAR2     AA9F GA919      AAA8 HCHARZ     AAB5 HCHAR2     AABA LNKRTN     
AABE LNKRT2     AAC6 VCHARZ     AAD3 VCHAR2     AADA HVCHR      AAF9 HVCHS      
AAFA GPHV       AAFD GPHVRC     AB1B CHARLY     AB1E CHAR5      AB33 GAB1F      
AB3C GAB28      AB5E CHAR40     AB7F GAB6B      AB8D CHAR50     AB96 GAB82      
AB98 GAB84      AB9F CHARL2     ABBA CHARL3     ABC5 GABB1      ABD7 GABC3      
ABE2 CHRFIL     ABF4 CHARL4     ABFB KEY        ABFE GABD1      AC12 KEY1B      
AC31 GAC04      AC34 GAC07      AC36 KEY1C      AC3A KEY2       AC3C KEY2A      
AC3F LPARR      AC4A CPAR       AC4E CPAR2      AC56 CPAR3      AC5C RAN16      
AC65 BORDER     AC6A BORAGN     AC7A SCRON      AC85 LDSCRN     AC8D BORDES     
AC94 BORCRN     AC9B ERRWXY     AC9E GAC99      ACB4 GACAF      ACBF GACBA      
ACCA GACC5      ACD3 GACCE      ACD5 GACD0      ACE1 ERR10      AD07 GAD03      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0081 
RXB 2022
AD0F GAD0B      AD41 GAD3E      AD44 GAD42      AD49 ERRCOM     AD4E ERRC05     
AD59 ERRSYN     AD5D ERRSNM     AD61 ERRMUV     AD65 ERRMEM     AD69 ERRSO      
AD6D ERRNWF     AD71 ERRFNN     AD75 ERRSNS     AD79 ERRRSC     AD7D ERRRWG     
AD81 ERRBS      AD85 ERRLNF     AD89 ERRBA      AD8D ERRBV      AD91 ERRIAL     
AD95 ERRSNF     AD99 CHAR1      AD9B CHAR2      AD9F LINKS1     ADAA LINKS2     
ADB8 LINKS3     ADC5 LINKS4     ADCF LINKS5     ADDB LINKS6     ADE6 LINKS7     
ADF1 LINKS8     ADFD LINKS9     AE0A LINKSA     AE12 LINKSB     AE1C LINKSC     
AE28 LINKSD     AE32 LINKSE     AE3C LINKSF     AE45 LINKSG     AE4E LINKSH     
AE57 LINKSI     AE60 LINKSJ     AE6C LINKSK     AE78 LINKSL     AE80 LINKSM     
AE8E LINKSN     AE9C LINKSO     AEA9 LINKSP     AEB7 LINKSQ     AEC6 LINKSS     
AED2 SPRTE      AED8 SPRT3      AEEB SPRT4      AEFC GAEBB      AF01 SPRDEL     
AF04 SPDEL1     AF22 GAEE1      AF30 SPDEL2     AF37 GAEF6      AF3E GAEFD      
AF40 SPRPOS     AF43 SPRP02     AF5C GAF1C      AF5E GAF1E      AF73 SPRP03     
AF7E SCIFDN     AF81 SPRCOI     AF97 GAF56      AFAD GAF6C      AFB6 SPRMAG     
AFB9 SPRMLP     AFD3 SPRMOV     AFD6 SPRMV2     AFD9 SPRMV3     AFDC SPRMV4     
AFE3 SPRLOC     AFE6 SPRLC2     AFF7 SPRPAT     AFFA SPRPT2     B007 DIST       
B00A GAFC4      B027 OVER       B02B GAFE5      B02F CODIST     B057 GB011      
B05D GB017      B06F CHRSET     B08B CHRALL     B0B1 SPNUM2     B0B3 SPNUM6     
B0B8 SPNUM3     B0BD SPNUM4     B0C3 SPNUM5     B0D5 SPLOC      B0D8 SPLOC2     
B0F2 SPCHR      B104 SPMOVE     B125 SPMOVF     B126 RANGEV     B143 GB0DB      
B149 GB0E1      B14A COMMA1     B14D COMMA2     B155 NULRTN     B158 ASSRTN     
B15D MYNR       B163 PREPN      B171 SAY        B1A1 DIRSPK     B1BF GB158      
B1D7 GB170      B1DA GB173      B1E5 GB17E      B1EF GB188      B1FD GB196      
B207 GB1A0      B20E GB1A7      B218 NEXT1      B22D NEXT2      B232 SPEAK      
B235 GB1CE      B252 LOOP1      B263 GB1FC      B265 GB1FE      B278 DIRSPH     
B294 LOOPR      B2A8 GB241      B2BC CONTIN     B2BF GB258      B2C8 SPGET      
B2D1 NXTPAR     B301 GB29C      B30F GB2AA      B350 GB2EB      B364 RNDAG      
B37B GB316      B37D GB318      B384 GETPRM     B396 SETCB      B39A PHRASE     
B3A1 GB33C      B3AB GB346      B3B4 GB34F      B3B7 GB352      B3C7 FNDNUM     
B3D5 GB370      B3E1 GB37C      B3F0 GB38B      B3F1 TIMING     B400 GB39B      
B401 GETTIM     B411 GB3AC      B41E GB3B9      B429 GB3C4      B42A GB3C5      
B439 GB3D4      B442 GB3DD      B455 PTIME      B459 GB3F4      B469 GB404      
B472 GB40D      B47B NOTIME     B47F NUMERC     B495 GB430      B496 LOOKUP     
B498 TRYAGN     B4B3 GB44E      B4BD FOUND      B4BE SEARCH     B4D8 NEXT       
B4F2 GB48D      B4FD GB498      B506 GB4A1      B525 GB4C0      B52B GB4C6      
B536 GB4D1      B542 NXTPHR     B54D GB4E8      B552 LOADAD     B584 READAD     
B59C STDATA     B5AC WAIT       B5B7 SETRW      B5BE ERRSSL     B5C2 CLEAR      
B5CA MOVES      B5CD MOVESA     B5F2 MOVESX     B5F8 MOVESB     B610 MOVESN     
B613 MOVESC     B61E MTYPES     B626 MTYPE      B630 MTYPE0     B638 MTYPE1     
B646 MTYPE2     B653 MTYPE3     B65D MTYPE4     B666 MTYPE5     B675 MTYPE6     
B683 MTYPE7     B68D MTYPE8     B695 MTYPE9     B6A3 MTYPEA     B6B0 MOVESD     
B6B7 HEX        B6BA HEXAGN     B705 HEXNS      B70D HEXNS2     B717 HEX00      
B731 HEXDON     B738 HEXSTR     B74A HEX01      B760 HEX02      B76E HEX03      
B77C HEX04      B783 HEX05      B784 HPUTZ      B787 HPUTS      B78D HPOUT      
B794 VPUTZ      B797 VPUTS      B79D VPOUT      B7A4 PUTZ       B7BD HVPUTN     
B7D0 PUTZ1      B7D1 HGETZ      B7D4 HAGAIN     B7D7 LP2        B7E2 HDONE      
B7EA XPTRTN     B7EF VGETZ      B7F2 VAGAIN     B7F5 LP1        B80A VDONE      
B814 HVGETS     B849 GMOT       B84C GMAGN      B857 GMO1       B866 GMO2       
B872 GMO3       B880 RMOT       B883 RMAGN      B892 NXALL      B89A NOALL      
B8A9 RMALL      B8B1 RMOTLP     B8C3 J1         B8C5 J2         B8D1 J3         
B8DC ZSCOI      B8DF COINLP     B8EB ZDIST      B8EE DISLP      B8F8 ZKEY       
B902 KEYJOY     B922 KEYSTR     B930 RSCAN      B939 RSCAN0     B93C RSCAN1     
B940 RSCAN2     B956 RSCAN3     B957 RSCAN4     B95C RSCAN5     B963 ZONKEY     
B973 GOTON0     B981 ONLP       B99E ONKEY1     B9AE GKEY1      B9B5 GKEY2      
B9C9 GKEY3      B9DA JOYST      B9DD JOYRPT     B9FD JOYSTS     BA16 ZJOYST     
BA19 JOYAGN     BA26 SPGS       BA40 SPGSA      BA53 SPGS1      BA5E SPGS2      
BA6A SPGS3      BA73 SPGS4      BA75 SPGSE      BA78 SPAR       BA82 SPAR1      
BA9A SPAR2      BA9F ZJOMO      BAC4 ZJOMO1     BACE ZJOMO2     BAD8 ZJOMO3     
BAE2 ZJOMO4     BAEC ZJOMO5     BAF6 ZJOMO6     BB00 ZJOMO7     BB0A ZJOMO8     
BB14 ZJOMO9     BB23 ZJOKG      BB55 ZJOMOR     BB58 ZJOLO      BB84 ZJOLO1     
BB8D ZJOLO2     BB96 ZJOLO3     BB9F ZJOLO4     BBA8 ZJOLO5     BBB4 ZJOLO6     
BBC0 ZJOLO7     BBCC ZJOLO8     BBD8 ZJOLO9     BBFA SWCHR      BBFD SWCHAG     
BC2C SWCLR      BC30 SCOL10     BC60 SCOL20     BC8D CLRS       BC95 CLRSC      
BC9F CLRSA      BCAB SSDSLL     BCB6 S1ET9F     BCBD S00T10     BCC4 CASCII     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0082 
RXB 2022
BCD6 BIT1D      BCDC BIT2       BCF2 BIT2D      BCF8 BIT3       BD0B BIT3D      
BD11 BIT4       BD27 BIT4D      BD2D BITDI      BD41 COLL       BD44 COLL3      
BD64 COLL1      BD6B COLL2      BD97 SETSND     E025 GE025      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0083 
RXB 2022
Symbol Table #4 (Def,alpha)  
0034 ACCTON     835C ARG        0032 ATN        0036 BADTON     003B BITREV     
0012 CFI        0014 CNS        002C COS        0010 CSN        8372 DATSTK     
0001 DIVZER     0003 ERRIOV     0006 ERRLOG     0005 ERRNIP     0002 ERRSNN     
0004 ERRSQR     0028 EXP        834A FAC        0006 FADD       000A FCOMP      
0009 FDIV       0008 FMUL       836C FPERAD     0007 FSUB       0038 GETSPACE   
0022 INT        0010 LINK       0018 LOCASE     002A LOG        8370 MEMSIZ     
003D NAMLNK     8300 PAD        0024 PWR        0012 RETURN     000B SADD       
000F SCOMP      000E SDIV       8375 SGN        002E SIN        000D SMUL       
8400 SOUND      0026 SQR        000C SSUB       837C STATUS     0016 STCASE     
8373 SUBSTK     0030 TAN        0007 TRIGER     004A UPCASE     836E VSPTR      
0001 WRNOV      837F XPT        837E YPT        

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0084 
RXB 2022
Symbol Table #8 (Def,value)  
0001 DIVZER     0001 WRNOV      0002 ERRSNN     0003 ERRIOV     0004 ERRSQR     
0005 ERRNIP     0006 ERRLOG     0006 FADD       0007 FSUB       0007 TRIGER     
0008 FMUL       0009 FDIV       000A FCOMP      000B SADD       000C SSUB       
000D SMUL       000E SDIV       000F SCOMP      0010 CSN        0010 LINK       
0012 CFI        0012 RETURN     0014 CNS        0016 STCASE     0018 LOCASE     
0022 INT        0024 PWR        0026 SQR        0028 EXP        002A LOG        
002C COS        002E SIN        0030 TAN        0032 ATN        0034 ACCTON     
0036 BADTON     0038 GETSPACE   003B BITREV     003D NAMLNK     004A UPCASE     
8300 PAD        834A FAC        835C ARG        836C FPERAD     836E VSPTR      
8370 MEMSIZ     8372 DATSTK     8373 SUBSTK     8375 SGN        837C STATUS     
837E YPT        837F XPT        8400 SOUND      
